{"version":3,"sources":["jsviews.js"],"names":["factory","global","$","jQuery","exports","module","define","amd","getDerivedMethod","baseMethod","method","ret","tag","this","prevBase","base","apply","arguments","getMethod","$isFunction","_d","noop","tagHandlersFromProps","tagCtx","prop","props","rHasHandlers","test","fix","constructor","prototype","retVal","val","dbgBreak","console","log","e","baseApply","JsViewsError","message","name","link","$extend","target","source","$viewsDelimiters","openChars","closeChars","$isArray","$views","linkChar","error","delimOpenChar0","delimOpenChar1","delimCloseChar0","delimCloseChar1","$subSettings","delimiters","rTag","$sub","RegExp","rTmpl","$viewsSettings","getView","inner","type","undefined","views","i","l","found","view","root","_","useKey","get","length","parent","getNestedIndex","index","getIndex","getPathObject","ob","path","ltOb","fn","prevOb","tokens","split","lt","contextParameter","key","value","wrapped","deps","res","obsCtxPrm","tagElse","callView","newRes","storeView","isUpdate","isRenderCall","store","ctx","hasOwnProperty","$helpers","it","linked","_cxp","scope","isTop","_ocps","_ocp","_vw","_key","ind","updateValue","observable","setProperty","_ceo","unshift","cvtArgs","data","_ucp","getTemplate","tmpl","getRsc","$templates","convertVal","converter","onError","linkCtx","argsLen","bindTo","boundTag","bnds","_lr","args","_bd","_lc","_tg","bnd","unlinked","inline","tagName","convert","flow","tagCtxs","_is","extendCtx","_er","onRender","convertArgs","bound","boundArgs","bindFrom","slice","argOrProp","context","convertBoundArgs","getResource","resourceType","itemName","renderTag","parentView","bindToOrBindFrom","bindArray","m","isNaN","parseInt","topView","tagDef","template","tags","attr","parentTag","n","itemRet","tagCtxCtx","ctxPrm","initVal","content","callInit","mapDef","thisMap","bdArgs","tagDataMap","contentCtx","bindFromLength","bindToLength","linkedElement","defaultCtx","parentTmpl","lateRender","params","tmpls","render","renderContent","bndArgs","_getTmpl","init","_ctr","ths","arrVws","dataBoundOnly","dataMap","map","parents","parentTags","rendering","rndr","argDefault","linkedCtxParam","fromIndex","toIndex","_dfAt","noVws","HTML","_cp","cvt","src","unmap","tgt","rWrappedInViewMarker","links","renderWithViews","$converters","html","View","contentTmpl","parentView_","self_","self","isArray","id","viewId","scp","indexStr","push","splice","compileChildResources","storeName","storeNames","resources","jsvStores","compileTag","Tag","baseTag","compiledDef","depends","$tags","_parentTmpl","compileTmpl","options","lookupTemplate","currentName","nodeType","elem","document","getElementById","innerHTML","getAttribute","tmplAttr","jsvTmpl","tmplName","setAttribute","compiledTmpl","tmplOrMarkup","_html","markup","tmplObject","tmplFn","replace","rEscapeQuotes","getDefaultVal","defaultVal","call","unmapArray","modelArr","arr","compileViewModel","GetNew","vm","iterate","action","getterType","j","g","getters","getter","viewModels","JSON","parse","merge","viewModel","$expando","getterNames","mod","assigned","newModArr","k","model","$observable","refresh","concat","charAt","extend","proto","body","privField","set","Function","htmlTag","wrapMap","$subSettingsAdvanced","_wm","rFirstElem","exec","toLowerCase","div","trim","registerStore","storeSettings","theStore","item","compile","thisStore","onStore","OBJECT","getTgt","addSetting","st","Map","baseMap","noIteration","isTopRenderCall","prevData","prevIndex","result","useViews","setItemVar","newCtx","itemVar","newView","childView","itemResult","swapContent","outerOnRender","noLinking","_wrp","syntaxError","nl","helpers","contentView","onRenderError","fallback","Err","isLinkExpr","convertBack","hasElse","pushprecedingContent","shift","loc","substr","rNewLine","blockTagCheck","block","parseTag","all","bind","colon","codeTag","slash","bind2","closeBlock","late","openTagName","isLateOb","pathBindings","ctxProps","paramsArgs","paramsProps","paramsCtxProps","useTrigger","allowCode","rUnescapeQuotes","rTestElseIf","current","substring","stack","pop","parseParams","rBuildHash","onerror","isCtxPrm","keyToken","keyValue","arg","param","hasHandlers","newNode","parsedParam","bindings","astTop","buildCode","setPaths","pathsArr","paths","skp","paramStructure","parts","parseTokens","lftPrn0","lftPrn","operator","err","eq","path2","prn","comma","lftPrn2","apos","quot","rtPrn","rtPrnDot","prn2","space","full","parsePath","allPath","not","object","helper","viewProperty","pathTokens","leafToken","subPath","binds","named","bindto","_jsvto","bndCtx","bd","theOb","_cpfn","sb","pathStart","parenDepth","join","expr","exprFn","newOb","rtSq","aposed","quoted","bndStack","prm","tmplLinks","indexOf","paramIndex","boundName","rPath","fnCall","0","rBracketQuote","rPrm","ast","node","hasTag","hasEncoder","getsVal","hasCnvt","useCnvt","tmplBindings","boundOnErrStart","boundOnErrEnd","tagRender","nestedTmpls","nestedTmpl","tagAndElses","nextIsElse","oldCode","isElse","isGetVal","tagCtxFn","tagStart","trigger","retStrOpen","retStrClose","tmplBindingKey","templates","converters","code","tmplOptions","debug","debugMode","_tag","parentContext","getTargetProps","propsArr","noFunctions","isFunction","getTargetSorted","mapped","start","end","propParams","filter","sort","directSort","step","reverse","v","a","b","onFilter","sorted","paged","$fnRender","tmplElem","jquery","getCharEntity","ch","charEntities","charCodeAt","getCharFromEntity","match","token","charsFromEntities","htmlEncode","text","rIsHtml","rHtmlEncode","dataEncode","rDataEncode","dataUnencode","rDataUnencode","updateValues","sourceValues","bindId","ev","cvtBack","cnvtName","binding","sourceValue","origVals","sourceElem","sourceEl","tos","to","tcpTag","exprOb","contextCb","_tgId","defineBindToDataTargets","bindingStore","chg","nodeName","multiple","_jsvSel","onBeforeUpdateVal","change","setValue","_jsvInd","_jsvLkEl","_jsvElse","_ctxCb","_cpCtx","onElemChange","fromAttr","defaultAttr","setter","fnSetters","_jsvTr","delegateTarget","activeBody","_jsvChg","rSplitBindings","lastIndex","_jsvBnd","onDataLinkedTagChange","eventArgs","noUpdate","forceUpdate","hasError","bindEarly","linkFn","parentElem","parentNode","oldLinkCtx","onEvent","changeHandler","onBeforeChangeStr","_toLk","VALUE","CHECKBOX","CHECKED","onUpdate","mergeCtxs","NONE","callAfterLink","observeAndBind","onAfterChangeStr","onUnbind","linkedElems","linkedElem","mainElem","displayElem","_cnvt","TRUE","addLinkMethods","updateContent","_noUpd","setDefer","_df","deferAttr","prevNode","nextNode","nodesToRemove","useProp","openIndex","closeIndex","testElem","cStyle","jsvSel","renders","targetParent","$target","targetVal","_val","_elCnt","_prv","_nxt","currentStyle","getComputedStyle","display","_jsvd","displayStyles","createElement","appendChild","removeChild","style","RADIO","nodes","transferViewTokens","jsvAttrStr","disposeTokens","previousSibling","lastChild","remove","empty","children","TEXTCONTENT","selected","$inArray","lateLink","arrayChangeHandler","onBeforeChange","onAfterChange","items","srt","addViews","removeViews","moveViews","oldIndex","fixIndex","setArrayChangeLink","handler","arrayBinding","bndArr","off","arrayChangeStr","on","linkGetVal","_fe","contentEditable","from","renderAndLink","linkToNode","prevView","elCnt","removeViewBinding","nextSibling","addBindingMarkers","bindingKey","viewStore","exprFnDeps","propDeps","tagDepends","cvtBk","_hdl","_dp","_depends","bdId","_apply","boundProps","_bndId","bindLinkedElChange","lnkCtx","tmplLink","$link","tmplOrLinkExpr","useInput","elementChangeStr","vwInfos","placeholderParent","targetEl","topLevelCall","replaceMode","$view","addDataBinding","cleanData","lnk","viewInfos","rOpenViewMarkers","viewLink","outerData","validateOnly","convertMarkers","preceding","selfClose","closeTag","spaceBefore","boundId","spaceAfter","tag1","tag2","closeTag2","spaceAfterClose","selfClose2","endOpenTag","errorMsg","bndId","endOfElCnt","inTag","isVoid","tagStack","validate","voidElems","prevElCnt","elContent","defer","ids","openScript","closeScript","deferStack","badParent","processViewInfos","deferPath","deferChar","bindChar","onAftCr","deep","addedBindEls","_tkns","len","vwInfo","open","onArrayChange","removeSubStr","onAfterCreateStr","onAfterCreate","bindEls","getViewInfos","level","tagDepth","dataLink","wrap","selector","linkViewsSel","elems","qsa","querySelectorAll","prevNodes","markerNodeInfo","contains","isLink","rViewMarkers","skip","processInfos","$viewsLinkAttr","rOpenTagMarkers","unmarkPrevOrNextNode","prevIds","linkInfo","nextView","depth","fragment","copiedNode","firstTag","wrapper","thisId","noValidate","markPrevOrNextNode","namespaceURI","rConvertMarkers","safeFragment","createDocumentFragment","firstChild","insertBefore","linkMarkup","currentView","boundTagId","tagExpr","rTagIndex","linkExpressions","bindDataLinkTarget","normalizeLinkTag","rTagDatalink","linkCtxType","_gccb","$elem","str","SCRIPT","isVal","rBinding","getInfos","close","elPath","infos","rMarkerTokens","removeAttribute","marker","twoway","copyFromTagCtxToTag","linkedElements","$linkCtxElem","linkCtxElem","linkedEl","linkedTag","tagCtxElse","oldVal","indexTo","mapDeps","tagCtxslength","mainElement","displayElement","Array","contents","onBind","mapProps","mapDepends","observe","setSize","height","width","className","_jsvCl","hasClass","removeClass","addClass","onAfterLink","asyncOnElemChange","which","setTimeout","bindTriggerEvent","trig","onoff","isIE","$linkedElem","newTrig","oldTrig","pathIndex","lastPath","bindtoOb","targetPaths","bindTos","targetPathsElses","resolveDataTargetPath","targetPath","topCp","newCtxs","newTagCtx","_thp","clean","elemArray","linkedElemTag","objId","obsId","allLinkedElems","cbId","propertyChangeStr","onDispose","cbBindingsStore","$unlink","each","innerView","getElementsByTagName","inputAttrib","viewOrTagChar","viewOrTag","precedingLength","emptyView","vwItem","rOpenMarkers","async","values","setValues","tagOrView","theTag","theView","select","filtered","add","find","withMarkers","prevIsFirstNode","lastSibling","childTags","_gm","indexFrom","linkedCtxPrmKey","newVal","domChange","hasListener","_data","events","domChangeNotification","triggerHandler","dataItems","viewsCount","itemsCount","keepNodes","isMove","removeView","viewToRemove","itemView","setPrv","prv","rTagMarkers","selfNxt","backwards","firstChange","lastChange","movedNodes","viewsToMove","appendTo","afterParts","endChange","startView","endView","afterView","startParts","endParts","observeProps","updatePropsArr","update","insert","observeMappedProps","removeProperty","oldValue","shallowArrayFilter","rShallowArrayPath","setGlobals","jsvStoreName","$observe","setting","versionNumber","rAttrEncode","&","<",">","\u0000","'","\"","`","=","amp","gt","$render","jsr","jsrender","jsrToJq","jsviews","sub","syntaxErr","settings","advSet","_err","_sq","advanced","Error","_getOb","expando","renderFile","__express","obj","_jq","jq","_jsv","if","done","for","sortDataMap","cloned","range","include","*",":*","dbg","encode","unencode","url","encodeURI","$eventSpecial","event","special","PARSEINT","rNotWhite","rShallowPath","propChng","arrChng","observeStr","observeObjKey","observeCbKey","observeInnerCbKey","$data","getCbKey","cb","_cId","ObjectObservable","ns","_ns","ArrayObservable","wrapArray","dependsPaths","callback","rt","nextObj","out","_ar","removeCbBindings","cbBindings","cbBindingsId","onDataChange","isOb","noArray","parentObs","observeAll","_arOk","array","_path","observe_apply","$observeAll","unobserve","$unobserveAll","namespace","objMap","observeArrayItems","unobs","newAllPath","filterAndObserveAll","nestedArray","newObject","newParentObs","_fltr","nextParentObs","updatedTgt","wrappedCb","isObject","obId","notRemoving","un","hasData","shallowFilter","$unobserve","innerObserve","unobserveBinding","observeOnOff","fullPath","pathStr","isArrayBinding","evData","boundObOrArr","prntObs","allPth","initialNs","el","allowArray","inArray","unbind","relPath","prevAllPath","observeObjects","observeObjectPaths","pths","getInnerCb","newObj","observePath","prts","obArrAddRemove","arrIndex","dep","obArr","prt","_inId","pth","innerCb","p","inId","initNsArr","initNsArrLen","lastArg","Object","unobserveAll","nonStrict","pair","multi","_setProperty","leaf","removeProp","property","Date","_trigger","_insert","oldLength","numToRemove","_remove","move","newIndex","numToMove","_move","excess","newItems","insertAdded","addedItems","dataLength","newItem","num","oldItems","newLength","_srt","$_data","handleObj","oldMapOrTarget","unbound","changing","updatedMap","obsSrc","obs","srcFlt","obsTgt","obt","_updt","tgtFlt","oldMap","newMap","obmp","_def","_gck","_obs","oldAdvSet","window","navigator","userAgent","textContent","bindElsSel","input","valueBinding","isCleanCall","oldCleanData","oldJsvDelimiters","querySelector","ol","ul","table","tbody","thead","tfoot","tr","colgroup","dl","optgroup","svg","svg_ns","br","img","hr","area","col","meta","command","embed","keygen","track","wbr","rViewPath","requiresStr","regularExpression","currentValue","toggle","_hi","activeElem","contextOb","_sel","_evs","_hlr","radiogroup","Math","random","domChngCntnr","useDisable","disabled","forOrIfTagCtx","checked","arrayView","targetLength","arrayBindings","_ars","tagCt","newTagCtxs","prevArg","different","tci","getInnerView","nd","isVl","unlink","oldFn","_glt","regEx","linkCtxs","last","nextPath","addedTagCpDep","paramVal","paramExpr","tagCtxPrm","cloneExprObjects","clones","linkAttr","option","caption","th","td","legend","support","htmlSerialize","textarea"],"mappings":"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","file":"jsviews.min.js","sourcesContent":["/*! jsviews.js v1.0.2 single-file version: http://jsviews.com/ */\n/*! includes JsRender, JsObservable and JsViews - see: http://jsviews.com/#download */\n\n/* Interactive data-driven views using JsRender templates */\n\n//<<<<<<<<<<<<<<<<<<<<<<<<<<<<<< JsRender >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>\n/* JsRender:\n * See http://jsviews.com/#jsrender and http://github.com/BorisMoore/jsrender\n * Copyright 2019, Boris Moore\n * Released under the MIT License.\n */\n\n//jshint -W018, -W041, -W120\n\n(function(factory, global) {\n\t// global var is the this object, which is window when running in the usual browser environment\n\tvar $ = global.jQuery;\n\n\tif (typeof exports === \"object\") { // CommonJS e.g. Browserify\n\t\tmodule.exports = $\n\t\t\t? factory(global, $)\n\t\t\t: function($) { // If no global jQuery, take jQuery passed as parameter: require(\"jsviews\")(jQuery)\n\t\t\t\treturn factory(global, $);\n\t\t\t};\n\t} else if (typeof define === \"function\" && define.amd) { // AMD script loader, e.g. RequireJS\n\t\tdefine([\"jquery\"], function($) {\n\t\t\treturn factory(global, $);\n\t\t}); // Require jQuery\n\t} else { // Browser using plain <script> tag\n\t\tfactory(global, false);\n\t}\n} (\n\n// factory (for jsviews.js)\nfunction(global, $) {\n\"use strict\";\n\n//========================== Top-level vars ==========================\n\n// global var is the this object, which is window when running in the usual browser environment\nvar setGlobals = $ === false; // Only set globals if script block in browser (not AMD and not CommonJS)\n\n$ = $ || global.jQuery; // $ is jQuery passed in by CommonJS loader (Browserify), or global jQuery.\n\nif (!$ || !$.fn) {\n\t// jQuery is not loaded.\n\tthrow \"JsViews requires jQuery\"; // We require jQuery\n}\n\nvar versionNumber = \"v1.0.2\",\n\n\tjsvStoreName, rTag, rTmplString, topView, $views, $observe, $observable, $expando,\n\t_ocp = \"_ocp\", // Observable contextual parameter\n\n//TODO\ttmplFnsCache = {},\n\t$isFunction, $isArray, $templates, $converters, $helpers, $tags, $sub, $subSettings, $subSettingsAdvanced, $viewsSettings,\n\tdelimOpenChar0, delimOpenChar1, delimCloseChar0, delimCloseChar1, linkChar, setting, baseOnError,\n\n\tisRenderCall,\n\trNewLine = /[ \\t]*(\\r\\n|\\n|\\r)/g,\n\trUnescapeQuotes = /\\\\(['\"])/g,\n\trEscapeQuotes = /['\"\\\\]/g, // Escape quotes and \\ character\n\trBuildHash = /(?:\\x08|^)(onerror:)?(?:(~?)(([\\w$.]+):)?([^\\x08]+))\\x08(,)?([^\\x08]+)/gi,\n\trTestElseIf = /^if\\s/,\n\trFirstElem = /<(\\w+)[>\\s]/,\n\trAttrEncode = /[\\x00`><\"'&=]/g, // Includes > encoding since rConvertMarkers in JsViews does not skip > characters in attribute strings\n\trIsHtml = /[\\x00`><\\\"'&=]/,\n\trHasHandlers = /^on[A-Z]|^convert(Back)?$/,\n\trWrappedInViewMarker = /^\\#\\d+_`[\\s\\S]*\\/\\d+_`$/,\n\trHtmlEncode = rAttrEncode,\n\trDataEncode = /[&<>]/g,\n\trDataUnencode = /&(amp|gt|lt);/g,\n\trBracketQuote = /\\[['\"]?|['\"]?\\]/g,\n\tviewId = 0,\n\tcharEntities = {\n\t\t\"&\": \"&amp;\",\n\t\t\"<\": \"&lt;\",\n\t\t\">\": \"&gt;\",\n\t\t\"\\x00\": \"&#0;\",\n\t\t\"'\": \"&#39;\",\n\t\t'\"': \"&#34;\",\n\t\t\"`\": \"&#96;\",\n\t\t\"=\": \"&#61;\"\n\t},\n\tcharsFromEntities  = {\n\t\tamp: \"&\",\n\t\tgt: \">\",\n\t\tlt: \"<\"\n\t},\n\tHTML = \"html\",\n\tOBJECT = \"object\",\n\ttmplAttr = \"data-jsv-tmpl\",\n\tjsvTmpl = \"jsvTmpl\",\n\tindexStr = \"For #index in nested block use #getIndex().\",\n\t$render = {},\n\n\tjsr = global.jsrender,\n\tjsrToJq = jsr && $ && !$.render, // JsRender already loaded, without jQuery. but we will re-load it now to attach to jQuery\n\n\tjsvStores = {\n\t\ttemplate: {\n\t\t\tcompile: compileTmpl\n\t\t},\n\t\ttag: {\n\t\t\tcompile: compileTag\n\t\t},\n\t\tviewModel: {\n\t\t\tcompile: compileViewModel\n\t\t},\n\t\thelper: {},\n\t\tconverter: {}\n\t};\n\n\t// views object ($.views if jQuery is loaded, jsrender.views if no jQuery, e.g. in Node.js)\n\t$views = {\n\t\tjsviews: versionNumber,\n\t\tsub: {\n\t\t\t// subscription, e.g. JsViews integration\n\t\t\trPath: /^(!*?)(?:null|true|false|\\d[\\d.]*|([\\w$]+|\\.|~([\\w$]+)|#(view|([\\w$]+))?)([\\w$.^]*?)(?:[.[^]([\\w$]+)\\]?)?)$/g,\n\t\t\t//        not                               object     helper    view  viewProperty pathTokens      leafToken\n\n\t\t\trPrm: /(\\()(?=\\s*\\()|(?:([([])\\s*)?(?:(\\^?)(~?[\\w$.^]+)?\\s*((\\+\\+|--)|\\+|-|~(?![\\w$])|&&|\\|\\||===|!==|==|!=|<=|>=|[<>%*:?\\/]|(=))\\s*|(!*?(@)?[#~]?[\\w$.^]+)([([])?)|(,\\s*)|(\\(?)\\\\?(?:(')|(\"))|(?:\\s*(([)\\]])(?=[.^]|\\s*$|[^([])|[)\\]])([([]?))|(\\s+)/g,\n\t\t\t//   lftPrn0           lftPrn         bound     path               operator     err                                          eq      path2 late            prn      comma  lftPrn2   apos quot        rtPrn  rtPrnDot                  prn2     space\n\n\t\t\tView: View,\n\t\t\tErr: JsViewsError,\n\t\t\ttmplFn: tmplFn,\n\t\t\tparse: parseParams,\n\t\t\textend: $extend,\n\t\t\textendCtx: extendCtx,\n\t\t\tsyntaxErr: syntaxError,\n\t\t\tonStore: {\n\t\t\t\ttemplate: function(name, item) {\n\t\t\t\t\tif (item === null) {\n\t\t\t\t\t\tdelete $render[name];\n\t\t\t\t\t} else if (name) {\n\t\t\t\t\t\t$render[name] = item;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t},\n\t\t\taddSetting: addSetting,\n\t\t\tsettings: {\n\t\t\t\tallowCode: false\n\t\t\t},\n\t\t\tadvSet: noop, // Update advanced settings\n\t\t\t_thp: tagHandlersFromProps,\n\t\t\t_gm: getMethod,\n\t\t\t_tg: function() {}, // Constructor for tagDef\n\t\t\t_cnvt: convertVal,\n\t\t\t_tag: renderTag,\n\t\t\t_er: error,\n\t\t\t_err: onRenderError,\n\t\t\t_cp: retVal, // Get observable contextual parameters (or properties) ~foo=expr. In JsRender, simply returns val.\n\t\t\t_sq: function(token) {\n\t\t\t\tif (token === \"constructor\") {\n\t\t\t\t\tsyntaxError(\"\");\n\t\t\t\t}\n\t\t\t\treturn token;\n\t\t\t}\n\t\t},\n\t\tsettings: {\n\t\t\tdelimiters: $viewsDelimiters,\n\t\t\tadvanced: function(value) {\n\t\t\t\treturn value\n\t\t\t\t\t? (\n\t\t\t\t\t\t\t$extend($subSettingsAdvanced, value),\n\t\t\t\t\t\t\t$sub.advSet(),\n\t\t\t\t\t\t\t$viewsSettings\n\t\t\t\t\t\t)\n\t\t\t\t\t\t: $subSettingsAdvanced;\n\t\t\t\t}\n\t\t},\n\t\tmap: dataMap    // If jsObservable loaded first, use that definition of dataMap\n\t};\n\nfunction getDerivedMethod(baseMethod, method) {\n\treturn function() {\n\t\tvar ret,\n\t\t\ttag = this,\n\t\t\tprevBase = tag.base;\n\n\t\ttag.base = baseMethod; // Within method call, calling this.base will call the base method\n\t\tret = method.apply(tag, arguments); // Call the method\n\t\ttag.base = prevBase; // Replace this.base to be the base method of the previous call, for chained calls\n\t\treturn ret;\n\t};\n}\n\nfunction getMethod(baseMethod, method) {\n\t// For derived methods (or handlers declared declaratively as in {{:foo onChange=~fooChanged}} replace by a derived method, to allow using this.base(...)\n\t// or this.baseApply(arguments) to call the base implementation. (Equivalent to this._super(...) and this._superApply(arguments) in jQuery UI)\n\tif ($isFunction(method)) {\n\t\tmethod = getDerivedMethod(\n\t\t\t\t!baseMethod\n\t\t\t\t\t? noop // no base method implementation, so use noop as base method\n\t\t\t\t\t: baseMethod._d\n\t\t\t\t\t\t? baseMethod // baseMethod is a derived method, so use it\n\t\t\t\t\t\t: getDerivedMethod(noop, baseMethod), // baseMethod is not derived so make its base method be the noop method\n\t\t\t\tmethod\n\t\t\t);\n\t\tmethod._d = (baseMethod && baseMethod._d || 0) + 1; // Add flag for derived method (incremented for derived of derived...)\n\t}\n\treturn method;\n}\n\nfunction tagHandlersFromProps(tag, tagCtx) {\n\tvar prop,\n\t\tprops = tagCtx.props;\n\tfor (prop in props) {\n\t\tif (rHasHandlers.test(prop) && !(tag[prop] && tag[prop].fix)) { // Don't override handlers with fix expando (used in datepicker and spinner)\n\t\t\ttag[prop] = prop !== \"convert\" ? getMethod(tag.constructor.prototype[prop], props[prop]) : props[prop];\n\t\t\t// Copy over the onFoo props, convert and convertBack from tagCtx.props to tag (overrides values in tagDef).\n\t\t\t// Note: unsupported scenario: if handlers are dynamically added ^onFoo=expression this will work, but dynamically removing will not work.\n\t\t}\n\t}\n}\n\nfunction retVal(val) {\n\treturn val;\n}\n\nfunction noop() {\n\treturn \"\";\n}\n\nfunction dbgBreak(val) {\n\t// Usage examples: {{dbg:...}}, {{:~dbg(...)}}, {{dbg .../}}, {^{for ... onAfterLink=~dbg}} etc.\n\ttry {\n\t\tconsole.log(\"JsRender dbg breakpoint: \" + val);\n\t\tthrow \"dbg breakpoint\"; // To break here, stop on caught exceptions.\n\t}\n\tcatch (e) {}\n\treturn this.base ? this.baseApply(arguments) : val;\n}\n\nfunction JsViewsError(message) {\n\t// Error exception type for JsViews/JsRender\n\t// Override of $.views.sub.Error is possible\n\tthis.name = ($.link ? \"JsViews\" : \"JsRender\") + \" Error\";\n\tthis.message = message || this.name;\n}\n\nfunction $extend(target, source) {\n\tif (target) {\n\t\tfor (var name in source) {\n\t\t\ttarget[name] = source[name];\n\t\t}\n\t\treturn target;\n\t}\n}\n\n(JsViewsError.prototype = new Error()).constructor = JsViewsError;\n\n//========================== Top-level functions ==========================\n\n//===================\n// views.delimiters\n//===================\n\n\t/**\n\t* Set the tag opening and closing delimiters and 'link' character. Default is \"{{\", \"}}\" and \"^\"\n\t* openChars, closeChars: opening and closing strings, each with two characters\n\t* $.views.settings.delimiters(...)\n\t*\n\t* @param {string}   openChars\n\t* @param {string}   [closeChars]\n\t* @param {string}   [link]\n\t* @returns {Settings}\n\t*\n\t* Get delimiters\n\t* delimsArray = $.views.settings.delimiters()\n\t*\n\t* @returns {string[]}\n\t*/\nfunction $viewsDelimiters(openChars, closeChars, link) {\n\tif (!openChars) {\n\t\treturn $subSettings.delimiters;\n\t}\n\tif ($isArray(openChars)) {\n\t\treturn $viewsDelimiters.apply($views, openChars);\n\t}\n\tlinkChar = link ? link[0] : linkChar;\n\tif (!/^(\\W|_){5}$/.test(openChars + closeChars + linkChar)) {\n\t\terror(\"Invalid delimiters\"); // Must be non-word characters, and openChars and closeChars must each be length 2\n\t}\n\tdelimOpenChar0 = openChars[0];\n\tdelimOpenChar1 = openChars[1];\n\tdelimCloseChar0 = closeChars[0];\n\tdelimCloseChar1 = closeChars[1];\n\n\t$subSettings.delimiters = [delimOpenChar0 + delimOpenChar1, delimCloseChar0 + delimCloseChar1, linkChar];\n\n\t// Escape the characters - since they could be regex special characters\n\topenChars = \"\\\\\" + delimOpenChar0 + \"(\\\\\" + linkChar + \")?\\\\\" + delimOpenChar1; // Default is \"{^{\"\n\tcloseChars = \"\\\\\" + delimCloseChar0 + \"\\\\\" + delimCloseChar1;                   // Default is \"}}\"\n\t// Build regex with new delimiters\n\t//          [tag    (followed by / space or })  or cvtr+colon or html or code] followed by space+params then convertBack?\n\trTag = \"(?:(\\\\w+(?=[\\\\/\\\\s\\\\\" + delimCloseChar0 + \"]))|(\\\\w+)?(:)|(>)|(\\\\*))\\\\s*((?:[^\\\\\"\n\t\t+ delimCloseChar0 + \"]|\\\\\" + delimCloseChar0 + \"(?!\\\\\" + delimCloseChar1 + \"))*?)\";\n\n\t// Make rTag available to JsViews (or other components) for parsing binding expressions\n\t$sub.rTag = \"(?:\" + rTag + \")\";\n\t//                        { ^? {   tag+params slash?  or closingTag                                                   or comment\n\trTag = new RegExp(\"(?:\" + openChars + rTag + \"(\\\\/)?|\\\\\" + delimOpenChar0 + \"(\\\\\" + linkChar + \")?\\\\\" + delimOpenChar1 + \"(?:(?:\\\\/(\\\\w+))\\\\s*|!--[\\\\s\\\\S]*?--))\" + closeChars, \"g\");\n\n\t// Default:  bind     tagName         cvt   cln html code    params            slash   bind2         closeBlk  comment\n\t//      /(?:{(\\^)?{(?:(\\w+(?=[\\/\\s}]))|(\\w+)?(:)|(>)|(\\*))\\s*((?:[^}]|}(?!}))*?)(\\/)?|{(\\^)?{(?:(?:\\/(\\w+))\\s*|!--[\\s\\S]*?--))}}\n\n\t$sub.rTmpl = new RegExp(\"^\\\\s|\\\\s$|<.*>|([^\\\\\\\\]|^)[{}]|\" + openChars + \".*\" + closeChars);\n\t// $sub.rTmpl looks for initial or final white space, html tags or { or } char not preceded by \\\\, or JsRender tags {{xxx}}.\n\t// Each of these strings are considered NOT to be jQuery selectors\n\treturn $viewsSettings;\n}\n\n//=========\n// View.get\n//=========\n\nfunction getView(inner, type) { //view.get(inner, type)\n\tif (!type && inner !== true) {\n\t\t// view.get(type)\n\t\ttype = inner;\n\t\tinner = undefined;\n\t}\n\n\tvar views, i, l, found,\n\t\tview = this,\n\t\troot = type === \"root\";\n\t\t// view.get(\"root\") returns view.root, view.get() returns view.parent, view.get(true) returns view.views[0].\n\n\tif (inner) {\n\t\t// Go through views - this one, and all nested ones, depth-first - and return first one with given type.\n\t\t// If type is undefined, i.e. view.get(true), return first child view.\n\t\tfound = type && view.type === type && view;\n\t\tif (!found) {\n\t\t\tviews = view.views;\n\t\t\tif (view._.useKey) {\n\t\t\t\tfor (i in views) {\n\t\t\t\t\tif (found = type ? views[i].get(inner, type) : views[i]) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tfor (i = 0, l = views.length; !found && i < l; i++) {\n\t\t\t\t\tfound = type ? views[i].get(inner, type) : views[i];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t} else if (root) {\n\t\t// Find root view. (view whose parent is top view)\n\t\tfound = view.root;\n\t} else if (type) {\n\t\twhile (view && !found) {\n\t\t\t// Go through views - this one, and all parent ones - and return first one with given type.\n\t\t\tfound = view.type === type ? view : undefined;\n\t\t\tview = view.parent;\n\t\t}\n\t} else {\n\t\tfound = view.parent;\n\t}\n\treturn found || undefined;\n}\n\nfunction getNestedIndex() {\n\tvar view = this.get(\"item\");\n\treturn view ? view.index : undefined;\n}\n\ngetNestedIndex.depends = function() {\n\treturn [this.get(\"item\"), \"index\"];\n};\n\nfunction getIndex() {\n\treturn this.index;\n}\n\ngetIndex.depends = \"index\";\n\n//==================\n// View.ctxPrm, etc.\n//==================\n\n/* Internal private: view._getOb() */\nfunction getPathObject(ob, path, ltOb, fn) {\n\t// Iterate through path to late paths: @a.b.c paths\n\t// Return \"\" (or noop if leaf is a function @a.b.c(...) ) if intermediate object not yet available\n\tvar prevOb, tokens, l,\n\t\ti = 0;\n\tif (ltOb === 1) {\n\t\tfn = 1;\n\t\tltOb = undefined;\n\t}\n\t// Paths like ^a^b^c or ~^a^b^c will not throw if an object in path is undefined.\n\tif (path) {\n\t\ttokens = path.split(\".\");\n\t\tl = tokens.length;\n\n\t\tfor (; ob && i < l; i++) {\n\t\t\tprevOb = ob;\n\t\t\tob = tokens[i] ? ob[tokens[i]] : ob;\n\t\t}\n\t}\n\tif (ltOb) {\n\t\tltOb.lt = ltOb.lt || i<l; // If i < l there was an object in the path not yet available\n\t}\n\treturn ob === undefined\n\t\t? fn ? noop : \"\"\n\t\t: fn ? function() {\n\t\t\treturn ob.apply(prevOb, arguments);\n\t\t} : ob;\n}\n\nfunction contextParameter(key, value, get) {\n\t// Helper method called as view.ctxPrm(key) for helpers or template parameters ~foo - from compiled template or from context callback\n\tvar wrapped, deps, res, obsCtxPrm, tagElse, callView, newRes,\n\t\tstoreView = this,\n\t\tisUpdate = !isRenderCall && arguments.length > 1,\n\t\tstore = storeView.ctx;\n\tif (key) {\n\t\tif (!storeView._) { // tagCtx.ctxPrm() call\n\t\t\ttagElse = storeView.index;\n\t\t\tstoreView = storeView.tag;\n\t\t}\n\t\tcallView = storeView;\n\t\tif (store && store.hasOwnProperty(key) || (store = $helpers).hasOwnProperty(key)) {\n\t\t\tres = store[key];\n\t\t\tif (key === \"tag\" || key === \"tagCtx\" || key === \"root\" || key === \"parentTags\" || storeView._.it === key ) {\n\t\t\t\treturn res;\n\t\t\t}\n\t\t} else {\n\t\t\tstore = undefined;\n\t\t}\n\t\tif (!isRenderCall && storeView.tagCtx || storeView.linked) { // Data-linked view, or tag instance\n\t\t\tif (!res || !res._cxp) {\n\t\t\t\t// Not a contextual parameter\n\t\t\t\t// Set storeView to tag (if this is a tag.ctxPrm() call) or to root view (\"data\" view of linked template)\n\t\t\t\tstoreView = storeView.tagCtx || $isFunction(res)\n\t\t\t\t\t? storeView // Is a tag, not a view, or is a computed contextual parameter, so scope to the callView, no the 'scope view'\n\t\t\t\t\t: (storeView = storeView.scope || storeView,\n\t\t\t\t\t\t!storeView.isTop && storeView.ctx.tag // If this view is in a tag, set storeView to the tag\n\t\t\t\t\t\t\t|| storeView);\n\t\t\t\tif (res !== undefined && storeView.tagCtx) {\n\t\t\t\t\t// If storeView is a tag, but the contextual parameter has been set at at higher level (e.g. helpers)...\n\t\t\t\t\tstoreView = storeView.tagCtx.view.scope; //  then move storeView to the outer level (scope of tag container view)\n\t\t\t\t}\n\t\t\t\tstore = storeView._ocps;\n\t\t\t\tres = store && store.hasOwnProperty(key) && store[key] || res;\n\t\t\t\tif (!(res && res._cxp) && (get || isUpdate)) {\n\t\t\t\t\t// Create observable contextual parameter\n\t\t\t\t\t(store || (storeView._ocps = storeView._ocps || {}))[key]\n\t\t\t\t\t\t= res\n\t\t\t\t\t\t= [{\n\t\t\t\t\t\t\t_ocp: res, // The observable contextual parameter value\n\t\t\t\t\t\t\t_vw: callView,\n\t\t\t\t\t\t\t_key: key\n\t\t\t\t\t\t}];\n\t\t\t\t\tres._cxp = {\n\t\t\t\t\t\tpath: _ocp,\n\t\t\t\t\t\tind: 0,\n\t\t\t\t\t\tupdateValue: function(val, path) {\n\t\t\t\t\t\t\t$.observable(res[0]).setProperty(_ocp, val); // Set the value (res[0]._ocp)\n\t\t\t\t\t\t\treturn this;\n\t\t\t\t\t\t}\n\t\t\t\t\t};\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (obsCtxPrm = res && res._cxp) {\n\t\t\t\t// If this helper resource is an observable contextual parameter\n\t\t\t\tif (arguments.length > 2) {\n\t\t\t\t\tdeps = res[1] ? $sub._ceo(res[1].deps) : [_ocp]; // fn deps (with any exprObs cloned using $sub._ceo)\n\t\t\t\t\tdeps.unshift(res[0]); // view\n\t\t\t\t\tdeps._cxp = obsCtxPrm;\n\t\t\t\t\t// In a context callback for a contextual param, we set get = true, to get ctxPrm  [view, dependencies...] array - needed for observe call\n\t\t\t\t\treturn deps;\n\t\t\t\t}\n\t\t\t\ttagElse = obsCtxPrm.tagElse;\n\t\t\t\tnewRes = res[1] // linkFn for compiled expression\n\t\t\t\t\t? obsCtxPrm.tag && obsCtxPrm.tag.cvtArgs\n\t\t\t\t\t\t? obsCtxPrm.tag.cvtArgs(tagElse, 1)[obsCtxPrm.ind] // = tag.bndArgs() - for tag contextual parameter\n\t\t\t\t\t\t: res[1](res[0].data, res[0], $sub)    // = fn(data, view, $sub) for compiled binding expression\n\t\t\t\t\t: res[0]._ocp; // Observable contextual parameter (uninitialized, or initialized as static expression, so no path dependencies)\n\t\t\t\tif (isUpdate) {\n\t\t\t\t\tif (res && newRes !== value) {\n\t\t\t\t\t\t$sub._ucp(key, value, storeView, obsCtxPrm); // Update observable contextual parameter\n\t\t\t\t\t}\n\t\t\t\t\treturn storeView;\n\t\t\t\t}\n\t\t\t\tres = newRes;\n\t\t\t}\n\t\t}\n\t\tif (res && $isFunction(res)) {\n\t\t\t// If a helper is of type function we will wrap it, so if called with no this pointer it will be called with the\n\t\t\t// view as 'this' context. If the helper ~foo() was in a data-link expression, the view will have a 'temporary' linkCtx property too.\n\t\t\t// Note that helper functions on deeper paths will have specific this pointers, from the preceding path.\n\t\t\t// For example, ~util.foo() will have the ~util object as 'this' pointer\n\t\t\twrapped = function() {\n\t\t\t\treturn res.apply((!this || this === global) ? callView : this, arguments);\n\t\t\t};\n\t\t\t$extend(wrapped, res); // Attach same expandos (if any) to the wrapped function\n\t\t}\n\t\treturn wrapped || res;\n\t}\n}\n\n/* Internal private: view._getTmpl() */\nfunction getTemplate(tmpl) {\n\treturn tmpl && (tmpl.fn\n\t\t? tmpl\n\t\t: this.getRsc(\"templates\", tmpl) || $templates(tmpl)); // not yet compiled\n}\n\n//==============\n// views._cnvt\n//==============\n\nfunction convertVal(converter, view, tagCtx, onError) {\n\t// Called from compiled template code for {{:}}\n\t// self is template object or linkCtx object\n\tvar tag, linkCtx, value, argsLen, bindTo,\n\t\t// If tagCtx is an integer, then it is the key for the compiled function to return the boundTag tagCtx\n\t\tboundTag = typeof tagCtx === \"number\" && view.tmpl.bnds[tagCtx-1];\n\n\tif (onError === undefined && boundTag && boundTag._lr) { // lateRender\n\t\tonError = \"\";\n\t}\n\tif (onError !== undefined) {\n\t\ttagCtx = onError = {props: {}, args: [onError]};\n\t} else if (boundTag) {\n\t\ttagCtx = boundTag(view.data, view, $sub);\n\t}\n\tboundTag = boundTag._bd && boundTag;\n\tif (converter || boundTag) {\n\t\tlinkCtx = view._lc; // For data-link=\"{cvt:...}\"... See onDataLinkedTagChange\n\t\ttag = linkCtx && linkCtx.tag;\n\t\ttagCtx.view = view;\n\t\tif (!tag) {\n\t\t\ttag = $extend(new $sub._tg(), {\n\t\t\t\t_: {\n\t\t\t\t\tbnd: boundTag,\n\t\t\t\t\tunlinked: true,\n\t\t\t\t\tlt: tagCtx.lt // If a late path @some.path has not returned @some object, mark tag as late\n\t\t\t\t},\n\t\t\t\tinline: !linkCtx,\n\t\t\t\ttagName: \":\",\n\t\t\t\tconvert: converter,\n\t\t\t\tflow: true,\n\t\t\t\ttagCtx: tagCtx,\n\t\t\t\ttagCtxs: [tagCtx],\n\t\t\t\t_is: \"tag\"\n\t\t\t});\n\t\t\targsLen = tagCtx.args.length;\n\t\t\tif (argsLen>1) {\n\t\t\t\tbindTo = tag.bindTo = [];\n\t\t\t\twhile (argsLen--) {\n\t\t\t\t\tbindTo.unshift(argsLen); // Bind to all the arguments - generate bindTo array: [0,1,2...]\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (linkCtx) {\n\t\t\t\tlinkCtx.tag = tag;\n\t\t\t\ttag.linkCtx = linkCtx;\n\t\t\t}\n\t\t\ttagCtx.ctx = extendCtx(tagCtx.ctx, (linkCtx ? linkCtx.view : view).ctx);\n\t\t\ttagHandlersFromProps(tag, tagCtx);\n\t\t}\n\t\ttag._er = onError && value;\n\t\ttag.ctx = tagCtx.ctx || tag.ctx || {};\n\t\ttagCtx.ctx = undefined;\n\t\tvalue = tag.cvtArgs()[0]; // If there is a convertBack but no convert, converter will be \"true\"\n\t\ttag._er = onError && value;\n\t} else {\n\t\tvalue = tagCtx.args[0];\n\t}\n\n\t// Call onRender (used by JsViews if present, to add binding annotations around rendered content)\n\tvalue = boundTag && view._.onRender\n\t\t? view._.onRender(value, view, tag)\n\t\t: value;\n\treturn value != undefined ? value : \"\";\n}\n\nfunction convertArgs(tagElse, bound) { // tag.cvtArgs() or tag.cvtArgs(tagElse?, true?)\n\tvar l, key, boundArgs, args, bindFrom, tag, converter,\n\t\ttagCtx = this;\n\n\tif (tagCtx.tagName) {\n\t\ttag = tagCtx;\n\t\ttagCtx = (tag.tagCtxs || [tagCtx])[tagElse||0];\n\t\tif (!tagCtx) {\n\t\t\treturn;\n\t\t}\n\t} else {\n\t\ttag = tagCtx.tag;\n\t}\n\n\tbindFrom = tag.bindFrom;\n\targs = tagCtx.args;\n\n\tif ((converter = tag.convert) && \"\" + converter === converter) {\n\t\tconverter = converter === \"true\"\n\t\t\t? undefined\n\t\t\t: (tagCtx.view.getRsc(\"converters\", converter) || error(\"Unknown converter: '\" + converter + \"'\"));\n\t}\n\n\tif (converter && !bound) { // If there is a converter, use a copy of the tagCtx.args array for rendering, and replace the args[0] in\n\t\targs = args.slice(); // the copied array with the converted value. But we do not modify the value of tag.tagCtx.args[0] (the original args array)\n\t}\n\tif (bindFrom) { // Get the values of the boundArgs\n\t\tboundArgs = [];\n\t\tl = bindFrom.length;\n\t\twhile (l--) {\n\t\t\tkey = bindFrom[l];\n\t\t\tboundArgs.unshift(argOrProp(tagCtx, key));\n\t\t}\n\t\tif (bound) {\n\t\t\targs = boundArgs; // Call to bndArgs() - returns the boundArgs\n\t\t}\n\t}\n\tif (converter) {\n\t\tconverter = converter.apply(tag, boundArgs || args);\n\t\tif (converter === undefined) {\n\t\t\treturn args; // Returning undefined from a converter is equivalent to not having a converter.\n\t\t}\n\t\tbindFrom = bindFrom || [0];\n\t\tl = bindFrom.length;\n\t\tif (!$isArray(converter) || converter.length !== l) {\n\t\t\tconverter = [converter];\n\t\t\tbindFrom = [0];\n\t\t\tl = 1;\n\t\t}\n\t\tif (bound) {        // Call to bndArgs() - so apply converter to all boundArgs\n\t\t\targs = converter; // The array of values returned from the converter\n\t\t} else {            // Call to cvtArgs()\n\t\t\twhile (l--) {\n\t\t\t\tkey = bindFrom[l];\n\t\t\t\tif (+key === key) {\n\t\t\t\t\targs[key] = converter[l];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn args;\n}\n\nfunction argOrProp(context, key) {\n\tcontext = context[+key === key ? \"args\" : \"props\"];\n\treturn context && context[key];\n}\n\nfunction convertBoundArgs(tagElse) { // tag.bndArgs()\n\treturn this.cvtArgs(tagElse, 1);\n}\n\n//=============\n// views.tag\n//=============\n\n/* view.getRsc() */\nfunction getResource(resourceType, itemName) {\n\tvar res, store,\n\t\tview = this;\n\tif (\"\" + itemName === itemName) {\n\t\twhile ((res === undefined) && view) {\n\t\t\tstore = view.tmpl && view.tmpl[resourceType];\n\t\t\tres = store && store[itemName];\n\t\t\tview = view.parent;\n\t\t}\n\t\treturn res || $views[resourceType][itemName];\n\t}\n}\n\nfunction renderTag(tagName, parentView, tmpl, tagCtxs, isUpdate, onError) {\n\tfunction bindToOrBindFrom(type) {\n\t\tvar bindArray = tag[type];\n\n\t\tif (bindArray !== undefined) {\n\t\t\tbindArray = $isArray(bindArray) ? bindArray : [bindArray];\n\t\t\tm = bindArray.length;\n\t\t\twhile (m--) {\n\t\t\t\tkey = bindArray[m];\n\t\t\t\tif (!isNaN(parseInt(key))) {\n\t\t\t\t\tbindArray[m] = parseInt(key); // Convert \"0\" to 0,  etc.\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn bindArray || [0];\n\t}\n\n\tparentView = parentView || topView;\n\tvar tag, tagDef, template, tags, attr, parentTag, l, m, n, itemRet, tagCtx, tagCtxCtx, ctxPrm, bindTo, bindFrom, initVal,\n\t\tcontent, callInit, mapDef, thisMap, args, bdArgs, props, tagDataMap, contentCtx, key, bindFromLength, bindToLength, linkedElement, defaultCtx,\n\t\ti = 0,\n\t\tret = \"\",\n\t\tlinkCtx = parentView._lc || false, // For data-link=\"{myTag...}\"... See onDataLinkedTagChange\n\t\tctx = parentView.ctx,\n\t\tparentTmpl = tmpl || parentView.tmpl,\n\t\t// If tagCtxs is an integer, then it is the key for the compiled function to return the boundTag tagCtxs\n\t\tboundTag = typeof tagCtxs === \"number\" && parentView.tmpl.bnds[tagCtxs-1];\n\n\tif (tagName._is === \"tag\") {\n\t\ttag = tagName;\n\t\ttagName = tag.tagName;\n\t\ttagCtxs = tag.tagCtxs;\n\t\ttemplate = tag.template;\n\t} else {\n\t\ttagDef = parentView.getRsc(\"tags\", tagName) || error(\"Unknown tag: {{\" + tagName + \"}} \");\n\t\ttemplate = tagDef.template;\n\t}\n\tif (onError === undefined && boundTag && (boundTag._lr = (tagDef.lateRender && boundTag._lr!== false || boundTag._lr))) {\n\t\tonError = \"\"; // If lateRender, set temporary onError, to skip initial rendering (and render just \"\")\n\t}\n\tif (onError !== undefined) {\n\t\tret += onError;\n\t\ttagCtxs = onError = [{props: {}, args: [], params: {props:{}}}];\n\t} else if (boundTag) {\n\t\ttagCtxs = boundTag(parentView.data, parentView, $sub);\n\t}\n\n\tl = tagCtxs.length;\n\tfor (; i < l; i++) {\n\t\ttagCtx = tagCtxs[i];\n\t\tcontent = tagCtx.tmpl;\n\t\tif (!linkCtx || !linkCtx.tag || i && !linkCtx.tag.inline || tag._er || content && +content===content) {\n\t\t\t// Initialize tagCtx\n\t\t\t// For block tags, tagCtx.tmpl is an integer > 0\n\t\t\tif (content && parentTmpl.tmpls) {\n\t\t\t\ttagCtx.tmpl = tagCtx.content = parentTmpl.tmpls[content - 1]; // Set the tmpl property to the content of the block tag\n\t\t\t}\n\t\t\ttagCtx.index = i;\n\t\t\ttagCtx.ctxPrm = contextParameter;\n\t\t\ttagCtx.render = renderContent;\n\t\t\ttagCtx.cvtArgs = convertArgs;\n\t\t\ttagCtx.bndArgs = convertBoundArgs;\n\t\t\ttagCtx.view = parentView;\n\t\t\ttagCtx.ctx = extendCtx(extendCtx(tagCtx.ctx, tagDef && tagDef.ctx), ctx); // Clone and extend parentView.ctx\n\t\t}\n\t\tif (tmpl = tagCtx.props.tmpl) {\n\t\t\t// If the tmpl property is overridden, set the value (when initializing, or, in case of binding: ^tmpl=..., when updating)\n\t\t\ttagCtx.tmpl = parentView._getTmpl(tmpl);\n\t\t\ttagCtx.content = tagCtx.content || tagCtx.tmpl;\n\t\t}\n\n\t\tif (!tag) {\n\t\t\t// This will only be hit for initial tagCtx (not for {{else}}) - if the tag instance does not exist yet\n\t\t\t// If the tag has not already been instantiated, we will create a new instance.\n\t\t\t// ~tag will access the tag, even within the rendering of the template content of this tag.\n\t\t\t// From child/descendant tags, can access using ~tag.parent, or ~parentTags.tagName\n\t\t\ttag = new tagDef._ctr();\n\t\t\tcallInit = !!tag.init;\n\n\t\t\ttag.parent = parentTag = ctx && ctx.tag;\n\t\t\ttag.tagCtxs = tagCtxs;\n\n\t\t\tif (linkCtx) {\n\t\t\t\ttag.inline = false;\n\t\t\t\tlinkCtx.tag = tag;\n\t\t\t}\n\t\t\ttag.linkCtx = linkCtx;\n\t\t\tif (tag._.bnd = boundTag || linkCtx.fn) {\n\t\t\t\t// Bound if {^{tag...}} or data-link=\"{tag...}\"\n\t\t\t\ttag._.ths = tagCtx.params.props.this; // Tag has a this=expr binding, to get javascript reference to tag instance\n\t\t\t\ttag._.lt = tagCtxs.lt; // If a late path @some.path has not returned @some object, mark tag as late\n\t\t\t\ttag._.arrVws = {};\n\t\t\t} else if (tag.dataBoundOnly) {\n\t\t\t\terror(tagName + \" must be data-bound:\\n{^{\" + tagName + \"}}\");\n\t\t\t}\n\t\t\t//TODO better perf for childTags() - keep child tag.tags array, (and remove child, when disposed)\n\t\t\t// tag.tags = [];\n\t\t} else if (linkCtx && linkCtx.fn._lr) {\n\t\t\tcallInit = !!tag.init;\n\t\t}\n\t\ttagDataMap = tag.dataMap;\n\n\t\ttagCtx.tag = tag;\n\t\tif (tagDataMap && tagCtxs) {\n\t\t\ttagCtx.map = tagCtxs[i].map; // Copy over the compiled map instance from the previous tagCtxs to the refreshed ones\n\t\t}\n\t\tif (!tag.flow) {\n\t\t\ttagCtxCtx = tagCtx.ctx = tagCtx.ctx || {};\n\n\t\t\t// tags hash: tag.ctx.tags, merged with parentView.ctx.tags,\n\t\t\ttags = tag.parents = tagCtxCtx.parentTags = ctx && extendCtx(tagCtxCtx.parentTags, ctx.parentTags) || {};\n\t\t\tif (parentTag) {\n\t\t\t\ttags[parentTag.tagName] = parentTag;\n\t\t\t\t//TODO better perf for childTags: parentTag.tags.push(tag);\n\t\t\t}\n\t\t\ttags[tag.tagName] = tagCtxCtx.tag = tag;\n\t\t\ttagCtxCtx.tagCtx = tagCtx;\n\t\t}\n\t}\n\tif (!(tag._er = onError)) {\n\t\ttagHandlersFromProps(tag, tagCtxs[0]);\n\t\ttag.rendering = {rndr: tag.rendering}; // Provide object for state during render calls to tag and elses. (Used by {{if}} and {{for}}...)\n\t\tfor (i = 0; i < l; i++) { // Iterate tagCtx for each {{else}} block\n\t\t\ttagCtx = tag.tagCtx = tagCtxs[i];\n\t\t\tprops = tagCtx.props;\n\t\t\ttag.ctx = tagCtx.ctx;\n\n\t\t\tif (!i) {\n\t\t\t\tif (callInit) {\n\t\t\t\t\ttag.init(tagCtx, linkCtx, tag.ctx);\n\t\t\t\t\tcallInit = undefined;\n\t\t\t\t}\n\t\t\t\tif (!tagCtx.args.length && tagCtx.argDefault !== false && tag.argDefault !== false) {\n\t\t\t\t\ttagCtx.args = args = [tagCtx.view.data]; // Missing first arg defaults to the current data context\n\t\t\t\t\ttagCtx.params.args = [\"#data\"];\n\t\t\t\t}\n\n\t\t\t\tbindTo = bindToOrBindFrom(\"bindTo\");\n\n\t\t\t\tif (tag.bindTo !== undefined) {\n\t\t\t\t\ttag.bindTo = bindTo;\n\t\t\t\t}\n\n\t\t\t\tif (tag.bindFrom !== undefined) {\n\t\t\t\t\ttag.bindFrom = bindToOrBindFrom(\"bindFrom\");\n\t\t\t\t} else if (tag.bindTo) {\n\t\t\t\t\ttag.bindFrom = tag.bindTo = bindTo;\n\t\t\t\t}\n\t\t\t\tbindFrom = tag.bindFrom || bindTo;\n\n\t\t\t\tbindToLength = bindTo.length;\n\t\t\t\tbindFromLength = bindFrom.length;\n\n\t\t\t\tif (tag._.bnd && (linkedElement = tag.linkedElement)) {\n\t\t\t\t\ttag.linkedElement = linkedElement = $isArray(linkedElement) ? linkedElement: [linkedElement];\n\n\t\t\t\t\tif (bindToLength !== linkedElement.length) {\n\t\t\t\t\t\terror(\"linkedElement not same length as bindTo\");\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (linkedElement = tag.linkedCtxParam) {\n\t\t\t\t\ttag.linkedCtxParam = linkedElement = $isArray(linkedElement) ? linkedElement: [linkedElement];\n\n\t\t\t\t\tif (bindFromLength !== linkedElement.length) {\n\t\t\t\t\t\terror(\"linkedCtxParam not same length as bindFrom/bindTo\");\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (bindFrom) {\n\t\t\t\t\ttag._.fromIndex = {}; // Hash of bindFrom index which has same path value as bindTo index. fromIndex = tag._.fromIndex[toIndex]\n\t\t\t\t\ttag._.toIndex = {}; // Hash of bindFrom index which has same path value as bindTo index. fromIndex = tag._.fromIndex[toIndex]\n\t\t\t\t\tn = bindFromLength;\n\t\t\t\t\twhile (n--) {\n\t\t\t\t\t\tkey = bindFrom[n];\n\t\t\t\t\t\tm = bindToLength;\n\t\t\t\t\t\twhile (m--) {\n\t\t\t\t\t\t\tif (key === bindTo[m]) {\n\t\t\t\t\t\t\t\ttag._.fromIndex[m] = n;\n\t\t\t\t\t\t\t\ttag._.toIndex[n] = m;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (linkCtx) {\n\t\t\t\t\t// Set attr on linkCtx to ensure outputting to the correct target attribute.\n\t\t\t\t\t// Setting either linkCtx.attr or this.attr in the init() allows per-instance choice of target attrib.\n\t\t\t\t\tlinkCtx.attr = tag.attr = linkCtx.attr || tag.attr || linkCtx._dfAt;\n\t\t\t\t}\n\t\t\t\tattr = tag.attr;\n\t\t\t\ttag._.noVws = attr && attr !== HTML;\n\t\t\t}\n\t\t\targs = tag.cvtArgs(i);\n\t\t\tif (tag.linkedCtxParam) {\n\t\t\t\tbdArgs = tag.cvtArgs(i, 1);\n\t\t\t\tm = bindFromLength;\n\t\t\t\tdefaultCtx = tag.constructor.prototype.ctx;\n\t\t\t\twhile (m--) {\n\t\t\t\t\tif (ctxPrm = tag.linkedCtxParam[m]) {\n\t\t\t\t\t\tkey = bindFrom[m];\n\t\t\t\t\t\tinitVal = bdArgs[m];\n\t\t\t\t\t\t// Create tag contextual parameter\n\t\t\t\t\t\ttagCtx.ctx[ctxPrm] = $sub._cp(\n\t\t\t\t\t\t\tdefaultCtx && initVal === undefined ? defaultCtx[ctxPrm]: initVal,\n\t\t\t\t\t\t\tinitVal !== undefined && argOrProp(tagCtx.params, key),\n\t\t\t\t\t\t\ttagCtx.view,\n\t\t\t\t\t\t\ttag._.bnd && {tag: tag, cvt: tag.convert, ind: m, tagElse: i}\n\t\t\t\t\t\t);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif ((mapDef = props.dataMap || tagDataMap) && (args.length || props.dataMap)) {\n\t\t\t\tthisMap = tagCtx.map;\n\t\t\t\tif (!thisMap || thisMap.src !== args[0] || isUpdate) {\n\t\t\t\t\tif (thisMap && thisMap.src) {\n\t\t\t\t\t\tthisMap.unmap(); // only called if observable map - not when only used in JsRender, e.g. by {{props}}\n\t\t\t\t\t}\n\t\t\t\t\tmapDef.map(args[0], tagCtx, thisMap, !tag._.bnd);\n\t\t\t\t\tthisMap = tagCtx.map;\n\t\t\t\t}\n\t\t\t\targs = [thisMap.tgt];\n\t\t\t}\n\n\t\t\titemRet = undefined;\n\t\t\tif (tag.render) {\n\t\t\t\titemRet = tag.render.apply(tag, args);\n\t\t\t\tif (parentView.linked && itemRet && !rWrappedInViewMarker.test(itemRet)) {\n\t\t\t\t\t// When a tag renders content from the render method, with data linking then we need to wrap with view markers, if absent,\n\t\t\t\t\t// to provide a contentView for the tag, which will correctly dispose bindings if deleted. The 'tmpl' for this view will\n\t\t\t\t\t// be a dumbed-down template which will always return the  itemRet string (no matter what the data is). The itemRet string\n\t\t\t\t\t// is not compiled as template markup, so can include \"{{\" or \"}}\" without triggering syntax errors\n\t\t\t\t\ttmpl = { // 'Dumbed-down' template which always renders 'static' itemRet string\n\t\t\t\t\t\tlinks: []\n\t\t\t\t\t};\n\t\t\t\t\ttmpl.render = tmpl.fn = function() {\n\t\t\t\t\t\treturn itemRet;\n\t\t\t\t\t};\n\t\t\t\t\titemRet = renderWithViews(tmpl, parentView.data, undefined, true, parentView, undefined, undefined, tag);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!args.length) {\n\t\t\t\targs = [parentView]; // no arguments - (e.g. {{else}}) get data context from view.\n\t\t\t}\n\t\t\tif (itemRet === undefined) {\n\t\t\t\tcontentCtx = args[0]; // Default data context for wrapped block content is the first argument\n\t\t\t\tif (tag.contentCtx) { // Set tag.contentCtx to true, to inherit parent context, or to a function to provide alternate context.\n\t\t\t\t\tcontentCtx = tag.contentCtx === true ? parentView : tag.contentCtx(contentCtx);\n\t\t\t\t}\n\t\t\t\titemRet = tagCtx.render(contentCtx, true) || (isUpdate ? undefined : \"\");\n\t\t\t}\n\t\t\tret = ret\n\t\t\t\t? ret + (itemRet || \"\")\n\t\t\t\t: itemRet !== undefined\n\t\t\t\t\t? \"\" + itemRet\n\t\t\t\t\t: undefined; // If no return value from render, and no template/content tagCtx.render(...), return undefined\n\t\t}\n\t\ttag.rendering = tag.rendering.rndr; // Remove tag.rendering object (if this is outermost render call. (In case of nested calls)\n\t}\n\ttag.tagCtx = tagCtxs[0];\n\ttag.ctx = tag.tagCtx.ctx;\n\n\tif (tag._.noVws && tag.inline) {\n\t\t// inline tag with attr set to \"text\" will insert HTML-encoded content - as if it was element-based innerText\n\t\tret = attr === \"text\"\n\t\t\t? $converters.html(ret)\n\t\t\t: \"\";\n\t}\n\treturn boundTag && parentView._.onRender\n\t\t// Call onRender (used by JsViews if present, to add binding annotations around rendered content)\n\t\t? parentView._.onRender(ret, parentView, tag)\n\t\t: ret;\n}\n\n//=================\n// View constructor\n//=================\n\nfunction View(context, type, parentView, data, template, key, onRender, contentTmpl) {\n\t// Constructor for view object in view hierarchy. (Augmented by JsViews if JsViews is loaded)\n\tvar views, parentView_, tag, self_,\n\t\tself = this,\n\t\tisArray = type === \"array\";\n\t\t// If the data is an array, this is an 'array view' with a views array for each child 'item view'\n\t\t// If the data is not an array, this is an 'item view' with a views 'hash' object for any child nested views\n\n\tself.content = contentTmpl;\n\tself.views = isArray ? [] : {};\n\tself.data = data;\n\tself.tmpl = template;\n\tself_ = self._ = {\n\t\tkey: 0,\n\t\t// ._.useKey is non zero if is not an 'array view' (owning a data array). Use this as next key for adding to child views hash\n\t\tuseKey: isArray ? 0 : 1,\n\t\tid: \"\" + viewId++,\n\t\tonRender: onRender,\n\t\tbnds: {}\n\t};\n\tself.linked = !!onRender;\n\tself.type = type || \"top\";\n\tif (self.parent = parentView) {\n\t\tself.root = parentView.root || self; // view whose parent is top view\n\t\tviews = parentView.views;\n\t\tparentView_ = parentView._;\n\t\tself.isTop = parentView_.scp; // Is top content view of a link(\"#container\", ...) call\n\t\tself.scope = (!context.tag || context.tag === parentView.ctx.tag) && !self.isTop && parentView.scope || self;\n\t\t// Scope for contextParams - closest non flow tag ancestor or root view\n\t\tif (parentView_.useKey) {\n\t\t\t// Parent is not an 'array view'. Add this view to its views object\n\t\t\t// self._key = is the key in the parent view hash\n\t\t\tviews[self_.key = \"_\" + parentView_.useKey++] = self;\n\t\t\tself.index = indexStr;\n\t\t\tself.getIndex = getNestedIndex;\n\t\t} else if (views.length === (self_.key = self.index = key)) { // Parent is an 'array view'. Add this view to its views array\n\t\t\tviews.push(self); // Adding to end of views array. (Using push when possible - better perf than splice)\n\t\t} else {\n\t\t\tviews.splice(key, 0, self); // Inserting in views array\n\t\t}\n\t\t// If no context was passed in, use parent context\n\t\t// If context was passed in, it should have been merged already with parent context\n\t\tself.ctx = context || parentView.ctx;\n\t} else {\n\t\tself.ctx = context || {};\n\t}\n}\n\nView.prototype = {\n\tget: getView,\n\tgetIndex: getIndex,\n\tctxPrm: contextParameter,\n\tgetRsc: getResource,\n\t_getTmpl: getTemplate,\n\t_getOb: getPathObject,\n\t_is: \"view\"\n};\n\n//====================================================\n// Registration\n//====================================================\n\nfunction compileChildResources(parentTmpl) {\n\tvar storeName, storeNames, resources;\n\tfor (storeName in jsvStores) {\n\t\tstoreNames = storeName + \"s\";\n\t\tif (parentTmpl[storeNames]) {\n\t\t\tresources = parentTmpl[storeNames];    // Resources not yet compiled\n\t\t\tparentTmpl[storeNames] = {};               // Remove uncompiled resources\n\t\t\t$views[storeNames](resources, parentTmpl); // Add back in the compiled resources\n\t\t}\n\t}\n}\n\n//===============\n// compileTag\n//===============\n\nfunction compileTag(name, tagDef, parentTmpl) {\n\tvar tmpl, baseTag, prop,\n\t\tcompiledDef = new $sub._tg();\n\n\tfunction Tag() {\n\t\tvar tag = this;\n\t\ttag._ = {\n\t\t\tunlinked: true\n\t\t};\n\t\ttag.inline = true;\n\t\ttag.tagName = name;\n\t}\n\n\tif ($isFunction(tagDef)) {\n\t\t// Simple tag declared as function. No presenter instantation.\n\t\ttagDef = {\n\t\t\tdepends: tagDef.depends,\n\t\t\trender: tagDef\n\t\t};\n\t} else if (\"\" + tagDef === tagDef) {\n\t\ttagDef = {template: tagDef};\n\t}\n\n\tif (baseTag = tagDef.baseTag) {\n\t\ttagDef.flow = !!tagDef.flow; // Set flow property, so defaults to false even if baseTag has flow=true\n\t\tbaseTag = \"\" + baseTag === baseTag\n\t\t\t? (parentTmpl && parentTmpl.tags[baseTag] || $tags[baseTag])\n\t\t\t: baseTag;\n\t\tif (!baseTag) {\n\t\t\terror('baseTag: \"' + tagDef.baseTag + '\" not found');\n\t\t}\n\t\tcompiledDef = $extend(compiledDef, baseTag);\n\n\t\tfor (prop in tagDef) {\n\t\t\tcompiledDef[prop] = getMethod(baseTag[prop], tagDef[prop]);\n\t\t}\n\t} else {\n\t\tcompiledDef = $extend(compiledDef, tagDef);\n\t}\n\n\t// Tag declared as object, used as the prototype for tag instantiation (control/presenter)\n\tif ((tmpl = compiledDef.template) !== undefined) {\n\t\tcompiledDef.template = \"\" + tmpl === tmpl ? ($templates[tmpl] || $templates(tmpl)) : tmpl;\n\t}\n\t(Tag.prototype = compiledDef).constructor = compiledDef._ctr = Tag;\n\n\tif (parentTmpl) {\n\t\tcompiledDef._parentTmpl = parentTmpl;\n\t}\n\treturn compiledDef;\n}\n\nfunction baseApply(args) {\n\t// In derived method (or handler declared declaratively as in {{:foo onChange=~fooChanged}} can call base method,\n\t// using this.baseApply(arguments) (Equivalent to this._superApply(arguments) in jQuery UI)\n\treturn this.base.apply(this, args);\n}\n\n//===============\n// compileTmpl\n//===============\n\nfunction compileTmpl(name, tmpl, parentTmpl, options) {\n\t// tmpl is either a template object, a selector for a template script block, the name of a compiled template, or a template object\n\n\t//==== nested functions ====\n\tfunction lookupTemplate(value) {\n\t\t// If value is of type string - treat as selector, or name of compiled template\n\t\t// Return the template object, if already compiled, or the markup string\n\t\tvar currentName, tmpl;\n\t\tif ((\"\" + value === value) || value.nodeType > 0 && (elem = value)) {\n\t\t\tif (!elem) {\n\t\t\t\tif (/^\\.\\/[^\\\\:*?\"<>]*$/.test(value)) {\n\t\t\t\t\t// tmpl=\"./some/file.html\"\n\t\t\t\t\t// If the template is not named, use \"./some/file.html\" as name.\n\t\t\t\t\tif (tmpl = $templates[name = name || value]) {\n\t\t\t\t\t\tvalue = tmpl;\n\t\t\t\t\t} else {\n\t\t\t\t\t\t// BROWSER-SPECIFIC CODE (not on Node.js):\n\t\t\t\t\t\t// Look for server-generated script block with id \"./some/file.html\"\n\t\t\t\t\t\telem = document.getElementById(value);\n\t\t\t\t\t}\n\t\t\t\t} else if ($.fn && !$sub.rTmpl.test(value)) {\n\t\t\t\t\ttry {\n\t\t\t\t\t\telem = $ (value, document)[0]; // if jQuery is loaded, test for selector returning elements, and get first element\n\t\t\t\t\t} catch (e) {}\n\t\t\t\t}// END BROWSER-SPECIFIC CODE\n\t\t\t} //BROWSER-SPECIFIC CODE\n\t\t\tif (elem) {\n\t\t\t\tif (elem.tagName !== \"SCRIPT\") {\n\t\t\t\t\terror(value + \": Use script block, not \" + elem.tagName);\n\t\t\t\t}\n\t\t\t\tif (options) {\n\t\t\t\t\t// We will compile a new template using the markup in the script element\n\t\t\t\t\tvalue = elem.innerHTML;\n\t\t\t\t} else {\n\t\t\t\t\t// We will cache a single copy of the compiled template, and associate it with the name\n\t\t\t\t\t// (renaming from a previous name if there was one).\n\t\t\t\t\tcurrentName = elem.getAttribute(tmplAttr);\n\t\t\t\t\tif (currentName) {\n\t\t\t\t\t\tif (currentName !== jsvTmpl) {\n\t\t\t\t\t\t\tvalue = $templates[currentName];\n\t\t\t\t\t\t\tdelete $templates[currentName];\n\t\t\t\t\t\t} else if ($.fn) {\n\t\t\t\t\t\t\tvalue = $.data(elem)[jsvTmpl]; // Get cached compiled template\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (!currentName || !value) { // Not yet compiled, or cached version lost\n\t\t\t\t\t\tname = name || ($.fn ? jsvTmpl : value);\n\t\t\t\t\t\tvalue = compileTmpl(name, elem.innerHTML, parentTmpl, options);\n\t\t\t\t\t}\n\t\t\t\t\tvalue.tmplName = name = name || currentName;\n\t\t\t\t\tif (name !== jsvTmpl) {\n\t\t\t\t\t\t$templates[name] = value;\n\t\t\t\t\t}\n\t\t\t\t\telem.setAttribute(tmplAttr, name);\n\t\t\t\t\tif ($.fn) {\n\t\t\t\t\t\t$.data(elem, jsvTmpl, value);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} // END BROWSER-SPECIFIC CODE\n\t\t\telem = undefined;\n\t\t} else if (!value.fn) {\n\t\t\tvalue = undefined;\n\t\t\t// If value is not a string. HTML element, or compiled template, return undefined\n\t\t}\n\t\treturn value;\n\t}\n\n\tvar elem, compiledTmpl,\n\t\ttmplOrMarkup = tmpl = tmpl || \"\";\n\t$sub._html = $converters.html;\n\n\t//==== Compile the template ====\n\tif (options === 0) {\n\t\toptions = undefined;\n\t\ttmplOrMarkup = lookupTemplate(tmplOrMarkup); // Top-level compile so do a template lookup\n\t}\n\n\t// If options, then this was already compiled from a (script) element template declaration.\n\t// If not, then if tmpl is a template object, use it for options\n\toptions = options || (tmpl.markup\n\t\t? tmpl.bnds\n\t\t\t? $extend({}, tmpl)\n\t\t\t: tmpl\n\t\t: {}\n\t);\n\n\toptions.tmplName = options.tmplName || name || \"unnamed\";\n\tif (parentTmpl) {\n\t\toptions._parentTmpl = parentTmpl;\n\t}\n\t// If tmpl is not a markup string or a selector string, then it must be a template object\n\t// In that case, get it from the markup property of the object\n\tif (!tmplOrMarkup && tmpl.markup && (tmplOrMarkup = lookupTemplate(tmpl.markup)) && tmplOrMarkup.fn) {\n\t\t// If the string references a compiled template object, need to recompile to merge any modified options\n\t\ttmplOrMarkup = tmplOrMarkup.markup;\n\t}\n\tif (tmplOrMarkup !== undefined) {\n\t\tif (tmplOrMarkup.render || tmpl.render) {\n\t\t\t// tmpl is already compiled, so use it\n\t\t\tif (tmplOrMarkup.tmpls) {\n\t\t\t\tcompiledTmpl = tmplOrMarkup;\n\t\t\t}\n\t\t} else {\n\t\t\t// tmplOrMarkup is a markup string, not a compiled template\n\t\t\t// Create template object\n\t\t\ttmpl = tmplObject(tmplOrMarkup, options);\n\t\t\t// Compile to AST and then to compiled function\n\t\t\ttmplFn(tmplOrMarkup.replace(rEscapeQuotes, \"\\\\$&\"), tmpl);\n\t\t}\n\t\tif (!compiledTmpl) {\n\t\t\tcompiledTmpl = $extend(function() {\n\t\t\t\treturn compiledTmpl.render.apply(compiledTmpl, arguments);\n\t\t\t}, tmpl);\n\n\t\t\tcompileChildResources(compiledTmpl);\n\t\t}\n\t\treturn compiledTmpl;\n\t}\n}\n\n//==== /end of function compileTmpl ====\n\n//=================\n// compileViewModel\n//=================\n\nfunction getDefaultVal(defaultVal, data) {\n\treturn $isFunction(defaultVal)\n\t\t? defaultVal.call(data)\n\t\t: defaultVal;\n}\n\nfunction unmapArray(modelArr) {\n\t\tvar arr = [],\n\t\t\ti = 0,\n\t\t\tl = modelArr.length;\n\t\tfor (; i<l; i++) {\n\t\t\tarr.push(modelArr[i].unmap());\n\t\t}\n\t\treturn arr;\n}\n\nfunction compileViewModel(name, type) {\n\tvar i, constructor,\n\t\tviewModels = this,\n\t\tgetters = type.getters,\n\t\textend = type.extend,\n\t\tid = type.id,\n\t\tproto = $.extend({\n\t\t\t_is: name || \"unnamed\",\n\t\t\tunmap: unmap,\n\t\t\tmerge: merge\n\t\t}, extend),\n\t\targs = \"\",\n\t\tbody = \"\",\n\t\tg = getters ? getters.length : 0,\n\t\t$observable = $.observable,\n\t\tgetterNames = {};\n\n\tfunction GetNew(args) {\n\t\tconstructor.apply(this, args);\n\t}\n\n\tfunction vm() {\n\t\treturn new GetNew(arguments);\n\t}\n\n\tfunction iterate(data, action) {\n\t\tvar getterType, defaultVal, prop, ob,\n\t\t\tj = 0;\n\t\tfor (; j<g; j++) {\n\t\t\tprop = getters[j];\n\t\t\tgetterType = undefined;\n\t\t\tif (prop + \"\" !== prop) {\n\t\t\t\tgetterType = prop;\n\t\t\t\tprop = getterType.getter;\n\t\t\t}\n\t\t\tif ((ob = data[prop]) === undefined && getterType && (defaultVal = getterType.defaultVal) !== undefined) {\n\t\t\t\tob = getDefaultVal(defaultVal, data);\n\t\t\t}\n\t\t\taction(ob, getterType && viewModels[getterType.type], prop);\n\t\t}\n\t}\n\n\tfunction map(data) {\n\t\tdata = data + \"\" === data\n\t\t\t? JSON.parse(data) // Accept JSON string\n\t\t\t: data;            // or object/array\n\t\tvar l, prop,\n\t\t\tj = 0,\n\t\t\tob = data,\n\t\t\tarr = [];\n\n\t\tif ($isArray(data)) {\n\t\t\tdata = data || [];\n\t\t\tl = data.length;\n\t\t\tfor (; j<l; j++) {\n\t\t\t\tarr.push(this.map(data[j]));\n\t\t\t}\n\t\t\tarr._is = name;\n\t\t\tarr.unmap = unmap;\n\t\t\tarr.merge = merge;\n\t\t\treturn arr;\n\t\t}\n\n\t\tif (data) {\n\t\t\titerate(data, function(ob, viewModel) {\n\t\t\t\tif (viewModel) { // Iterate to build getters arg array (value, or mapped value)\n\t\t\t\t\tob = viewModel.map(ob);\n\t\t\t\t}\n\t\t\t\tarr.push(ob);\n\t\t\t});\n\n\t\t\tob = this.apply(this, arr); // Instantiate this View Model, passing getters args array to constructor\n\t\t\tfor (prop in data) { // Copy over any other properties. that are not get/set properties\n\t\t\t\tif (prop !== $expando && !getterNames[prop]) {\n\t\t\t\t\tob[prop] = data[prop];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn ob;\n\t}\n\n\tfunction merge(data) {\n\t\tdata = data + \"\" === data\n\t\t\t? JSON.parse(data) // Accept JSON string\n\t\t\t: data;            // or object/array\n\t\tvar j, l, m, prop, mod, found, assigned, ob, newModArr,\n\t\t\tk = 0,\n\t\t\tmodel = this;\n\n\t\tif ($isArray(model)) {\n\t\t\tassigned = {};\n\t\t\tnewModArr = [];\n\t\t\tl = data.length;\n\t\t\tm = model.length;\n\t\t\tfor (; k<l; k++) {\n\t\t\t\tob = data[k];\n\t\t\t\tfound = false;\n\t\t\t\tfor (j=0; j<m && !found; j++) {\n\t\t\t\t\tif (assigned[j]) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tmod = model[j];\n\n\t\t\t\t\tif (id) {\n\t\t\t\t\t\tassigned[j] = found = id + \"\" === id\n\t\t\t\t\t\t? (ob[id] && (getterNames[id] ? mod[id]() : mod[id]) === ob[id])\n\t\t\t\t\t\t: id(mod, ob);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (found) {\n\t\t\t\t\tmod.merge(ob);\n\t\t\t\t\tnewModArr.push(mod);\n\t\t\t\t} else {\n\t\t\t\t\tnewModArr.push(vm.map(ob));\n\t\t\t\t}\n\t\t\t}\n\t\t\tif ($observable) {\n\t\t\t\t$observable(model).refresh(newModArr, true);\n\t\t\t} else {\n\t\t\t\tmodel.splice.apply(model, [0, model.length].concat(newModArr));\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\t\titerate(data, function(ob, viewModel, getter) {\n\t\t\tif (viewModel) {\n\t\t\t\tmodel[getter]().merge(ob); // Update typed property\n\t\t\t} else {\n\t\t\t\tmodel[getter](ob); // Update non-typed property\n\t\t\t}\n\t\t});\n\t\tfor (prop in data) {\n\t\t\tif (prop !== $expando && !getterNames[prop]) {\n\t\t\t\tmodel[prop] = data[prop];\n\t\t\t}\n\t\t}\n\t}\n\n\tfunction unmap() {\n\t\tvar ob, prop, getterType, arr, value,\n\t\t\tk = 0,\n\t\t\tmodel = this;\n\n\t\tif ($isArray(model)) {\n\t\t\treturn unmapArray(model);\n\t\t}\n\t\tob = {};\n\t\tfor (; k<g; k++) {\n\t\t\tprop = getters[k];\n\t\t\tgetterType = undefined;\n\t\t\tif (prop + \"\" !== prop) {\n\t\t\t\tgetterType = prop;\n\t\t\t\tprop = getterType.getter;\n\t\t\t}\n\t\t\tvalue = model[prop]();\n\t\t\tob[prop] = getterType && value && viewModels[getterType.type]\n\t\t\t\t? $isArray(value)\n\t\t\t\t\t? unmapArray(value)\n\t\t\t\t\t: value.unmap()\n\t\t\t\t: value;\n\t\t}\n\t\tfor (prop in model) {\n\t\t\tif (prop !== \"_is\" && !getterNames[prop] && prop !== $expando  && (prop.charAt(0) !== \"_\" || !getterNames[prop.slice(1)]) && !$isFunction(model[prop])) {\n\t\t\t\tob[prop] = model[prop];\n\t\t\t}\n\t\t}\n\t\treturn ob;\n\t}\n\n\tGetNew.prototype = proto;\n\n\tfor (i=0; i<g; i++) {\n\t\t(function(getter) {\n\t\t\tgetter = getter.getter || getter;\n\t\t\tgetterNames[getter] = i+1;\n\t\t\tvar privField = \"_\" + getter;\n\n\t\t\targs += (args ? \",\" : \"\") + getter;\n\t\t\tbody += \"this.\" + privField + \" = \" + getter + \";\\n\";\n\t\t\tproto[getter] = proto[getter] || function(val) {\n\t\t\t\tif (!arguments.length) {\n\t\t\t\t\treturn this[privField]; // If there is no argument, use as a getter\n\t\t\t\t}\n\t\t\t\tif ($observable) {\n\t\t\t\t\t$observable(this).setProperty(getter, val);\n\t\t\t\t} else {\n\t\t\t\t\tthis[privField] = val;\n\t\t\t\t}\n\t\t\t};\n\n\t\t\tif ($observable) {\n\t\t\t\tproto[getter].set = proto[getter].set || function(val) {\n\t\t\t\t\tthis[privField] = val; // Setter called by observable property change\n\t\t\t\t};\n\t\t\t}\n\t\t})(getters[i]);\n\t}\n\n\tconstructor = new Function(args, body.slice(0, -1));\n\tconstructor.prototype = proto;\n\tproto.constructor = constructor;\n\n\tvm.map = map;\n\tvm.getters = getters;\n\tvm.extend = extend;\n\tvm.id = id;\n\treturn vm;\n}\n\nfunction tmplObject(markup, options) {\n\t// Template object constructor\n\tvar htmlTag,\n\t\twrapMap = $subSettingsAdvanced._wm || {}, // Only used in JsViews. Otherwise empty: {}\n\t\ttmpl = {\n\t\t\ttmpls: [],\n\t\t\tlinks: {}, // Compiled functions for link expressions\n\t\t\tbnds: [],\n\t\t\t_is: \"template\",\n\t\t\trender: renderContent\n\t\t};\n\n\tif (options) {\n\t\ttmpl = $extend(tmpl, options);\n\t}\n\n\ttmpl.markup = markup;\n\tif (!tmpl.htmlTag) {\n\t\t// Set tmpl.tag to the top-level HTML tag used in the template, if any...\n\t\thtmlTag = rFirstElem.exec(markup);\n\t\ttmpl.htmlTag = htmlTag ? htmlTag[1].toLowerCase() : \"\";\n\t}\n\thtmlTag = wrapMap[tmpl.htmlTag];\n\tif (htmlTag && htmlTag !== wrapMap.div) {\n\t\t// When using JsViews, we trim templates which are inserted into HTML contexts where text nodes are not rendered (i.e. not 'Phrasing Content').\n\t\t// Currently not trimmed for <li> tag. (Not worth adding perf cost)\n\t\ttmpl.markup = $.trim(tmpl.markup);\n\t}\n\n\treturn tmpl;\n}\n\n//==============\n// registerStore\n//==============\n\n/**\n* Internal. Register a store type (used for template, tags, helpers, converters)\n*/\nfunction registerStore(storeName, storeSettings) {\n\n/**\n* Generic store() function to register item, named item, or hash of items\n* Also used as hash to store the registered items\n* Used as implementation of $.templates(), $.views.templates(), $.views.tags(), $.views.helpers() and $.views.converters()\n*\n* @param {string|hash} name         name - or selector, in case of $.templates(). Or hash of items\n* @param {any}         [item]       (e.g. markup for named template)\n* @param {template}    [parentTmpl] For item being registered as private resource of template\n* @returns {any|$.views} item, e.g. compiled template - or $.views in case of registering hash of items\n*/\n\tfunction theStore(name, item, parentTmpl) {\n\t\t// The store is also the function used to add items to the store. e.g. $.templates, or $.views.tags\n\n\t\t// For store of name 'thing', Call as:\n\t\t//    $.views.things(items[, parentTmpl]),\n\t\t// or $.views.things(name[, item, parentTmpl])\n\n\t\tvar compile, itemName, thisStore, cnt,\n\t\t\tonStore = $sub.onStore[storeName];\n\n\t\tif (name && typeof name === OBJECT && !name.nodeType && !name.markup && !name.getTgt && !(storeName === \"viewModel\" && name.getters || name.extend)) {\n\t\t\t// Call to $.views.things(items[, parentTmpl]),\n\n\t\t\t// Adding items to the store\n\t\t\t// If name is a hash, then item is parentTmpl. Iterate over hash and call store for key.\n\t\t\tfor (itemName in name) {\n\t\t\t\ttheStore(itemName, name[itemName], item);\n\t\t\t}\n\t\t\treturn item || $views;\n\t\t}\n\t\t// Adding a single unnamed item to the store\n\t\tif (name && \"\" + name !== name) { // name must be a string\n\t\t\tparentTmpl = item;\n\t\t\titem = name;\n\t\t\tname = undefined;\n\t\t}\n\t\tthisStore = parentTmpl\n\t\t\t? storeName === \"viewModel\"\n\t\t\t\t? parentTmpl\n\t\t\t\t: (parentTmpl[storeNames] = parentTmpl[storeNames] || {})\n\t\t\t: theStore;\n\t\tcompile = storeSettings.compile;\n\n\t\tif (item === undefined) {\n\t\t\titem = compile ? name : thisStore[name];\n\t\t\tname = undefined;\n\t\t}\n\t\tif (item === null) {\n\t\t\t// If item is null, delete this entry\n\t\t\tif (name) {\n\t\t\t\tdelete thisStore[name];\n\t\t\t}\n\t\t} else {\n\t\t\tif (compile) {\n\t\t\t\titem = compile.call(thisStore, name, item, parentTmpl, 0) || {};\n\t\t\t\titem._is = storeName; // Only do this for compiled objects (tags, templates...)\n\t\t\t}\n\t\t\tif (name) {\n\t\t\t\tthisStore[name] = item;\n\t\t\t}\n\t\t}\n\t\tif (onStore) {\n\t\t\t// e.g. JsViews integration\n\t\t\tonStore(name, item, parentTmpl, compile);\n\t\t}\n\t\treturn item;\n\t}\n\n\tvar storeNames = storeName + \"s\";\n\t$views[storeNames] = theStore;\n}\n\n/**\n* Add settings such as:\n* $.views.settings.allowCode(true)\n* @param {boolean}  value\n* @returns {Settings}\n*\n* allowCode = $.views.settings.allowCode()\n* @returns {boolean}\n*/\nfunction addSetting(st) {\n\t$viewsSettings[st] = function(value) {\n\t\treturn arguments.length\n\t\t\t? ($subSettings[st] = value, $viewsSettings)\n\t\t\t: $subSettings[st];\n\t};\n}\n\n//========================\n// dataMap for render only\n//========================\n\nfunction dataMap(mapDef) {\n\tfunction Map(source, options) {\n\t\tthis.tgt = mapDef.getTgt(source, options);\n\t\toptions.map = this;\n\t}\n\n\tif ($isFunction(mapDef)) {\n\t\t// Simple map declared as function\n\t\tmapDef = {\n\t\t\tgetTgt: mapDef\n\t\t};\n\t}\n\n\tif (mapDef.baseMap) {\n\t\tmapDef = $extend($extend({}, mapDef.baseMap), mapDef);\n\t}\n\n\tmapDef.map = function(source, options) {\n\t\treturn new Map(source, options);\n\t};\n\treturn mapDef;\n}\n\n//==============\n// renderContent\n//==============\n\n/** Render the template as a string, using the specified data and helpers/context\n* $(\"#tmpl\").render(), tmpl.render(), tagCtx.render(), $.render.namedTmpl()\n*\n* @param {any}        data\n* @param {hash}       [context]           helpers or context\n* @param {boolean}    [noIteration]\n* @param {View}       [parentView]        internal\n* @param {string}     [key]               internal\n* @param {function}   [onRender]          internal\n* @returns {string}   rendered template   internal\n*/\nfunction renderContent(data, context, noIteration, parentView, key, onRender) {\n\tvar i, l, tag, tmpl, tagCtx, isTopRenderCall, prevData, prevIndex,\n\t\tview = parentView,\n\t\tresult = \"\";\n\n\tif (context === true) {\n\t\tnoIteration = context; // passing boolean as second param - noIteration\n\t\tcontext = undefined;\n\t} else if (typeof context !== OBJECT) {\n\t\tcontext = undefined; // context must be a boolean (noIteration) or a plain object\n\t}\n\n\tif (tag = this.tag) {\n\t\t// This is a call from renderTag or tagCtx.render(...)\n\t\ttagCtx = this;\n\t\tview = view || tagCtx.view;\n\t\ttmpl = view._getTmpl(tag.template || tagCtx.tmpl);\n\t\tif (!arguments.length) {\n\t\t\tdata = tag.contentCtx && $isFunction(tag.contentCtx)\n\t\t\t\t? data = tag.contentCtx(data)\n\t\t\t\t: view; // Default data context for wrapped block content is the first argument\n\t\t}\n\t} else {\n\t\t// This is a template.render(...) call\n\t\ttmpl = this;\n\t}\n\n\tif (tmpl) {\n\t\tif (!parentView && data && data._is === \"view\") {\n\t\t\tview = data; // When passing in a view to render or link (and not passing in a parent view) use the passed-in view as parentView\n\t\t}\n\n\t\tif (view && data === view) {\n\t\t\t// Inherit the data from the parent view.\n\t\t\tdata = view.data;\n\t\t}\n\n\t\tisTopRenderCall = !view;\n\t\tisRenderCall = isRenderCall || isTopRenderCall;\n\t\tif (!view) {\n\t\t\t(context = context || {}).root = data; // Provide ~root as shortcut to top-level data.\n\t\t}\n\t\tif (!isRenderCall || $subSettingsAdvanced.useViews || tmpl.useViews || view && view !== topView) {\n\t\t\tresult = renderWithViews(tmpl, data, context, noIteration, view, key, onRender, tag);\n\t\t} else {\n\t\t\tif (view) { // In a block\n\t\t\t\tprevData = view.data;\n\t\t\t\tprevIndex = view.index;\n\t\t\t\tview.index = indexStr;\n\t\t\t} else {\n\t\t\t\tview = topView;\n\t\t\t\tprevData = view.data;\n\t\t\t\tview.data = data;\n\t\t\t\tview.ctx = context;\n\t\t\t}\n\t\t\tif ($isArray(data) && !noIteration) {\n\t\t\t\t// Create a view for the array, whose child views correspond to each data item. (Note: if key and parentView are passed in\n\t\t\t\t// along with parent view, treat as insert -e.g. from view.addViews - so parentView is already the view item for array)\n\t\t\t\tfor (i = 0, l = data.length; i < l; i++) {\n\t\t\t\t\tview.index = i;\n\t\t\t\t\tview.data = data[i];\n\t\t\t\t\tresult += tmpl.fn(data[i], view, $sub);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tview.data = data;\n\t\t\t\tresult += tmpl.fn(data, view, $sub);\n\t\t\t}\n\t\t\tview.data = prevData;\n\t\t\tview.index = prevIndex;\n\t\t}\n\t\tif (isTopRenderCall) {\n\t\t\tisRenderCall = undefined;\n\t\t}\n\t}\n\treturn result;\n}\n\nfunction renderWithViews(tmpl, data, context, noIteration, view, key, onRender, tag) {\n\tfunction setItemVar(item) {\n\t\t// When itemVar is specified, set modified ctx with user-named ~item\n\t\tnewCtx = $extend({}, context);\n\t\tnewCtx[itemVar] = item;\n\t}\n\n\t// Render template against data as a tree of subviews (nested rendered template instances), or as a string (top-level template).\n\t// If the data is the parent view, treat as noIteration, re-render with the same data context.\n\t// tmpl can be a string (e.g. rendered by a tag.render() method), or a compiled template.\n\tvar i, l, newView, childView, itemResult, swapContent, contentTmpl, outerOnRender, tmplName, itemVar, newCtx, tagCtx, noLinking,\n\t\tresult = \"\";\n\n\tif (tag) {\n\t\t// This is a call from renderTag or tagCtx.render(...)\n\t\ttmplName = tag.tagName;\n\t\ttagCtx = tag.tagCtx;\n\t\tcontext = context ? extendCtx(context, tag.ctx) : tag.ctx;\n\n\t\tif (tmpl === view.content) { // {{xxx tmpl=#content}}\n\t\t\tcontentTmpl = tmpl !== view.ctx._wrp // We are rendering the #content\n\t\t\t\t? view.ctx._wrp // #content was the tagCtx.props.tmpl wrapper of the block content - so within this view, #content will now be the view.ctx._wrp block content\n\t\t\t\t: undefined; // #content was the view.ctx._wrp block content - so within this view, there is no longer any #content to wrap.\n\t\t} else if (tmpl !== tagCtx.content) {\n\t\t\tif (tmpl === tag.template) { // Rendering {{tag}} tag.template, replacing block content.\n\t\t\t\tcontentTmpl = tagCtx.tmpl; // Set #content to block content (or wrapped block content if tagCtx.props.tmpl is set)\n\t\t\t\tcontext._wrp = tagCtx.content; // Pass wrapped block content to nested views\n\t\t\t} else { // Rendering tagCtx.props.tmpl wrapper\n\t\t\t\tcontentTmpl = tagCtx.content || view.content; // Set #content to wrapped block content\n\t\t\t}\n\t\t} else {\n\t\t\tcontentTmpl = view.content; // Nested views inherit same wrapped #content property\n\t\t}\n\n\t\tif (tagCtx.props.link === false) {\n\t\t\t// link=false setting on block tag\n\t\t\t// We will override inherited value of link by the explicit setting link=false taken from props\n\t\t\t// The child views of an unlinked view are also unlinked. So setting child back to true will not have any effect.\n\t\t\tcontext = context || {};\n\t\t\tcontext.link = false;\n\t\t}\n\t\tif (itemVar = tagCtx.props.itemVar) {\n\t\t\tif (itemVar[0] !== \"~\") {\n\t\t\t\tsyntaxError(\"Use itemVar='~myItem'\");\n\t\t\t}\n\t\t\titemVar = itemVar.slice(1);\n\t\t}\n\t}\n\n\tif (view) {\n\t\tonRender = onRender || view._.onRender;\n\t\tnoLinking = context && context.link === false;\n\n\t\tif (noLinking && view._.nl) {\n\t\t\tonRender = undefined;\n\t\t}\n\n\t\tcontext = extendCtx(context, view.ctx);\n\t}\n\n\tif (key === true) {\n\t\tswapContent = true;\n\t\tkey = 0;\n\t}\n\n\t// If link===false, do not call onRender, so no data-linking marker nodes\n\tif (onRender && tag && tag._.noVws) {\n\t\tonRender = undefined;\n\t}\n\touterOnRender = onRender;\n\tif (onRender === true) {\n\t\t// Used by view.refresh(). Don't create a new wrapper view.\n\t\touterOnRender = undefined;\n\t\tonRender = view._.onRender;\n\t}\n\t// Set additional context on views created here, (as modified context inherited from the parent, and to be inherited by child views)\n\tcontext = tmpl.helpers\n\t\t? extendCtx(tmpl.helpers, context)\n\t\t: context;\n\n\tnewCtx = context;\n\tif ($isArray(data) && !noIteration) {\n\t\t// Create a view for the array, whose child views correspond to each data item. (Note: if key and view are passed in\n\t\t// along with parent view, treat as insert -e.g. from view.addViews - so view is already the view item for array)\n\t\tnewView = swapContent\n\t\t\t? view\n\t\t\t: (key !== undefined && view)\n\t\t\t\t|| new View(context, \"array\", view, data, tmpl, key, onRender, contentTmpl);\n\t\tnewView._.nl= noLinking;\n\t\tif (view && view._.useKey) {\n\t\t\t// Parent is not an 'array view'\n\t\t\tnewView._.bnd = !tag || tag._.bnd && tag; // For array views that are data bound for collection change events, set the\n\t\t\t// view._.bnd property to true for top-level link() or data-link=\"{for}\", or to the tag instance for a data-bound tag, e.g. {^{for ...}}\n\t\t\tnewView.tag = tag;\n\t\t}\n\t\tfor (i = 0, l = data.length; i < l; i++) {\n\t\t\t// Create a view for each data item.\n\t\t\tif (itemVar) {\n\t\t\t\tsetItemVar(data[i]); // use modified ctx with user-named ~item\n\t\t\t}\n\t\t\tchildView = new View(newCtx, \"item\", newView, data[i], tmpl, (key || 0) + i, onRender, newView.content);\n\t\t\tchildView._.it = itemVar;\n\n\t\t\titemResult = tmpl.fn(data[i], childView, $sub);\n\t\t\tresult += newView._.onRender ? newView._.onRender(itemResult, childView) : itemResult;\n\t\t}\n\t} else {\n\t\t// Create a view for singleton data object. The type of the view will be the tag name, e.g. \"if\" or \"mytag\" except for\n\t\t// \"item\", \"array\" and \"data\" views. A \"data\" view is from programmatic render(object) against a 'singleton'.\n\t\tif (itemVar) {\n\t\t\tsetItemVar(data);\n\t\t}\n\t\tnewView = swapContent ? view : new View(newCtx, tmplName || \"data\", view, data, tmpl, key, onRender, contentTmpl);\n\t\tnewView._.it = itemVar;\n\t\tnewView.tag = tag;\n\t\tnewView._.nl = noLinking;\n\t\tresult += tmpl.fn(data, newView, $sub);\n\t}\n\tif (tag) {\n\t\tnewView.tagElse = tagCtx.index;\n\t\ttagCtx.contentView = newView;\n\t}\n\treturn outerOnRender ? outerOnRender(result, newView) : result;\n}\n\n//===========================\n// Build and compile template\n//===========================\n\n// Generate a reusable function that will serve to render a template against data\n// (Compile AST then build template function)\n\nfunction onRenderError(e, view, fallback) {\n\tvar message = fallback !== undefined\n\t\t? $isFunction(fallback)\n\t\t\t? fallback.call(view.data, e, view)\n\t\t\t: fallback || \"\"\n\t\t: \"{Error: \" + (e.message||e) + \"}\";\n\n\tif ($subSettings.onError && (fallback = $subSettings.onError.call(view.data, e, fallback && message, view)) !== undefined) {\n\t\tmessage = fallback; // There is a settings.debugMode(handler) onError override. Call it, and use return value (if any) to replace message\n\t}\n\treturn view && !view._lc ? $converters.html(message) : message; // For data-link=\\\"{... onError=...}\"... See onDataLinkedTagChange\n}\n\nfunction error(message) {\n\tthrow new $sub.Err(message);\n}\n\nfunction syntaxError(message) {\n\terror(\"Syntax error\\n\" + message);\n}\n\nfunction tmplFn(markup, tmpl, isLinkExpr, convertBack, hasElse) {\n\t// Compile markup to AST (abtract syntax tree) then build the template function code from the AST nodes\n\t// Used for compiling templates, and also by JsViews to build functions for data link expressions\n\n\t//==== nested functions ====\n\tfunction pushprecedingContent(shift) {\n\t\tshift -= loc;\n\t\tif (shift) {\n\t\t\tcontent.push(markup.substr(loc, shift).replace(rNewLine, \"\\\\n\"));\n\t\t}\n\t}\n\n\tfunction blockTagCheck(tagName, block) {\n\t\tif (tagName) {\n\t\t\ttagName += '}}';\n\t\t\t//\t\t\t'{{include}} block has {{/for}} with no open {{for}}'\n\t\t\tsyntaxError((\n\t\t\t\tblock\n\t\t\t\t\t? '{{' + block + '}} block has {{/' + tagName + ' without {{' + tagName\n\t\t\t\t\t: 'Unmatched or missing {{/' + tagName) + ', in template:\\n' + markup);\n\t\t}\n\t}\n\n\tfunction parseTag(all, bind, tagName, converter, colon, html, codeTag, params, slash, bind2, closeBlock, index) {\n/*\n\n     bind     tagName         cvt   cln html code    params            slash   bind2         closeBlk  comment\n/(?:{(\\^)?{(?:(\\w+(?=[\\/\\s}]))|(\\w+)?(:)|(>)|(\\*))\\s*((?:[^}]|}(?!}))*?)(\\/)?|{(\\^)?{(?:(?:\\/(\\w+))\\s*|!--[\\s\\S]*?--))}}/g\n\n(?:\n  {(\\^)?{            bind\n  (?:\n    (\\w+             tagName\n      (?=[\\/\\s}])\n    )\n    |\n    (\\w+)?(:)        converter colon\n    |\n    (>)              html\n    |\n    (\\*)             codeTag\n  )\n  \\s*\n  (                  params\n    (?:[^}]|}(?!}))*?\n  )\n  (\\/)?              slash\n  |\n  {(\\^)?{            bind2\n  (?:\n    (?:\\/(\\w+))\\s*   closeBlock\n    |\n    !--[\\s\\S]*?--    comment\n  )\n)\n}}/g\n\n*/\n\t\tif (codeTag && bind || slash && !tagName || params && params.slice(-1) === \":\" || bind2) {\n\t\t\tsyntaxError(all);\n\t\t}\n\n\t\t// Build abstract syntax tree (AST): [tagName, converter, params, content, hash, bindings, contentMarkup]\n\t\tif (html) {\n\t\t\tcolon = \":\";\n\t\t\tconverter = HTML;\n\t\t}\n\t\tslash = slash || isLinkExpr && !hasElse;\n\n\t\tvar late, openTagName, isLateOb,\n\t\t\tpathBindings = (bind || isLinkExpr) && [[]], // pathBindings is an array of arrays for arg bindings and a hash of arrays for prop bindings\n\t\t\tprops = \"\",\n\t\t\targs = \"\",\n\t\t\tctxProps = \"\",\n\t\t\tparamsArgs = \"\",\n\t\t\tparamsProps = \"\",\n\t\t\tparamsCtxProps = \"\",\n\t\t\tonError = \"\",\n\t\t\tuseTrigger = \"\",\n\t\t\t// Block tag if not self-closing and not {{:}} or {{>}} (special case) and not a data-link expression\n\t\t\tblock = !slash && !colon;\n\n\t\t//==== nested helper function ====\n\t\ttagName = tagName || (params = params || \"#data\", colon); // {{:}} is equivalent to {{:#data}}\n\t\tpushprecedingContent(index);\n\t\tloc = index + all.length; // location marker - parsed up to here\n\t\tif (codeTag) {\n\t\t\tif (allowCode) {\n\t\t\t\tcontent.push([\"*\", \"\\n\" + params.replace(/^:/, \"ret+= \").replace(rUnescapeQuotes, \"$1\") + \";\\n\"]);\n\t\t\t}\n\t\t} else if (tagName) {\n\t\t\tif (tagName === \"else\") {\n\t\t\t\tif (rTestElseIf.test(params)) {\n\t\t\t\t\tsyntaxError('For \"{{else if expr}}\" use \"{{else expr}}\"');\n\t\t\t\t}\n\t\t\t\tpathBindings = current[9] && [[]];\n\t\t\t\tcurrent[10] = markup.substring(current[10], index); // contentMarkup for block tag\n\t\t\t\topenTagName = current[11] || current[0] || syntaxError(\"Mismatched: \" + all);\n\t\t\t\t// current[0] is tagName, but for {{else}} nodes, current[11] is tagName of preceding open tag\n\t\t\t\tcurrent = stack.pop();\n\t\t\t\tcontent = current[2];\n\t\t\t\tblock = true;\n\t\t\t}\n\t\t\tif (params) {\n\t\t\t\t// remove newlines from the params string, to avoid compiled code errors for unterminated strings\n\t\t\t\tparseParams(params.replace(rNewLine, \" \"), pathBindings, tmpl, isLinkExpr)\n\t\t\t\t\t.replace(rBuildHash, function(all, onerror, isCtxPrm, key, keyToken, keyValue, arg, param) {\n\t\t\t\t\t\tif (key === \"this:\") {\n\t\t\t\t\t\t\tkeyValue = \"undefined\"; // this=some.path is always a to parameter (one-way), so don't need to compile/evaluate some.path initialization\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (param) {\n\t\t\t\t\t\t\tisLateOb = isLateOb || param[0] === \"@\";\n\t\t\t\t\t\t}\n\t\t\t\t\t\tkey = \"'\" + keyToken + \"':\";\n\t\t\t\t\t\tif (arg) {\n\t\t\t\t\t\t\targs += isCtxPrm + keyValue + \",\";\n\t\t\t\t\t\t\tparamsArgs += \"'\" + param + \"',\";\n\t\t\t\t\t\t} else if (isCtxPrm) { // Contextual parameter, ~foo=expr\n\t\t\t\t\t\t\tctxProps += key + 'j._cp(' + keyValue + ',\"' + param + '\",view),';\n\t\t\t\t\t\t\t// Compiled code for evaluating tagCtx on a tag will have: ctx:{'foo':j._cp(compiledExpr, \"expr\", view)}\n\t\t\t\t\t\t\tparamsCtxProps += key + \"'\" + param + \"',\";\n\t\t\t\t\t\t} else if (onerror) {\n\t\t\t\t\t\t\tonError += keyValue;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tif (keyToken === \"trigger\") {\n\t\t\t\t\t\t\t\tuseTrigger += keyValue;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif (keyToken === \"lateRender\") {\n\t\t\t\t\t\t\t\tlate = param !== \"false\"; // Render after first pass\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tprops += key + keyValue + \",\";\n\t\t\t\t\t\t\tparamsProps += key + \"'\" + param + \"',\";\n\t\t\t\t\t\t\thasHandlers = hasHandlers || rHasHandlers.test(keyToken);\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn \"\";\n\t\t\t\t\t}).slice(0, -1);\n\t\t\t}\n\n\t\t\tif (pathBindings && pathBindings[0]) {\n\t\t\t\tpathBindings.pop(); // Remove the binding that was prepared for next arg. (There is always an extra one ready).\n\t\t\t}\n\n\t\t\tnewNode = [\n\t\t\t\t\ttagName,\n\t\t\t\t\tconverter || !!convertBack || hasHandlers || \"\",\n\t\t\t\t\tblock && [],\n\t\t\t\t\tparsedParam(paramsArgs || (tagName === \":\" ? \"'#data',\" : \"\"), paramsProps, paramsCtxProps), // {{:}} equivalent to {{:#data}}\n\t\t\t\t\tparsedParam(args || (tagName === \":\" ? \"data,\" : \"\"), props, ctxProps),\n\t\t\t\t\tonError,\n\t\t\t\t\tuseTrigger,\n\t\t\t\t\tlate,\n\t\t\t\t\tisLateOb,\n\t\t\t\t\tpathBindings || 0\n\t\t\t\t];\n\t\t\tcontent.push(newNode);\n\t\t\tif (block) {\n\t\t\t\tstack.push(current);\n\t\t\t\tcurrent = newNode;\n\t\t\t\tcurrent[10] = loc; // Store current location of open tag, to be able to add contentMarkup when we reach closing tag\n\t\t\t\tcurrent[11] = openTagName; // Used for checking syntax (matching close tag)\n\t\t\t}\n\t\t} else if (closeBlock) {\n\t\t\tblockTagCheck(closeBlock !== current[0] && closeBlock !== current[11] && closeBlock, current[0]); // Check matching close tag name\n\t\t\tcurrent[10] = markup.substring(current[10], index); // contentMarkup for block tag\n\t\t\tcurrent = stack.pop();\n\t\t}\n\t\tblockTagCheck(!current && closeBlock);\n\t\tcontent = current[2];\n\t}\n\t//==== /end of nested functions ====\n\n\tvar i, result, newNode, hasHandlers, bindings,\n\t\tallowCode = $subSettings.allowCode || tmpl && tmpl.allowCode\n\t\t\t|| $viewsSettings.allowCode === true, // include direct setting of settings.allowCode true for backward compat only\n\t\tastTop = [],\n\t\tloc = 0,\n\t\tstack = [],\n\t\tcontent = astTop,\n\t\tcurrent = [,,astTop];\n\n\tif (allowCode && tmpl._is) {\n\t\ttmpl.allowCode = allowCode;\n\t}\n\n//TODO\tresult = tmplFnsCache[markup]; // Only cache if template is not named and markup length < ...,\n//and there are no bindings or subtemplates?? Consider standard optimization for data-link=\"a.b.c\"\n//\t\tif (result) {\n//\t\t\ttmpl.fn = result;\n//\t\t} else {\n\n//\t\tresult = markup;\n\tif (isLinkExpr) {\n\t\tif (convertBack !== undefined) {\n\t\t\tmarkup = markup.slice(0, -convertBack.length - 2) + delimCloseChar0;\n\t\t}\n\t\tmarkup = delimOpenChar0 + markup + delimCloseChar1;\n\t}\n\n\tblockTagCheck(stack[0] && stack[0][2].pop()[0]);\n\t// Build the AST (abstract syntax tree) under astTop\n\tmarkup.replace(rTag, parseTag);\n\n\tpushprecedingContent(markup.length);\n\n\tif (loc = astTop[astTop.length - 1]) {\n\t\tblockTagCheck(\"\" + loc !== loc && (+loc[10] === loc[10]) && loc[0]);\n\t}\n//\t\t\tresult = tmplFnsCache[markup] = buildCode(astTop, tmpl);\n//\t\t}\n\n\tif (isLinkExpr) {\n\t\tresult = buildCode(astTop, markup, isLinkExpr);\n\t\tbindings = [];\n\t\ti = astTop.length;\n\t\twhile (i--) {\n\t\t\tbindings.unshift(astTop[i][9]); // With data-link expressions, pathBindings array for tagCtx[i] is astTop[i][9]\n\t\t}\n\t\tsetPaths(result, bindings);\n\t} else {\n\t\tresult = buildCode(astTop, tmpl);\n\t}\n\treturn result;\n}\n\nfunction setPaths(fn, pathsArr) {\n\tvar key, paths,\n\t\ti = 0,\n\t\tl = pathsArr.length;\n\tfn.deps = [];\n\tfn.paths = []; // The array of path binding (array/dictionary)s for each tag/else block's args and props\n\tfor (; i < l; i++) {\n\t\tfn.paths.push(paths = pathsArr[i]);\n\t\tfor (key in paths) {\n\t\t\tif (key !== \"_jsvto\" && paths.hasOwnProperty(key) && paths[key].length && !paths[key].skp) {\n\t\t\t\tfn.deps = fn.deps.concat(paths[key]); // deps is the concatenation of the paths arrays for the different bindings\n\t\t\t}\n\t\t}\n\t}\n}\n\nfunction parsedParam(args, props, ctx) {\n\treturn [args.slice(0, -1), props.slice(0, -1), ctx.slice(0, -1)];\n}\n\nfunction paramStructure(parts, type) {\n\treturn '\\n\\t'\n\t\t+ (type\n\t\t\t? type + ':{'\n\t\t\t: '')\n\t\t+ 'args:[' + parts[0] + '],\\n\\tprops:{' + parts[1] + '}'\n\t\t+ (parts[2] ? ',\\n\\tctx:{' + parts[2] + '}' : \"\");\n}\n\nfunction parseParams(params, pathBindings, tmpl, isLinkExpr) {\n\n\tfunction parseTokens(all, lftPrn0, lftPrn, bound, path, operator, err, eq, path2, late, prn, comma, lftPrn2, apos, quot, rtPrn, rtPrnDot, prn2, space, index, full) {\n\t// /(\\()(?=\\s*\\()|(?:([([])\\s*)?(?:(\\^?)(~?[\\w$.^]+)?\\s*((\\+\\+|--)|\\+|-|~(?![\\w$])|&&|\\|\\||===|!==|==|!=|<=|>=|[<>%*:?\\/]|(=))\\s*|(!*?(@)?[#~]?[\\w$.^]+)([([])?)|(,\\s*)|(\\(?)\\\\?(?:(')|(\"))|(?:\\s*(([)\\]])(?=[.^]|\\s*$|[^([])|[)\\]])([([]?))|(\\s+)/g,\n\t//lftPrn0           lftPrn         bound     path               operator     err                                          eq      path2 late            prn      comma  lftPrn2   apos quot        rtPrn  rtPrnDot                  prn2     space\n\t// (left paren? followed by (path? followed by operator) or (path followed by paren?)) or comma or apos or quot or right paren or space\n\n\t\tfunction parsePath(allPath, not, object, helper, view, viewProperty, pathTokens, leafToken) {\n\t\t\t// /^(!*?)(?:null|true|false|\\d[\\d.]*|([\\w$]+|\\.|~([\\w$]+)|#(view|([\\w$]+))?)([\\w$.^]*?)(?:[.[^]([\\w$]+)\\]?)?)$/g,\n\t\t\t//    not                               object     helper    view  viewProperty pathTokens      leafToken\n\t\t\tvar subPath = object === \".\";\n\t\t\tif (object) {\n\t\t\t\tpath = path.slice(not.length);\n\t\t\t\tif (/^\\.?constructor$/.test(leafToken||path)) {\n\t\t\t\t\tsyntaxError(allPath);\n\t\t\t\t}\n\t\t\t\tif (!subPath) {\n\t\t\t\t\tallPath = (late // late path @a.b.c: not throw on 'property of undefined' if a undefined, and will use _getOb() after linking to resolve late.\n\t\t\t\t\t\t\t? (isLinkExpr ? '' : '(ltOb.lt=ltOb.lt||') + '(ob='\n\t\t\t\t\t\t\t: \"\"\n\t\t\t\t\t\t)\n\t\t\t\t\t\t+ (helper\n\t\t\t\t\t\t\t? 'view.ctxPrm(\"' + helper + '\")'\n\t\t\t\t\t\t\t: view\n\t\t\t\t\t\t\t\t? \"view\"\n\t\t\t\t\t\t\t\t: \"data\")\n\t\t\t\t\t\t+ (late\n\t\t\t\t\t\t\t? ')===undefined' + (isLinkExpr ? '' : ')') + '?\"\":view._getOb(ob,\"'\n\t\t\t\t\t\t\t: \"\"\n\t\t\t\t\t\t)\n\t\t\t\t\t\t+ (leafToken\n\t\t\t\t\t\t\t? (viewProperty\n\t\t\t\t\t\t\t\t? \".\" + viewProperty\n\t\t\t\t\t\t\t\t: helper\n\t\t\t\t\t\t\t\t\t? \"\"\n\t\t\t\t\t\t\t\t\t: (view ? \"\" : \".\" + object)\n\t\t\t\t\t\t\t\t) + (pathTokens || \"\")\n\t\t\t\t\t\t\t: (leafToken = helper ? \"\" : view ? viewProperty || \"\" : object, \"\"));\n\t\t\t\t\tallPath = allPath + (leafToken ? \".\" + leafToken : \"\");\n\n\t\t\t\t\tallPath = not + (allPath.slice(0, 9) === \"view.data\"\n\t\t\t\t\t\t? allPath.slice(5) // convert #view.data... to data...\n\t\t\t\t\t\t: allPath)\n\t\t\t\t\t+ (late\n\t\t\t\t\t\t\t? (isLinkExpr ? '\"': '\",ltOb') + (prn ? ',1)':')')\n\t\t\t\t\t\t\t: \"\"\n\t\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t\tif (bindings) {\n\t\t\t\t\tbinds = named === \"_linkTo\" ? (bindto = pathBindings._jsvto = pathBindings._jsvto || []) : bndCtx.bd;\n\t\t\t\t\tif (theOb = subPath && binds[binds.length-1]) {\n\t\t\t\t\t\tif (theOb._cpfn) { // Computed property exprOb\n\t\t\t\t\t\t\twhile (theOb.sb) {\n\t\t\t\t\t\t\t\ttheOb = theOb.sb;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif (theOb.bnd) {\n\t\t\t\t\t\t\t\tpath = \"^\" + path.slice(1);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\ttheOb.sb = path;\n\t\t\t\t\t\t\ttheOb.bnd = theOb.bnd || path[0] === \"^\";\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tbinds.push(path);\n\t\t\t\t\t}\n\t\t\t\t\tpathStart[parenDepth] = index + (subPath ? 1 : 0);\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn allPath;\n\t\t}\n\n\t\t//bound = bindings && bound;\n\t\tif (bound && !eq) {\n\t\t\tpath = bound + path; // e.g. some.fn(...)^some.path - so here path is \"^some.path\"\n\t\t}\n\t\toperator = operator || \"\";\n\t\tlftPrn = lftPrn || lftPrn0 || lftPrn2;\n\t\tpath = path || path2;\n\n\t\tif (late && (late = !/\\)|]/.test(full[index-1]))) {\n\t\t\tpath = path.slice(1).split(\".\").join(\"^\"); // Late path @z.b.c. Use \"^\" rather than \".\" to ensure that deep binding will be used\n\t\t}\n\t\t// Could do this - but not worth perf cost?? :-\n\t\t// if (!path.lastIndexOf(\"#data.\", 0)) { path = path.slice(6); } // If path starts with \"#data.\", remove that.\n\t\tprn = prn || prn2 || \"\";\n\n\t\tvar expr, exprFn, binds, theOb, newOb,\n\t\t\trtSq = \")\";\n\n\t\tif (prn === \"[\") {\n\t\t\tprn = \"[j._sq(\";\n\t\t\trtSq = \")]\";\n\t\t}\n\n\t\tif (err && !aposed && !quoted) {\n\t\t\tsyntaxError(params);\n\t\t} else {\n\t\t\tif (bindings && rtPrnDot && !aposed && !quoted) {\n\t\t\t\t// This is a binding to a path in which an object is returned by a helper/data function/expression, e.g. foo()^x.y or (a?b:c)^x.y\n\t\t\t\t// We create a compiled function to get the object instance (which will be called when the dependent data of the subexpression changes, to return the new object, and trigger re-binding of the subsequent path)\n\t\t\t\tif (parenDepth) {\n\t\t\t\t\texpr = pathStart[parenDepth - 1];\n\t\t\t\t\tif (full.length - 1 > index - (expr || 0)) { // We need to compile a subexpression\n\t\t\t\t\t\texpr = full.slice(expr, index + all.length);\n\t\t\t\t\t\tif (exprFn !== true) { // If not reentrant call during compilation\n\t\t\t\t\t\t\tbinds = bindto || bndStack[parenDepth-1].bd;\n\t\t\t\t\t\t\t// Insert exprOb object, to be used during binding to return the computed object\n\t\t\t\t\t\t\ttheOb = binds[binds.length-1];\n\t\t\t\t\t\t\tif (theOb && theOb.prm) {\n\t\t\t\t\t\t\t\twhile (theOb.sb && theOb.sb.prm) {\n\t\t\t\t\t\t\t\t\ttheOb = theOb.sb;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tnewOb = theOb.sb = {path: theOb.sb, bnd: theOb.bnd};\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tbinds.push(newOb = {path: binds.pop()}); // Insert exprOb object, to be used during binding to return the computed object\n\t\t\t\t\t\t\t}\t\t\t\t\t\t\t\t\t\t\t // (e.g. \"some.object()\" in \"some.object().a.b\" - to be used as context for binding the following tokens \"a.b\")\n\t\t\t\t\t\t}\n\t\t\t\t\t\trtPrnDot = delimOpenChar1 + \":\" + expr // The parameter or function subexpression\n\t\t\t\t\t\t\t+ \" onerror=''\" // set onerror='' in order to wrap generated code with a try catch - returning '' as object instance if there is an error/missing parent\n\t\t\t\t\t\t\t+ delimCloseChar0;\n\t\t\t\t\t\texprFn = tmplLinks[rtPrnDot];\n\t\t\t\t\t\tif (!exprFn) {\n\t\t\t\t\t\t\ttmplLinks[rtPrnDot] = true; // Flag that this exprFn (for rtPrnDot) is being compiled\n\t\t\t\t\t\t\ttmplLinks[rtPrnDot] = exprFn = tmplFn(rtPrnDot, tmpl, true); // Compile the expression (or use cached copy already in tmpl.links)\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (exprFn !== true && newOb) {\n\t\t\t\t\t\t\t// If not reentrant call during compilation\n\t\t\t\t\t\t\tnewOb._cpfn = exprFn;\n\t\t\t\t\t\t\tnewOb.prm = bndCtx.bd;\n\t\t\t\t\t\t\tnewOb.bnd = newOb.bnd || newOb.path && newOb.path.indexOf(\"^\") >= 0;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn (aposed\n\t\t\t\t// within single-quoted string\n\t\t\t\t? (aposed = !apos, (aposed ? all : lftPrn2 + '\"'))\n\t\t\t\t: quoted\n\t\t\t\t// within double-quoted string\n\t\t\t\t\t? (quoted = !quot, (quoted ? all : lftPrn2 + '\"'))\n\t\t\t\t\t:\n\t\t\t\t(\n\t\t\t\t\t(lftPrn\n\t\t\t\t\t\t? (pathStart[parenDepth] = index++, bndCtx = bndStack[++parenDepth] = {bd: []}, lftPrn)\n\t\t\t\t\t\t: \"\")\n\t\t\t\t\t+ (space\n\t\t\t\t\t\t? (parenDepth\n\t\t\t\t\t\t\t? \"\"\n\t\t\t\t// New arg or prop - so insert backspace \\b (\\x08) as separator for named params, used subsequently by rBuildHash, and prepare new bindings array\n\t\t\t\t\t\t\t: (paramIndex = full.slice(paramIndex, index), named\n\t\t\t\t\t\t\t\t? (named = boundName = bindto = false, \"\\b\")\n\t\t\t\t\t\t\t\t: \"\\b,\") + paramIndex + (paramIndex = index + all.length, bindings && pathBindings.push(bndCtx.bd = []), \"\\b\")\n\t\t\t\t\t\t)\n\t\t\t\t\t\t: eq\n\t\t\t\t// named param. Remove bindings for arg and create instead bindings array for prop\n\t\t\t\t\t\t\t? (parenDepth && syntaxError(params), bindings && pathBindings.pop(), named = \"_\" + path, boundName = bound, paramIndex = index + all.length,\n\t\t\t\t\t\t\t\t\tbindings && ((bindings = bndCtx.bd = pathBindings[named] = []), bindings.skp = !bound), path + ':')\n\t\t\t\t\t\t\t: path\n\t\t\t\t// path\n\t\t\t\t\t\t\t\t? (path.split(\"^\").join(\".\").replace($sub.rPath, parsePath)\n\t\t\t\t\t\t\t\t\t+ (prn\n\t\t\t\t// some.fncall(\n\t\t\t\t\t\t\t\t\t\t? (bndCtx = bndStack[++parenDepth] = {bd: []}, fnCall[parenDepth] = rtSq, prn)\n\t\t\t\t\t\t\t\t\t\t: operator)\n\t\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\t\t: operator\n\t\t\t\t// operator\n\t\t\t\t\t\t\t\t\t? operator\n\t\t\t\t\t\t\t\t\t: rtPrn\n\t\t\t\t// function\n\t\t\t\t\t\t\t\t\t\t? ((rtPrn = fnCall[parenDepth] || rtPrn, fnCall[parenDepth] = false, bndCtx = bndStack[--parenDepth], rtPrn)\n\t\t\t\t\t\t\t\t\t\t\t+ (prn // rtPrn and prn, e.g )( in (a)() or a()(), or )[ in a()[]\n\t\t\t\t\t\t\t\t\t\t\t\t? (bndCtx = bndStack[++parenDepth], fnCall[parenDepth] = rtSq, prn)\n\t\t\t\t\t\t\t\t\t\t\t\t: \"\")\n\t\t\t\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\t\t\t\t: comma\n\t\t\t\t\t\t\t\t\t\t\t? (fnCall[parenDepth] || syntaxError(params), \",\") // We don't allow top-level literal arrays or objects\n\t\t\t\t\t\t\t\t\t\t\t: lftPrn0\n\t\t\t\t\t\t\t\t\t\t\t\t? \"\"\n\t\t\t\t\t\t\t\t\t\t\t\t: (aposed = apos, quoted = quot, '\"')\n\t\t\t\t))\n\t\t\t);\n\t\t}\n\t}\n\n\tvar named, bindto, boundName,\n\t\tquoted, // boolean for string content in double quotes\n\t\taposed, // or in single quotes\n\t\tbindings = pathBindings && pathBindings[0], // bindings array for the first arg\n\t\tbndCtx = {bd: bindings},\n\t\tbndStack = {0: bndCtx},\n\t\tparamIndex = 0, // list,\n\t\ttmplLinks = (tmpl ? tmpl.links : bindings && (bindings.links = bindings.links || {})) || topView.tmpl.links,\n\t\t// The following are used for tracking path parsing including nested paths, such as \"a.b(c^d + (e))^f\", and chained computed paths such as\n\t\t// \"a.b().c^d().e.f().g\" - which has four chained paths, \"a.b()\", \"^c.d()\", \".e.f()\" and \".g\"\n\t\tparenDepth = 0,\n\t\tfnCall = {}, // We are in a function call\n\t\tpathStart = {}, // tracks the start of the current path such as c^d() in the above example\n\t\tresult;\n\n\tif (params[0] === \"@\") {\n\t\tparams = params.replace(rBracketQuote, \".\");\n\t}\n\tresult = (params + (tmpl ? \" \" : \"\")).replace($sub.rPrm, parseTokens);\n\n\treturn !parenDepth && result || syntaxError(params); // Syntax error if unbalanced parens in params expression\n}\n\nfunction buildCode(ast, tmpl, isLinkExpr) {\n\t// Build the template function code from the AST nodes, and set as property on the passed-in template object\n\t// Used for compiling templates, and also by JsViews to build functions for data link expressions\n\tvar i, node, tagName, converter, tagCtx, hasTag, hasEncoder, getsVal, hasCnvt, useCnvt, tmplBindings, pathBindings, params, boundOnErrStart,\n\t\tboundOnErrEnd, tagRender, nestedTmpls, tmplName, nestedTmpl, tagAndElses, content, markup, nextIsElse, oldCode, isElse, isGetVal, tagCtxFn,\n\t\tonError, tagStart, trigger, lateRender, retStrOpen, retStrClose,\n\t\ttmplBindingKey = 0,\n\t\tuseViews = $subSettingsAdvanced.useViews || tmpl.useViews || tmpl.tags || tmpl.templates || tmpl.helpers || tmpl.converters,\n\t\tcode = \"\",\n\t\ttmplOptions = {},\n\t\tl = ast.length;\n\n\tif (\"\" + tmpl === tmpl) {\n\t\ttmplName = isLinkExpr ? 'data-link=\"' + tmpl.replace(rNewLine, \" \").slice(1, -1) + '\"' : tmpl;\n\t\ttmpl = 0;\n\t} else {\n\t\ttmplName = tmpl.tmplName || \"unnamed\";\n\t\tif (tmpl.allowCode) {\n\t\t\ttmplOptions.allowCode = true;\n\t\t}\n\t\tif (tmpl.debug) {\n\t\t\ttmplOptions.debug = true;\n\t\t}\n\t\ttmplBindings = tmpl.bnds;\n\t\tnestedTmpls = tmpl.tmpls;\n\t}\n\tfor (i = 0; i < l; i++) {\n\t\t// AST nodes: [0: tagName, 1: converter, 2: content, 3: params, 4: code, 5: onError, 6: trigger, 7:pathBindings, 8: contentMarkup]\n\t\tnode = ast[i];\n\n\t\t// Add newline for each callout to t() c() etc. and each markup string\n\t\tif (\"\" + node === node) {\n\t\t\t// a markup string to be inserted\n\t\t\tcode += '\\n+\"' + node + '\"';\n\t\t} else {\n\t\t\t// a compiled tag expression to be inserted\n\t\t\ttagName = node[0];\n\t\t\tif (tagName === \"*\") {\n\t\t\t\t// Code tag: {{* }}\n\t\t\t\tcode += \";\\n\" + node[1] + \"\\nret=ret\";\n\t\t\t} else {\n\t\t\t\tconverter = node[1];\n\t\t\t\tcontent = !isLinkExpr && node[2];\n\t\t\t\ttagCtx = paramStructure(node[3], 'params') + '},' + paramStructure(params = node[4]);\n\t\t\t\ttrigger = node[6];\n\t\t\t\tlateRender = node[7];\n\t\t\t\tif (node[8]) { // latePath @a.b.c or @~a.b.c\n\t\t\t\t\tretStrOpen = \"\\nvar ob,ltOb={},ctxs=\";\n\t\t\t\t\tretStrClose = \";\\nctxs.lt=ltOb.lt;\\nreturn ctxs;\";\n\t\t\t\t} else {\n\t\t\t\t\tretStrOpen = \"\\nreturn \";\n\t\t\t\t\tretStrClose = \"\";\n\t\t\t\t}\n\t\t\t\tmarkup = node[10] && node[10].replace(rUnescapeQuotes, \"$1\");\n\t\t\t\tif (isElse = tagName === \"else\") {\n\t\t\t\t\tif (pathBindings) {\n\t\t\t\t\t\tpathBindings.push(node[9]);\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tonError = node[5] || $subSettings.debugMode !== false && \"undefined\"; // If debugMode not false, set default onError handler on tag to \"undefined\" (see onRenderError)\n\t\t\t\t\tif (tmplBindings && (pathBindings = node[9])) { // Array of paths, or false if not data-bound\n\t\t\t\t\t\tpathBindings = [pathBindings];\n\t\t\t\t\t\ttmplBindingKey = tmplBindings.push(1); // Add placeholder in tmplBindings for compiled function\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tuseViews = useViews || params[1] || params[2] || pathBindings || /view.(?!index)/.test(params[0]);\n\t\t\t\t// useViews is for perf optimization. For render() we only use views if necessary - for the more advanced scenarios.\n\t\t\t\t// We use views if there are props, contextual properties or args with #... (other than #index) - but you can force\n\t\t\t\t// using the full view infrastructure, (and pay a perf price) by opting in: Set useViews: true on the template, manually...\n\t\t\t\tif (isGetVal = tagName === \":\") {\n\t\t\t\t\tif (converter) {\n\t\t\t\t\t\ttagName = converter === HTML ? \">\" : converter + tagName;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tif (content) { // TODO optimize - if content.length === 0 or if there is a tmpl=\"...\" specified - set content to null / don't run this compilation code - since content won't get used!!\n\t\t\t\t\t\t// Create template object for nested template\n\t\t\t\t\t\tnestedTmpl = tmplObject(markup, tmplOptions);\n\t\t\t\t\t\tnestedTmpl.tmplName = tmplName + \"/\" + tagName;\n\t\t\t\t\t\t// Compile to AST and then to compiled function\n\t\t\t\t\t\tnestedTmpl.useViews = nestedTmpl.useViews || useViews;\n\t\t\t\t\t\tbuildCode(content, nestedTmpl);\n\t\t\t\t\t\tuseViews = nestedTmpl.useViews;\n\t\t\t\t\t\tnestedTmpls.push(nestedTmpl);\n\t\t\t\t\t}\n\n\t\t\t\t\tif (!isElse) {\n\t\t\t\t\t\t// This is not an else tag.\n\t\t\t\t\t\ttagAndElses = tagName;\n\t\t\t\t\t\tuseViews = useViews || tagName && (!$tags[tagName] || !$tags[tagName].flow);\n\t\t\t\t\t\t// Switch to a new code string for this bound tag (and its elses, if it has any) - for returning the tagCtxs array\n\t\t\t\t\t\toldCode = code;\n\t\t\t\t\t\tcode = \"\";\n\t\t\t\t\t}\n\t\t\t\t\tnextIsElse = ast[i + 1];\n\t\t\t\t\tnextIsElse = nextIsElse && nextIsElse[0] === \"else\";\n\t\t\t\t}\n\t\t\t\ttagStart = onError ? \";\\ntry{\\nret+=\" : \"\\n+\";\n\t\t\t\tboundOnErrStart = \"\";\n\t\t\t\tboundOnErrEnd = \"\";\n\n\t\t\t\tif (isGetVal && (pathBindings || trigger || converter && converter !== HTML || lateRender)) {\n\t\t\t\t\t// For convertVal we need a compiled function to return the new tagCtx(s)\n\t\t\t\t\ttagCtxFn = new Function(\"data,view,j,u\", \"// \" + tmplName + \" \" + (++tmplBindingKey) + \" \" + tagName\n\t\t\t\t\t\t+ retStrOpen + \"{\" + tagCtx + \"};\" + retStrClose);\n\t\t\t\t\ttagCtxFn._er = onError;\n\t\t\t\t\ttagCtxFn._tag = tagName;\n\t\t\t\t\ttagCtxFn._bd = !!pathBindings; // data-linked tag {^{.../}}\n\t\t\t\t\ttagCtxFn._lr = lateRender;\n\n\t\t\t\t\tif (isLinkExpr) {\n\t\t\t\t\t\treturn tagCtxFn;\n\t\t\t\t\t}\n\n\t\t\t\t\tsetPaths(tagCtxFn, pathBindings);\n\t\t\t\t\ttagRender = 'c(\"' + converter + '\",view,';\n\t\t\t\t\tuseCnvt = true;\n\t\t\t\t\tboundOnErrStart = tagRender + tmplBindingKey + \",\";\n\t\t\t\t\tboundOnErrEnd = \")\";\n\t\t\t\t}\n\t\t\t\tcode += (isGetVal\n\t\t\t\t\t? (isLinkExpr ? (onError ? \"try{\\n\" : \"\") + \"return \" : tagStart) + (useCnvt // Call _cnvt if there is a converter: {{cnvt: ... }} or {^{cnvt: ... }}\n\t\t\t\t\t\t? (useCnvt = undefined, useViews = hasCnvt = true, tagRender + (tagCtxFn\n\t\t\t\t\t\t\t? ((tmplBindings[tmplBindingKey - 1] = tagCtxFn), tmplBindingKey) // Store the compiled tagCtxFn in tmpl.bnds, and pass the key to convertVal()\n\t\t\t\t\t\t\t: \"{\" + tagCtx + \"}\") + \")\")\n\t\t\t\t\t\t: tagName === \">\"\n\t\t\t\t\t\t\t? (hasEncoder = true, \"h(\" + params[0] + \")\")\n\t\t\t\t\t\t\t: (getsVal = true, \"((v=\" + params[0] + ')!=null?v:' + (isLinkExpr ? 'null)' : '\"\")'))\n\t\t\t\t\t\t\t// Non strict equality so data-link=\"title{:expr}\" with expr=null/undefined removes title attribute\n\t\t\t\t\t)\n\t\t\t\t\t: (hasTag = true, \"\\n{view:view,content:false,tmpl:\" // Add this tagCtx to the compiled code for the tagCtxs to be passed to renderTag()\n\t\t\t\t\t\t+ (content ? nestedTmpls.length : \"false\") + \",\" // For block tags, pass in the key (nestedTmpls.length) to the nested content template\n\t\t\t\t\t\t+ tagCtx + \"},\"));\n\n\t\t\t\tif (tagAndElses && !nextIsElse) {\n\t\t\t\t\t// This is a data-link expression or an inline tag without any elses, or the last {{else}} of an inline tag\n\t\t\t\t\t// We complete the code for returning the tagCtxs array\n\t\t\t\t\tcode = \"[\" + code.slice(0, -1) + \"]\";\n\t\t\t\t\ttagRender = 't(\"' + tagAndElses + '\",view,this,';\n\t\t\t\t\tif (isLinkExpr || pathBindings) {\n\t\t\t\t\t\t// This is a bound tag (data-link expression or inline bound tag {^{tag ...}}) so we store a compiled tagCtxs function in tmp.bnds\n\t\t\t\t\t\tcode = new Function(\"data,view,j,u\", \" // \" + tmplName + \" \" + tmplBindingKey + \" \" + tagAndElses + retStrOpen + code\n\t\t\t\t\t\t\t+ retStrClose);\n\t\t\t\t\t\tcode._er = onError;\n\t\t\t\t\t\tcode._tag = tagAndElses;\n\t\t\t\t\t\tif (pathBindings) {\n\t\t\t\t\t\t\tsetPaths(tmplBindings[tmplBindingKey - 1] = code, pathBindings);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcode._lr = lateRender;\n\t\t\t\t\t\tif (isLinkExpr) {\n\t\t\t\t\t\t\treturn code; // For a data-link expression we return the compiled tagCtxs function\n\t\t\t\t\t\t}\n\t\t\t\t\t\tboundOnErrStart = tagRender + tmplBindingKey + \",undefined,\";\n\t\t\t\t\t\tboundOnErrEnd = \")\";\n\t\t\t\t\t}\n\n\t\t\t\t\t// This is the last {{else}} for an inline tag.\n\t\t\t\t\t// For a bound tag, pass the tagCtxs fn lookup key to renderTag.\n\t\t\t\t\t// For an unbound tag, include the code directly for evaluating tagCtxs array\n\t\t\t\t\tcode = oldCode + tagStart + tagRender + (pathBindings && tmplBindingKey || code) + \")\";\n\t\t\t\t\tpathBindings = 0;\n\t\t\t\t\ttagAndElses = 0;\n\t\t\t\t}\n\t\t\t\tif (onError && !nextIsElse) {\n\t\t\t\t\tuseViews = true;\n\t\t\t\t\tcode += ';\\n}catch(e){ret' + (isLinkExpr ? \"urn \" : \"+=\") + boundOnErrStart + 'j._err(e,view,' + onError + ')' + boundOnErrEnd + ';}' + (isLinkExpr ? \"\" : 'ret=ret');\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t// Include only the var references that are needed in the code\n\tcode = \"// \" + tmplName\n\t\t+ (tmplOptions.debug ? \"\\ndebugger;\" : \"\")\n\t\t+ \"\\nvar v\"\n\t\t+ (hasTag ? \",t=j._tag\" : \"\")                // has tag\n\t\t+ (hasCnvt ? \",c=j._cnvt\" : \"\")              // converter\n\t\t+ (hasEncoder ? \",h=j._html\" : \"\")           // html converter\n\t\t+ (isLinkExpr\n\t\t\t\t? (node[8]  // late @... path?\n\t\t\t\t\t\t? \", ob\"\n\t\t\t\t\t\t: \"\"\n\t\t\t\t\t) + \";\\n\"\n\t\t\t\t: ',ret=\"\"')\n\t\t+ code\n\t\t+ (isLinkExpr ? \"\\n\" : \";\\nreturn ret;\");\n\n\ttry {\n\t\tcode = new Function(\"data,view,j,u\", code);\n\t} catch (e) {\n\t\tsyntaxError(\"Compiled template code:\\n\\n\" + code + '\\n: \"' + (e.message||e) + '\"');\n\t}\n\tif (tmpl) {\n\t\ttmpl.fn = code;\n\t\ttmpl.useViews = !!useViews;\n\t}\n\treturn code;\n}\n\n//==========\n// Utilities\n//==========\n\n// Merge objects, in particular contexts which inherit from parent contexts\nfunction extendCtx(context, parentContext) {\n\t// Return copy of parentContext, unless context is defined and is different, in which case return a new merged context\n\t// If neither context nor parentContext are defined, return undefined\n\treturn context && context !== parentContext\n\t\t? (parentContext\n\t\t\t? $extend($extend({}, parentContext), context)\n\t\t\t: context)\n\t\t: parentContext && $extend({}, parentContext);\n}\n\nfunction getTargetProps(source, tagCtx) {\n\t// this pointer is theMap - which has tagCtx.props too\n\t// arguments: tagCtx.args.\n\tvar key, prop,\n\t\tmap = tagCtx.map,\n\t\tpropsArr = map && map.propsArr;\n\n\tif (!propsArr) { // map.propsArr is the full array of {key:..., prop:...} objects\n\t\tpropsArr = [];\n\t\tif (typeof source === OBJECT || $isFunction(source)) {\n\t\t\tfor (key in source) {\n\t\t\t\tprop = source[key];\n\t\t\t\tif (key !== $expando && source.hasOwnProperty(key) && (!tagCtx.props.noFunctions || !$.isFunction(prop))) {\n\t\t\t\t\tpropsArr.push({key: key, prop: prop});\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (map) {\n\t\t\tmap.propsArr = map.options && propsArr; // If bound {^{props}} and not isRenderCall, store propsArr on map (map.options is defined only for bound, && !isRenderCall)\n\t\t}\n\t}\n\treturn getTargetSorted(propsArr, tagCtx); // Obtains map.tgt, by filtering, sorting and splicing the full propsArr\n}\n\nfunction getTargetSorted(value, tagCtx) {\n\t// getTgt\n\tvar mapped, start, end,\n\t\ttag = tagCtx.tag,\n\t\tprops = tagCtx.props,\n\t\tpropParams = tagCtx.params.props,\n\t\tfilter = props.filter,\n\t\tsort = props.sort,\n\t\tdirectSort = sort === true,\n\t\tstep = parseInt(props.step),\n\t\treverse = props.reverse ? -1 : 1;\n\n\tif (!$isArray(value)) {\n\t\treturn value;\n\t}\n\tif (directSort || sort && \"\" + sort === sort) {\n\t\t// Temporary mapped array holds objects with index and sort-value\n\t\tmapped = value.map(function(item, i) {\n\t\t\titem = directSort ? item : getPathObject(item, sort);\n\t\t\treturn {i: i, v: \"\" + item === item ? item.toLowerCase() : item};\n\t\t});\n\t\t// Sort mapped array\n\t\tmapped.sort(function(a, b) {\n\t\t\treturn a.v > b.v ? reverse : a.v < b.v ? -reverse : 0;\n\t\t});\n\t\t// Map to new array with resulting order\n\t\tvalue = mapped.map(function(item){\n\t\t\treturn value[item.i];\n\t\t});\n\t} else if ((sort || reverse < 0) && !tag.dataMap) {\n\t\tvalue = value.slice(); // Clone array first if not already a new array\n\t}\n\tif ($isFunction(sort)) {\n\t\tvalue = value.sort(function() { // Wrap the sort function to provide tagCtx as 'this' pointer\n\t\t\treturn sort.apply(tagCtx, arguments);\n\t\t});\n\t}\n\tif (reverse < 0 && (!sort || $isFunction(sort))) { // Reverse result if not already reversed in sort\n\t\tvalue = value.reverse();\n\t}\n\n\tif (value.filter && filter) { // IE8 does not support filter\n\t\tvalue = value.filter(filter, tagCtx);\n\t\tif (tagCtx.tag.onFilter) {\n\t\t\ttagCtx.tag.onFilter(tagCtx);\n\t\t}\n\t}\n\n\tif (propParams.sorted) {\n\t\tmapped = (sort || reverse < 0) ? value : value.slice();\n\t\tif (tag.sorted) {\n\t\t\t$.observable(tag.sorted).refresh(mapped); // Note that this might cause the start and end props to be modified - e.g. by pager tag control\n\t\t} else {\n\t\t\ttagCtx.map.sorted = mapped;\n\t\t}\n\t}\n\n\tstart = props.start; // Get current value - after possible  changes triggered by tag.sorted refresh() above\n\tend = props.end;\n\tif (propParams.start && start === undefined || propParams.end && end === undefined) {\n\t\tstart = end = 0;\n\t}\n\tif (!isNaN(start) || !isNaN(end)) { // start or end specified, but not the auto-create Number array scenario of {{for start=xxx end=yyy}}\n\t\tstart = +start || 0;\n\t\tend = end === undefined || end > value.length ? value.length : +end;\n//\t\tend = end === undefined ? value.length : +end;\n\t\tvalue = value.slice(start, end);\n\t}\n\tif (step > 1) {\n\t\tstart = 0;\n\t\tend = value.length;\n\t\tmapped = [];\n\t\tfor (; start<end; start+=step) {\n\t\t\tmapped.push(value[start]);\n\t\t}\n\t\tvalue = mapped;\n\t}\n\tif (propParams.paged && tag.paged) {\n\t\t$observable(tag.paged).refresh(value);\n\t}\n\n\treturn value;\n}\n\n/** Render the template as a string, using the specified data and helpers/context\n* $(\"#tmpl\").render()\n*\n* @param {any}        data\n* @param {hash}       [helpersOrContext]\n* @param {boolean}    [noIteration]\n* @returns {string}   rendered template\n*/\nfunction $fnRender(data, context, noIteration) {\n\tvar tmplElem = this.jquery && (this[0] || error('Unknown template')), // Targeted element not found for jQuery template selector such as \"#myTmpl\"\n\t\ttmpl = tmplElem.getAttribute(tmplAttr);\n\n\treturn renderContent.call(tmpl && $.data(tmplElem)[jsvTmpl] || $templates(tmplElem),\n\t\tdata, context, noIteration);\n}\n\n//========================== Register converters ==========================\n\nfunction getCharEntity(ch) {\n\t// Get character entity for HTML, Attribute and optional data encoding\n\treturn charEntities[ch] || (charEntities[ch] = \"&#\" + ch.charCodeAt(0) + \";\");\n}\n\nfunction getCharFromEntity(match, token) {\n\t// Get character from HTML entity, for optional data unencoding\n\treturn charsFromEntities[token] || \"\";\n}\n\nfunction htmlEncode(text) {\n\t// HTML encode: Replace < > & ' \" ` etc. by corresponding entities.\n\treturn text != undefined ? rIsHtml.test(text) && (\"\" + text).replace(rHtmlEncode, getCharEntity) || text : \"\";\n}\n\nfunction dataEncode(text) {\n\t// Encode just < > and & - intended for 'safe data' along with {{:}} rather than {{>}}\n  return \"\" + text === text ? text.replace(rDataEncode, getCharEntity) : text;\n}\n\nfunction dataUnencode(text) {\n  // Unencode just < > and & - intended for 'safe data' along with {{:}} rather than {{>}}\n  return \"\" + text === text ? text.replace(rDataUnencode, getCharFromEntity) : text;\n}\n\n//========================== Initialize ==========================\n\n$sub = $views.sub;\n$viewsSettings = $views.settings;\n\nif (!(jsr || $ && $.render)) {\n\t// JsRender not already loaded, or loaded without jQuery, and we are now moving from jsrender namespace to jQuery namepace\n\tfor (jsvStoreName in jsvStores) {\n\t\tregisterStore(jsvStoreName, jsvStores[jsvStoreName]);\n\t}\n\n\t$converters = $views.converters;\n\t$helpers = $views.helpers;\n\t$tags = $views.tags;\n\n\t$sub._tg.prototype = {\n\t\tbaseApply: baseApply,\n\t\tcvtArgs: convertArgs,\n\t\tbndArgs: convertBoundArgs,\n\t\tctxPrm: contextParameter\n\t};\n\n\ttopView = $sub.topView = new View();\n\n\t//BROWSER-SPECIFIC CODE\n\tif ($) {\n\n\t\t////////////////////////////////////////////////////////////////////////////////////////////////\n\t\t// jQuery (= $) is loaded\n\n\t\t$.fn.render = $fnRender;\n\t\t$expando = $.expando;\n\t\tif ($.observable) {\n\t\t\tif (versionNumber !== (versionNumber = $.views.jsviews)) {\n\t\t\t\t// Different version of jsRender was loaded\n\t\t\t\tthrow \"JsObservable requires JsRender \" + versionNumber;\n\t\t\t}\n\t\t\t$extend($sub, $.views.sub); // jquery.observable.js was loaded before jsrender.js\n\t\t\t$views.map = $.views.map;\n\t\t}\n\n\t} else {\n\t\t////////////////////////////////////////////////////////////////////////////////////////////////\n\t\t// jQuery is not loaded.\n\n\t\t$ = {};\n\n\t\tif (setGlobals) {\n\t\t\tglobal.jsrender = $; // We are loading jsrender.js from a script element, not AMD or CommonJS, so set global\n\t\t}\n\n\t\t// Error warning if jsrender.js is used as template engine on Node.js (e.g. Express or Hapi...)\n\t\t// Use jsrender-node.js instead...\n\t\t$.renderFile = $.__express = $.compile = function() { throw \"Node.js: use npm jsrender, or jsrender-node.js\"; };\n\n\t\t//END BROWSER-SPECIFIC CODE\n\t\t$.isFunction = function(ob) {\n\t\t\treturn typeof ob === \"function\";\n\t\t};\n\n\t\t$.isArray = Array.isArray || function(obj) {\n\t\t\treturn ({}.toString).call(obj) === \"[object Array]\";\n\t\t};\n\n\t\t$sub._jq = function(jq) { // private method to move from JsRender APIs from jsrender namespace to jQuery namespace\n\t\t\tif (jq !== $) {\n\t\t\t\t$extend(jq, $); // map over from jsrender namespace to jQuery namespace\n\t\t\t\t$ = jq;\n\t\t\t\t$.fn.render = $fnRender;\n\t\t\t\tdelete $.jsrender;\n\t\t\t\t$expando = $.expando;\n\t\t\t}\n\t\t};\n\n\t\t$.jsrender = versionNumber;\n\t}\n\t$subSettings = $sub.settings;\n\t$subSettings.allowCode = false;\n\t$isFunction = $.isFunction;\n\t$.render = $render;\n\t$.views = $views;\n\t$.templates = $templates = $views.templates;\n\n\tfor (setting in $subSettings) {\n\t\taddSetting(setting);\n\t}\n\n\t/**\n\t* $.views.settings.debugMode(true)\n\t* @param {boolean}  debugMode\n\t* @returns {Settings}\n\t*\n\t* debugMode = $.views.settings.debugMode()\n\t* @returns {boolean}\n\t*/\n\t($viewsSettings.debugMode = function(debugMode) {\n\t\treturn debugMode === undefined\n\t\t\t? $subSettings.debugMode\n\t\t\t: (\n\t\t\t\t$subSettings.debugMode = debugMode,\n\t\t\t\t$subSettings.onError = debugMode + \"\" === debugMode\n\t\t\t\t\t? function() { return debugMode; }\n\t\t\t\t\t: $isFunction(debugMode)\n\t\t\t\t\t\t? debugMode\n\t\t\t\t\t\t: undefined,\n\t\t\t\t$viewsSettings);\n\t})(false); // jshint ignore:line\n\n\t$subSettingsAdvanced = $subSettings.advanced = {\n\t\tuseViews: false,\n\t\t_jsv: false // For global access to JsViews store\n\t};\n\n\t//========================== Register tags ==========================\n\n\t$tags({\n\t\t\"if\": {\n\t\t\trender: function(val) {\n\t\t\t\t// This function is called once for {{if}} and once for each {{else}}.\n\t\t\t\t// We will use the tag.rendering object for carrying rendering state across the calls.\n\t\t\t\t// If not done (a previous block has not been rendered), look at expression for this block and render the block if expression is truthy\n\t\t\t\t// Otherwise return \"\"\n\t\t\t\tvar self = this,\n\t\t\t\t\ttagCtx = self.tagCtx,\n\t\t\t\t\tret = (self.rendering.done || !val && (tagCtx.args.length || !tagCtx.index))\n\t\t\t\t\t\t? \"\"\n\t\t\t\t\t\t: (self.rendering.done = true,\n\t\t\t\t\t\t\tself.selected = tagCtx.index,\n\t\t\t\t\t\t\tundefined); // Test is satisfied, so render content on current context\n\t\t\t\treturn ret;\n\t\t\t},\n\t\t\tcontentCtx: true, // Inherit parent view data context\n\t\t\tflow: true\n\t\t},\n\t\t\"for\": {\n\t\t\tsortDataMap: dataMap(getTargetSorted),\n\t\t\tinit: function(val, cloned) {\n\t\t\t\tvar l, tagCtx, paramsProps, sort,\n\t\t\t\t\tself = this,\n\t\t\t\t\ttagCtxs = self.tagCtxs;\n\t\t\t\tl = tagCtxs.length;\n\t\t\t\twhile (l--) {\n\t\t\t\t\ttagCtx = tagCtxs[l];\n\t\t\t\t\tparamsProps = tagCtx.params.props;\n\t\t\t\t\ttagCtx.argDefault = tagCtx.props.end === undefined || tagCtx.args.length > 0; // Default to #data except for auto-create range scenario {{for start=xxx end=yyy step=zzz}}\n\n\t\t\t\t\tif (tagCtx.argDefault !== false && $isArray(tagCtx.args[0])\n\t\t\t\t\t\t&& (paramsProps.sort !== undefined || paramsProps.start || paramsProps.end || paramsProps.step || paramsProps.filter || paramsProps.reverse)) {\n\t\t\t\t\t\ttagCtx.props.dataMap = self.sortDataMap;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t},\n\t\t\trender: function(val) {\n\t\t\t\t// This function is called once for {{for}} and once for each {{else}}.\n\t\t\t\t// We will use the tag.rendering object for carrying rendering state across the calls.\n\t\t\t\tvar value, filter, srtField, isArray, i, sorted, end, step,\n\t\t\t\t\tself = this,\n\t\t\t\t\ttagCtx = self.tagCtx,\n\t\t\t\t\trange = tagCtx.argDefault === false,\n\t\t\t\t\tprops = tagCtx.props,\n\t\t\t\t\titerate =  range || tagCtx.args.length, // Not final else and not auto-create range\n\t\t\t\t\tresult = \"\",\n\t\t\t\t\tdone = 0;\n\n\t\t\t\tif (!self.rendering.done) {\n\t\t\t\t\tvalue = iterate ? val : tagCtx.view.data; // For the final else, defaults to current data without iteration.\n\n\t\t\t\t\tif (range) {\n\t\t\t\t\t\trange = props.reverse ? \"unshift\" : \"push\";\n\t\t\t\t\t\tend = +props.end;\n\t\t\t\t\t\tstep = +props.step || 1;\n\t\t\t\t\t\tvalue = []; // auto-create integer array scenario of {{for start=xxx end=yyy}}\n\t\t\t\t\t\tfor (i = +props.start || 0; (end - i) * step > 0; i += step) {\n\t\t\t\t\t\t\tvalue[range](i);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (value !== undefined) {\n\t\t\t\t\t\tisArray = $isArray(value);\n\t\t\t\t\t\tresult += tagCtx.render(value, !iterate || props.noIteration);\n\t\t\t\t\t\t// Iterates if data is an array, except on final else - or if noIteration property\n\t\t\t\t\t\t// set to true. (Use {{include}} to compose templates without array iteration)\n\t\t\t\t\t\tdone += isArray ? value.length : 1;\n\t\t\t\t\t}\n\t\t\t\t\tif (self.rendering.done = done) {\n\t\t\t\t\t\tself.selected = tagCtx.index;\n\t\t\t\t\t}\n\t\t\t\t\t// If nothing was rendered we will look at the next {{else}}. Otherwise, we are done.\n\t\t\t\t}\n\t\t\t\treturn result;\n\t\t\t},\n\t\t\tflow: true\n\t\t},\n\t\tprops: {\n\t\t\tbaseTag: \"for\",\n\t\t\tdataMap: dataMap(getTargetProps),\n\t\t\tinit: noop, // Don't execute the base init() of the \"for\" tag\n\t\t\tflow: true\n\t\t},\n\t\tinclude: {\n\t\t\tflow: true\n\t\t},\n\t\t\"*\": {\n\t\t\t// {{* code... }} - Ignored if template.allowCode and $.views.settings.allowCode are false. Otherwise include code in compiled template\n\t\t\trender: retVal,\n\t\t\tflow: true\n\t\t},\n\t\t\":*\": {\n\t\t\t// {{:* returnedExpression }} - Ignored if template.allowCode and $.views.settings.allowCode are false. Otherwise include code in compiled template\n\t\t\trender: retVal,\n\t\t\tflow: true\n\t\t},\n\t\tdbg: $helpers.dbg = $converters.dbg = dbgBreak // Register {{dbg/}}, {{dbg:...}} and ~dbg() to throw and catch, as breakpoints for debugging.\n\t});\n\n\t$converters({\n\t\thtml: htmlEncode,\n\t\tattr: htmlEncode, // Includes > encoding since rConvertMarkers in JsViews does not skip > characters in attribute strings\n\t\tencode: dataEncode,\n\t\tunencode: dataUnencode, // Includes > encoding since rConvertMarkers in JsViews does not skip > characters in attribute strings\n\t\turl: function(text) {\n\t\t\t// URL encoding helper.\n\t\t\treturn text != undefined ? encodeURI(\"\" + text) : text === null ? text : \"\"; // null returns null, e.g. to remove attribute. undefined returns \"\"\n\t\t}\n\t});\n}\n//========================== Define default delimiters ==========================\n$subSettings = $sub.settings;\n$isArray = ($||jsr).isArray;\n$viewsSettings.delimiters(\"{{\", \"}}\", \"^\");\n\nif (jsrToJq) { // Moving from jsrender namespace to jQuery namepace - copy over the stored items (templates, converters, helpers...)\n\tjsr.views.sub._jq($);\n}\n\n//<<<<<<<<<<<<<<<<<<<<<<<<<<<<<< JsObservable >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>\n/* JsObservable:\n * See https://www.jsviews.com/#jsobservable and http://github.com/borismoore/jsviews\n * Copyright 2019, Boris Moore\n * Released under the MIT License.\n */\n\n//========================== Top-level vars ==========================\n\n$views = $.views;\n$sub = $views.sub;\n$isFunction = $.isFunction;\n$isArray = $.isArray;\n$expando = $.expando;\nif (!$.observe) {\n\n\tvar $eventSpecial = $.event.special,\n\t\tslice = [].slice,\n\t\tsplice = [].splice,\n\t\tconcat = [].concat,\n\t\tPARSEINT = parseInt,\n\t\trNotWhite = /\\S+/g,\n\t\trShallowPath = /^[^.[]*$/, // No '.' or '[' in path\n\t\tpropertyChangeStr = $sub.propChng = $sub.propChng || \"propertyChange\",// These two settings can be overridden on settings after loading\n\t\tarrayChangeStr = $sub.arrChng = $sub.arrChng || \"arrayChange\",        // jsRender, and prior to loading jquery.observable.js and/or JsViews\n\t\tcbBindingsStore = {},\n\t\tobserveStr = propertyChangeStr + \".observe\",\n\t\tobserveObjKey = 1,\n\t\tobserveCbKey = 1,\n\t\tobserveInnerCbKey = 1,\n\t\t$data = $.data,\n\t\tremove = {}, // flag for removeProperty\n\n\t//========================== Top-level functions ==========================\n\n\tgetCbKey = function(cb) {\n\t\treturn cb\n\t\t? (cb._cId = cb._cId || (\".obs\" + observeCbKey++))\n\t\t: \"\";\n\t},\n\n\tObjectObservable = function(ns, data) {\n\t\tthis._data = data;\n\t\tthis._ns = ns;\n\t\treturn this;\n\t},\n\n\tArrayObservable = function(ns, data) {\n\t\tthis._data = data;\n\t\tthis._ns = ns;\n\t\treturn this;\n\t},\n\n\twrapArray = function(data) {\n\t\treturn $isArray(data)\n\t\t\t? [data]\n\t\t\t: data;\n\t},\n\n\tdependsPaths = function(paths, root, callback) {\n\t\t// Process depends = ... paths to resolve objects, and recursively process functions.\n\t\tpaths = paths\n\t\t\t? $isArray(paths)\n\t\t\t\t? paths\n\t\t\t\t: [paths]\n\t\t\t: [];\n\n\t\tvar i, path, object, rt,\n\t\t\tnextObj = object = root,\n\t\t\tl = paths && paths.length,\n\t\t\tout = [];\n\n\t\tfor (i = 0; i < l; i++) {\n\t\t\tpath = paths[i];\n\t\t\tif ($isFunction(path)) { // path is a depends function, returning [path1, ...]\n\t\t\t\trt = root.tagName\n\t\t\t\t\t\t? root.linkCtx.data // root is tag instance. rt is current data context of tag\n\t\t\t\t\t\t: root; // rt = root = current data context of computed prop\n\t\t\t\tout = out.concat(dependsPaths(path.call(root, rt, callback), rt, callback));\n\t\t\t\tcontinue;\n\t\t\t} else if (\"\" + path !== path) {\n\t\t\t\troot = nextObj = path = (path === undefined ? null : path);\n\t\t\t\tif (nextObj !== object) {\n\t\t\t\t\tout.push(object = nextObj);\n\t\t\t\t}\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (nextObj !== object) {\n\t\t\t\tout.push(object = nextObj);\n\t\t\t}\n\t\t\tout.push(path);\n\t\t}\n\t\tif (out.length) {\n\t\t\t// Switch on allowArray, for depends paths, by passing {_ar: ...} objects to switch on allowArray then return to contextual allowArray value\n\t\t\tout.unshift({_ar: 1});\n\t\t\tout.push({_ar: -1});\n\t\t}\n\t\treturn out;\n\t},\n\n\tremoveCbBindings = function(cbBindings, cbBindingsId) {\n\t\t// If the cbBindings collection is empty we will remove it from the cbBindingsStore\n\t\tfor (var cb in cbBindings) {\n\t\t\treturn;\n\t\t}\n\t\tdelete cbBindingsStore[cbBindingsId]; // This binding collection is empty, so remove from store\n\t},\n\n\tonDataChange = function(ev, eventArgs) {\n\t\tfunction isOb(val) {\n\t\t\treturn typeof val === OBJECT && (paths[0] || !noArray && $isArray(val));\n\t\t}\n\n\t\tif (!(ev.data && ev.data.off)) {\n\t\t\t// Skip if !!ev.data.off: - a handler that has already been removed (maybe was on handler collection at call time - then removed by another handler)\n\t\t\tvar allPath, filter, parentObs,\n\t\t\t\toldValue = eventArgs.oldValue,\n\t\t\t\tvalue = eventArgs.value,\n\t\t\t\tctx = ev.data,\n\t\t\t\tobserveAll = ctx.observeAll,\n\t\t\t\tcb = ctx.cb,\n\t\t\t\tnoArray = ctx._arOk ? 0 : 1,\n\t\t\t\tpaths = ctx.paths,\n\t\t\t\tns = ctx.ns;\n\n\t\t\tif (ev.type === arrayChangeStr) {\n\t\t\t\t(cb.array || cb).call(ctx, ev, eventArgs); // If there is an arrayHandler expando on the regular handler, use it, otherwise use the regular handler for arrayChange events also - for example: $.observe(array, handler)\n\t\t\t\t// or observeAll() with an array in the graph. Note that on data-link bindings we ensure always to have an array handler - $.noop if none is specified e.g. on the data-linked tag.\n\t\t\t} else if (ctx.prop === eventArgs.path || ctx.prop === \"*\") {\n\t\t\t\tif (observeAll) {\n\t\t\t\t\tallPath = observeAll._path + \".\" + eventArgs.path;\n\t\t\t\t\tfilter = observeAll.filter;\n\t\t\t\t\tparentObs = [ev.target].concat(observeAll.parents());\n\n\t\t\t\t\tif (isOb(oldValue)) {\n\t\t\t\t\t\tobserve_apply(undefined, ns, [oldValue], paths, cb, true, filter, [parentObs], allPath); // unobserve\n\t\t\t\t\t}\n\t\t\t\t\tif (isOb(value)) {\n\t\t\t\t\t\tobserve_apply(undefined, ns, [value], paths, cb, undefined, filter, [parentObs], allPath);\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tif (isOb(oldValue)) { // oldValue is an object, so unobserve\n\t\t\t\t\t\tobserve_apply(noArray, ns, [oldValue], paths, cb, true); // unobserve. Observe array change events too if this change is not from an 'observeAndBind' tag binding, or is from a 'depends' path\n\t\t\t\t\t}\n\t\t\t\t\tif (isOb(value)) { // value is an object, so observe\n\t\t\t\t\t\tobserve_apply(noArray, ns, [value], paths, cb); // observe. Observe array change events too if this change is not from an 'observeAndBind' tag binding, or is from a 'depends' path\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tctx.cb(ev, eventArgs);\n\t\t\t}\n\t\t}\n\t},\n\n\tobserve_apply = function() {\n\t\t// $.observe(), but allowing you to include arrays within the arguments - which you want flattened.\n\t\tvar args = concat.apply([], arguments); // Flatten the arguments\n\t\treturn $observe.apply(args.shift(), args);\n\t},\n\n\t$observeAll = function(cb, filter, unobserve) {\n\t\tobserveAll(this._ns, this._data, cb, filter, [], \"root\", unobserve);\n\t},\n\n\t$unobserveAll = function(cb, filter) {\n\t\t$observeAll.call(this, cb, filter, true);\n\t},\n\n\tobserveAll = function(namespace, object, cb, filter, parentObs, allPath, unobserve, objMap) {\n\t\tfunction observeArrayItems(arr, unobs) {\n\t\t\tl = arr.length;\n\t\t\tnewAllPath = allPath + \"[]\";\n\t\t\twhile (l--) {\n\t\t\t\tfilterAndObserveAll(arr, l, unobs, 1);\n\t\t\t}\n\t\t}\n\n\t\tfunction filterAndObserveAll(obj, prop, unobs, nestedArray) {\n\t\t\tvar newObject, newParentObs;\n\t\t\tif (prop !== $expando && (newObject = $observable._fltr(newAllPath, obj[prop], nextParentObs, filter))) {\n\t\t\t\tnewParentObs = nextParentObs.slice();\n\t\t\t\tif (nestedArray && updatedTgt && newParentObs[0] !== updatedTgt) {\n\t\t\t\t\tnewParentObs.unshift(updatedTgt); // For array change events when observing an array which is not the root, need to add updated array to parentObs\n\t\t\t\t}\n\t\t\t\tobserveAll(namespace, newObject, cb, filter || (nestedArray ? undefined : 0), newParentObs, newAllPath, unobs, objMap);\n\t\t\t\t// If nested array, need to observe the array too - so set filter to undefined\n\t\t\t}\n\t\t}\n\n\t\tfunction wrappedCb(ev, eventArgs) {\n\t\t\t// This object is changing.\n\t\t\tallPath = ev.data.observeAll._path;\n\t\t\tupdatedTgt = ev.target;\n\t\t\tswitch (eventArgs.change) { // observeAll/unobserveAll on added or removed objects\n\t\t\t\tcase \"insert\":\n\t\t\t\t\tobserveArrayItems(eventArgs.items);\n\t\t\t\t\tbreak;\n\t\t\t\tcase \"remove\":\n\t\t\t\t\tobserveArrayItems(eventArgs.items, true); // unobserveAll on removed items\n\t\t\t\t\tbreak;\n\t\t\t\tcase \"set\":\n\t\t\t\t\tnewAllPath = allPath + \".\" + eventArgs.path;\n\t\t\t\t\tfilterAndObserveAll(eventArgs, \"oldValue\", true); // unobserve old value\n\t\t\t\t\tfilterAndObserveAll(eventArgs, \"value\"); // observe new value\n\t\t\t}\n\t\t\tupdatedTgt = undefined;\n\t\t\tcb.apply(this, arguments); // Observe this object (invoke the callback)\n\t\t}\n\t\twrappedCb._wrp = 1;\n\n\t\tvar l, isObject, newAllPath, nextParentObs, updatedTgt, obId,\n\t\t\tnotRemoving = !objMap || objMap.un || !unobserve; // true unless it is an observeAll call (not unobserveAll) and we are removing a listener (not adding one)\n\n\t\tif (object && typeof object === OBJECT) {\n\t\t\tnextParentObs = [object].concat(parentObs); // The parentObs chain for the next depth of observeAll\n\t\t\tisObject = $isArray(object) ? \"\" : \"*\";\n\t\t\tif (objMap && notRemoving && $.hasData(object) && objMap[obId = $data(object).obId]) {\n\t\t\t\tobjMap[obId]++;\n\t\t\t\treturn; // This object has already being observed/unobserved by this observeAll/unobserveAll call (must be a cyclic object graph) so skip, to avoid\n\t\t\t\t// stack overflow/multiple instances of listener. See jsviews/pull/305\n\t\t\t\t// NOTE - WE DO NOT support ObserveAll on data with cyclic graphs which include DUPLICATE REFERENCES TO ARRAY PROPERTIES - such as data.children = data.descendants = []\n\t\t\t}\n\t\t\tif (!objMap) {\n\t\t\t\tobjMap = {un: unobserve}; // Map object to register observed objects for this observeAll\n\t\t\t}\n\n\t\t\tif (cb) {\n\t\t\t\t// Observe this object or array - and also listen for changes to object graph, to add or remove observers from the modified object graph\n\t\t\t\tif (isObject || filter !== 0) {\n\t\t\t\t\t// If an object, observe the object. If an array, only add arrayChange binding if has filter or if filter is undefined (!== 0) - which\n\t\t\t\t\t// is the case for top-level calls or for nested array (array item of an array - e.g. member of 2-dimensional array).\n\t\t\t\t\t// For array properties lower in the tree, with no filter, filter is set to 0 in filterAndObserveAll, so no arrayChange binding here,\n\t\t\t\t\t// since they get arrayChange binding added during regular $.observe(array ...) binding.\n\t\t\t\t\twrappedCb._cId = getCbKey(cb); // Identify wrapped callback with unwrapped callback, so unobserveAll will\n\t\t\t\t\t\t\t\t\t\t\t\t\t// remove previous observeAll wrapped callback, if inner callback was the same;\n\t\t\t\t\tif (notRemoving) {\n\t\t\t\t\t\t$observe(namespace, object, isObject, wrappedCb, unobserve, filter, nextParentObs, allPath);\n\t\t\t\t\t\tobId = $data(object).obId;\n\t\t\t\t\t\tobjMap[obId] = (objMap[obId] || 0) + 1; // Register on map of objects observed/unobserved by this observeAll/unobserveAll call\n\t\t\t\t\t\t\t//- or remove from map if we are removing this object from observeAll call. (Avoid dups, for cyclic graphs)\n\t\t\t\t\t} else {\n\t\t\t\t\t\tif (--objMap[$data(object).obId]) {\n\t\t\t\t\t\t\t// Register on map of objects observed/unobserved by this observeAll/unobserveAll call\n\t\t\t\t\t\t\t//- or remove from map if we are removing this object from observeAll call. (Avoid dups, for cyclic graphs)\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t}\n\t\t\t\t\t\t$observe(namespace, object, isObject, wrappedCb, unobserve, filter, nextParentObs, allPath);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t// No callback. Just unobserve if unobserve === true.\n\t\t\t\tif (objMap) {\n\t\t\t\t\tobjMap[$data(object).obId] = 1; // Register on map of objects unobserved by this unobserveAll call. (Avoid dups, for cyclic graphs)\n\t\t\t\t}\n\t\t\t\t$observe(namespace, object, isObject, undefined, unobserve, filter, nextParentObs, allPath);\n\t\t\t}\n\n\t\t\tif (isObject) {\n\t\t\t\t// Continue stepping through object graph, observing object and arrays\n\t\t\t\t// To override filtering, pass in filter function, or replace $.observable._fltr\n\t\t\t\tfor (l in object) {\n\t\t\t\t\tnewAllPath = allPath + \".\" + l;\n\t\t\t\t\tfilterAndObserveAll(object, l, unobserve);\n\t\t\t\t}\n\t\t\t} else { // Observe items in Array\n\t\t\t\tobserveArrayItems(object, unobserve);\n\t\t\t}\n\t\t}\n\t},\n\n\tshallowFilter = function(path /*, object, parentObs*/) {\n\t\treturn rShallowPath.test(path); // No '.' and no '[' in path\n\t},\n\n\t$unobserve = function() {\n\t\t[].push.call(arguments, true); // Add true as additional final argument\n\t\treturn $observe.apply(undefined, arguments);\n\t};\n\n\t$observe = function() {\n\t\t// $.observe([namespace, ]root, [1 or more objects, path or path Array params...], callback[, contextCallback][, unobserve])\n\n\t\tfunction innerObserve() {\n\t\t\tvar p, parts, unobserve, callback, cbId, inId, data, contextCb, items, cbBindings,\n\t\t\t\tinnerCb, parentObs, allPath, filter, initNsArr, initNsArrLen, view, prop, events, el;\n\n\t\t\tfunction unobserveBinding(cb, binding) {\n\t\t\t\tvar object;\n\t\t\t\tfor (data in binding) {\n\t\t\t\t\tobject = binding[data];\n\t\t\t\t\tif ($isArray(object)) {\n\t\t\t\t\t\tbindArray(cb, object, unobserve, unobserve);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tobserveOnOff(cb, object, undefined, ns, \"\");\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tfunction observeOnOff(cb, object, fullPath, namespace, pathStr, isArrayBinding, off) {\n\t\t\t\tvar j, evData,\n\t\t\t\t\tboundObOrArr = wrapArray(object),\n\t\t\t\t\tprntObs = parentObs,\n\t\t\t\t\tallPth = allPath;\n\n\t\t\t\tnamespace = initialNs ? namespace + \".\" + initialNs : namespace;\n\n\t\t\t\tif (!unobserve && (off || isArrayBinding)) {\n\t\t\t\t\tevents = $._data(object).events;\n\t\t\t\t\tevents = events && events[isArrayBinding ? arrayChangeStr : propertyChangeStr];\n\t\t\t\t\tel = events && events.length;\n\t\t\t\t\twhile (el--) { // Skip duplicates\n\t\t\t\t\t\tdata = events[el] && events[el].data;\n\t\t\t\t\t\tif (data && (off && data.ns !== initialNs\n\t\t\t\t\t\t\t// When observing, don't unbind dups unless they have the same namespace\n\t\t\t\t\t\t\t|| !off && data.ns === initialNs && data.cb && data.cb._cId === cb._cId && (!cb._wrp || data.cb._wrp)))\n\t\t\t\t\t\t\t// When observing and doing array binding, don't bind dups if they have the same namespace (Dups can happen e.g. with {^{for people ^~foo=people}})\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (unobserve || off) {\n\t\t\t\t\t$(boundObOrArr).off(namespace, onDataChange);\n\t\t\t\t} else {\n\t\t\t\t\tevData = isArrayBinding ? {}\n\t\t\t\t\t\t: {\n\t\t\t\t\t\t\tfullPath: fullPath,\n\t\t\t\t\t\t\tpaths: pathStr ? [pathStr] : [],\n\t\t\t\t\t\t\tprop: prop,\n\t\t\t\t\t\t\t_arOk: allowArray\n\t\t\t\t\t\t};\n\t\t\t\t\tevData.ns = initialNs;\n\t\t\t\t\tevData.cb = cb;\n\n\t\t\t\t\tif (allPath) {\n\t\t\t\t\t\t// This is an observeAll call\n\t\t\t\t\t\tevData.observeAll = {\n\t\t\t\t\t\t\t_path: allPth,\n\t\t\t\t\t\t\tpath: function() { // Step through path and parentObs parent chain, replacing '[]' by '[n]' based on current index of objects in parent arrays.\n\t\t\t\t\t\t\t\tj = prntObs.length;\n\t\t\t\t\t\t\t\treturn allPth.replace(/[[.]/g, function(all) {\n\t\t\t\t\t\t\t\t\tj--;\n\t\t\t\t\t\t\t\t\treturn all === \"[\"\n\t\t\t\t\t\t\t\t\t\t? \"[\" + $.inArray(prntObs[j - 1], prntObs[j])\n\t\t\t\t\t\t\t\t\t\t: \".\";\n\t\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tparents: function() {\n\t\t\t\t\t\t\t\treturn prntObs; // The chain of parents between the modified object and the root object used in the observeAll() call\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tfilter: filter\n\t\t\t\t\t\t};\n\t\t\t\t\t}\n\t\t\t\t\t$(boundObOrArr).on(namespace, null, evData, onDataChange);\n\n\t\t\t\t\tif (cbBindings) {\n\t\t\t\t\t\t// Add object to cbBindings\n\t\t\t\t\t\tcbBindings[$data(object).obId || $data(object, \"obId\", observeObjKey++)] = object;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tfunction bindArray(cb, arr, unbind, isArray, relPath) {\n\t\t\t\tif (allowArray) {\n\t\t\t\t\t// allowArray is 1 if this is a call to observe that does not come from observeAndBind (tag binding), or is from a 'depends' path,\n\t\t\t\t\t// so we allow arrayChange binding. Otherwise allowArray is zero.\n\t\t\t\t\tvar object,\n\t\t\t\t\t\tprevAllPath = allPath;\n\n\t\t\t\t\tobject = arr;\n\t\t\t\t\tif (relPath) {\n\t\t\t\t\t\tobject = arr[relPath];\n\t\t\t\t\t\tallPath += \".\" + relPath;\n\t\t\t\t\t}\n\t\t\t\t\tif (filter && object) {\n\t\t\t\t\t\tobject = $observable._fltr(allPath, object, relPath ? [arr].concat(parentObs) : parentObs, filter);\n\t\t\t\t\t}\n\t\t\t\t\tif (object && (isArray || $isArray(object))) {\n\t\t\t\t\t\tobserveOnOff(cb, object, undefined, arrayChangeStr + \".observe\" + getCbKey(cb), undefined, true, unbind);\n\t\t\t\t\t}\n\t\t\t\t\tallPath = prevAllPath;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tfunction observeObjects(paths) {\n\n\t\t\t\tfunction observeObjectPaths(object, pths, callback, contextCb) {\n\n\t\t\t\t\tfunction getInnerCb(exprOb) {\n\t\t\t\t\t\texprOb.ob = contextCb(exprOb, object); // Initialize object\n\t\t\t\t\t\treturn exprOb.cb = function(ev, eventArgs) {\n\t\t\t\t\t\t\t// The innerCb used for updating a computed in a compiled expression (setting the new instance as exprOb.ob, unobserving the previous object,\n\t\t\t\t\t\t\t// and observing the new one), then calling the outerCB - i.e. the handler for the whole compiled expression.\n\t\t\t\t\t\t\t// Initialized exprOb.ob to the current object.\n\t\t\t\t\t\t\t// Uses the contextCb callback to execute the compiled exprOb template in the context of the view/data etc. to get the returned value, typically an object or array.\n\t\t\t\t\t\t\t// If it is an array, registers array binding\n\t\t\t\t\t\t\t// Note: For jsviews/issues/292 ctxCb will need var ctxCb = contextCb || function(exprOb, origRt) {return exprOb._cpfn(origRt);};\n\t\t\t\t\t\t\tvar obj = exprOb.ob, // The old object\n\t\t\t\t\t\t\t\tsub = exprOb.sb,\n\t\t\t\t\t\t\t\tnewObj = contextCb(exprOb, object);\n\n\t\t\t\t\t\t\tif (newObj !== obj) {\n\t\t\t\t\t\t\t\tif (typeof obj === OBJECT) {\n\t\t\t\t\t\t\t\t\tbindArray(callback, obj, true);\n\t\t\t\t\t\t\t\t\tif (sub || allowArray && $isArray(obj)) {\n\t\t\t\t\t\t\t\t\t\tinnerObserve([obj], sub, callback, contextCb, true); // unobserve on the old object\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\texprOb.ob = newObj;\n\t\t\t\t\t\t\t\t// Put the updated object instance onto the exprOb in the paths array, so subsequent string paths are relative to this object\n\t\t\t\t\t\t\t\tif (typeof newObj === OBJECT) {\n\t\t\t\t\t\t\t\t\tbindArray(callback, newObj);\n\t\t\t\t\t\t\t\t\tif (sub || allowArray && $isArray(newObj)) { // observe on new object\n\t\t\t\t\t\t\t\t\t\tinnerObserve([newObj], sub, callback, contextCb);\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t// Call the outerCb - to execute the compiled expression that this computed is part of\n\t\t\t\t\t\t\tcallback(ev, eventArgs);\n\t\t\t\t\t\t};\n\t\t\t\t\t}\n\n\t\t\t\t\tfunction observePath(object, prts) { // Step through the path parts \"this.is^some.path\" and observe changes (on the leaf, or down to the bound depth)\n\n\t\t\t\t\t\tfunction obArrAddRemove(ev, eventArgs) {\n\t\t\t\t\t\t\t// If a \"[].*\" or \"[].prop\" wild card path (for observing properties of array items) we need to observe or unobserve added or removed items\n\t\t\t\t\t\t\tvar l;\n\t\t\t\t\t\t\tif (eventArgs.change === \"insert\" || (unobserve = eventArgs.change === \"remove\")) {\n\t\t\t\t\t\t\t\tl = eventArgs.items.length;\n\t\t\t\t\t\t\t\twhile (l--) {\n\t\t\t\t\t\t\t\t\tobservePath(eventArgs.items[l], prts.slice());\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tunobserve = false;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t//prts = $isArray(prts) ?  prts : [prts];\n\t\t\t\t\t\tif (callback) {\n\t\t\t\t\t\t\tobArrAddRemove._cId = getCbKey(callback); // Identify wrapped callback with unwrapped callback, so unobserveAll will\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// remove previous observeAll wrapped callback, if inner callback was the same;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tvar arrIndex, skip, dep, obArr, prt,\n\t\t\t\t\t\t\tobj = object;\n\t\t\t\t\t\tif (object && object._cxp) {\n\t\t\t\t\t\t\treturn observeObjectPaths(object[0], [object[1]], callback, contextCb);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\twhile ((prop = prts.shift()) !== undefined) {\n\t\t\t\t\t\t\tif (obj && typeof obj === OBJECT && \"\" + prop === prop) {\n\t\t\t\t\t\t\t\tif (prop === \"\") {\n\t\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tif ((prts.length < depth + 1) && !obj.nodeType) {\n\t\t\t\t\t\t\t\t\t// Add observer for each token in path starting at depth, and on to the leaf\n\t\t\t\t\t\t\t\t\tif (!unobserve && (events = $._data(obj).events)) {\n\t\t\t\t\t\t\t\t\t\tevents = events && events[propertyChangeStr];\n\t\t\t\t\t\t\t\t\t\tel = events && events.length;\n\t\t\t\t\t\t\t\t\t\tskip = 0;\n\t\t\t\t\t\t\t\t\t\twhile (el--) { // Skip duplicates\n\t\t\t\t\t\t\t\t\t\t\tdata = events[el].data;\n\t\t\t\t\t\t\t\t\t\t\tif (data\n\t\t\t\t\t\t\t\t\t\t\t\t&& data.ns === initialNs\n\t\t\t\t\t\t\t\t\t\t\t\t&& data.cb._cId === callback._cId\n\t\t\t\t\t\t\t\t\t\t\t\t&& data.cb._inId === callback._inId\n\t\t\t\t\t\t\t\t\t\t\t\t&& (data.prop === prop || data.prop === \"*\" || data.prop === \"**\")) {\n\t\t\t\t\t\t\t\t\t\t\t\tif (prt = prts.join(\".\")) {\n\t\t\t\t\t\t\t\t\t\t\t\t\tdata.paths.push(prt); // We will skip this binding, but if it is not a leaf binding,\n\t\t\t\t\t\t\t\t\t\t\t\t\t// need to keep bindings for rest of path, ready for if the obj gets swapped.\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\tskip++;\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\tif (skip) {\n\t\t\t\t\t\t\t\t\t\t\t// Duplicate binding(s) found, so move on\n\t\t\t\t\t\t\t\t\t\t\tobj = obj[prop];\n\t\t\t\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\tif (prop === \"*\" || prop === \"**\") { // \"*\" => all properties. \"**\" => all properties and sub-properties (i.e. deep observeAll behavior)\n\t\t\t\t\t\t\t\t\t\tif (!unobserve && events && events.length) {\n\t\t\t\t\t\t\t\t\t\t\t// Remove existing bindings, since they will be duplicates with \"*\" or \"**\"\n\t\t\t\t\t\t\t\t\t\t\tobserveOnOff(callback, obj, path, ns, \"\", false, true);\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\tif (prop === \"*\") {\n\t\t\t\t\t\t\t\t\t\t\tobserveOnOff(callback, obj, path, ns, \"\"); // observe the object for any property change\n\t\t\t\t\t\t\t\t\t\t\tfor (prt in obj) {\n\t\t\t\t\t\t\t\t\t\t\t\t// observing \"*\": So (in addition to listening to prop change, above) listen to arraychange on props of type array\n\t\t\t\t\t\t\t\t\t\t\t\tif (prt !== $expando) {\n\t\t\t\t\t\t\t\t\t\t\t\t\tbindArray(callback, obj, unobserve, undefined, prt);\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\t\t\t$.observable(initialNs, obj)[(unobserve ? \"un\" : \"\") + \"observeAll\"](callback); // observe or unobserve the object for any property change\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t} else if (prop == \"[]\") {  // \"[].*\" or \"[].prop\" wild card path, for observing properties of array items\n\t\t\t\t\t\t\t\t\t\tif ($isArray(obj)) {\n\t\t\t\t\t\t\t\t\t\t\tif (unobserve) {\n\t\t\t\t\t\t\t\t\t\t\t\tobserveOnOff(callback, obj, path, arrayChangeStr + getCbKey(callback), undefined, unobserve, unobserve);\n\t\t\t\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\t\t\t\t$observe(initialNs, obj, obArrAddRemove, unobserve); // observe or unobserve added or removed items\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t} else if (prop) {\n\t\t\t\t\t\t\t\t\t\tobserveOnOff(callback, obj, path, ns + \".p_\" + prop, prts.join(\"^\")); // By using \"^\" rather than \".\" we ensure that deep binding will be used on newly inserted object graphs\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tif (allPath) {\n\t\t\t\t\t\t\t\t\tallPath += \".\" + prop;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tif (prop === \"[]\") {\n\t\t\t\t\t\t\t\t\tif ($isArray(obj)) {\n\t\t\t\t\t\t\t\t\t\tobArr = obj;\n\t\t\t\t\t\t\t\t\t\tarrIndex = obj.length;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\twhile (arrIndex--) {\n\t\t\t\t\t\t\t\t\t\tobj = obArr[arrIndex];\n\t\t\t\t\t\t\t\t\t\tobservePath(obj, prts.slice());\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tprop = obj[prop];\n\t\t\t\t\t\t\t\tif (!prts[0]) {\n\t\t\t\t\t\t\t\t\tbindArray(callback, prop, unobserve); // [un]observe(object, \"arrayProperty\") observes array changes on property of type array\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif ($isFunction(prop)) {\n\t\t\t\t\t\t\t\tif (dep = prop.depends) {\n\t\t\t\t\t\t\t\t\t// This is a computed observable. We will observe any declared dependencies.\n\t\t\t\t\t\t\t\t\tif (obj._vw && obj._ocp) {\n\t\t\t\t\t\t\t\t\t\t// Observable contextual parameter, so context was ocp object. Now move context to view.data for dependencies\n\t\t\t\t\t\t\t\t\t\tobj = obj._vw; // storeView or tag (scope of contextual parameter)\n\t\t\t\t\t\t\t\t\t\tif (obj._tgId) {\n\t\t\t\t\t\t\t\t\t\t\t// Is a tag, so get view\n\t\t\t\t\t\t\t\t\t\t\tobj = obj.tagCtx.view;\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\tobj = obj.data; // view.data\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\tobserveObjects(concat.apply([], [[obj], dependsPaths(dep, obj, callback)]));\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tobj = prop;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tvar i, path,\n\t\t\t\t\t\tdepth = 0,\n\t\t\t\t\t\tl = pths.length;\n\t\t\t\t\tif (object && !contextCb && ((view = object._is === \"view\") || object._is === \"tag\")) {\n\t\t\t\t\t\tcontextCb = $sub._gccb(view ? object : object.tagCtx.contentView);\n\t\t\t\t\t\tif (callback && !unobserve) {\n\t\t\t\t\t\t\t(function() {\n\t\t\t\t\t\t\t\tvar ob = object,\n\t\t\t\t\t\t\t\t\tcb = callback;\n\t\t\t\t\t\t\t\tcallback = function(ev, eventArgs) {\n\t\t\t\t\t\t\t\t\t// Wrapped callback so this pointer is tag or view\n\t\t\t\t\t\t\t\t\tcb.call(ob, ev, eventArgs);\n\t\t\t\t\t\t\t\t};\n\t\t\t\t\t\t\t\tcallback._cId = cb._cId;\n\t\t\t\t\t\t\t\tcallback._inId = cb._inId;\n\t\t\t\t\t\t\t})();\n\t\t\t\t\t\t}\n\t\t\t\t\t\tobject = view ? object.data : object;\n\t\t\t\t\t}\n\t\t\t\t\tif (!pths[0]) {\n\t\t\t\t\t\tif ($isArray(object)) {\n\t\t\t\t\t\t\tbindArray(callback, object, unobserve, true); // observe(array, handler)\n\t\t\t\t\t\t} else if (unobserve) {\n\t\t\t\t\t\t\tobserveOnOff(callback, object, undefined, ns, \"\"); // unobserve(objectOrArray[, handler])\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tfor (i = 0; i < l; i++) { // Step through objects and paths\n\t\t\t\t\t\tpath = pths[i];\n\t\t\t\t\t\tif (path === \"\") {\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (path && path._ar) {\n\t\t\t\t\t\t\tallowArray += path._ar; // Switch on allowArray for depends paths, and off, afterwards.\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (\"\" + path === path) {\n\t\t\t\t\t\t\tparts = path.split(\"^\");\n\t\t\t\t\t\t\tif (parts[1]) {\n\t\t\t\t\t\t\t\t// We bind the leaf, plus additional nodes based on depth.\n\t\t\t\t\t\t\t\t// \"a.b.c^d.e\" is depth 2, so listens to changes of e, plus changes of d and of c\n\t\t\t\t\t\t\t\tdepth = parts[0].split(\".\").length;\n\t\t\t\t\t\t\t\tpath = parts.join(\".\");\n\t\t\t\t\t\t\t\tdepth = path.split(\".\").length - depth;\n\t\t\t\t\t\t\t\t// if more than one ^ in the path, the first one determines depth\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif (contextCb && (items = contextCb(path, object, depth))) {\n\t\t\t\t\t\t\t\t//object, paths\n\t\t\t\t\t\t\t\tif (items.length) {\n\t\t\t\t\t\t\t\t\tvar ob = items[0],\n\t\t\t\t\t\t\t\t\t\tpth = items[1];\n\t\t\t\t\t\t\t\t\tif (ob && ob._cxp) { // contextual parameter\n\t\t\t\t\t\t\t\t\t\tpth = ob[1];\n\t\t\t\t\t\t\t\t\t\tob = ob[0];\n\t\t\t\t\t\t\t\t\t\tif (ob._is === \"view\") {\n\t\t\t\t\t\t\t\t\t\t\tobserveObjectPaths(ob, [pth], callback); // Setting contextCb to undefined, to use passed in view for new contextCb\n\t\t\t\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\tif (pth + \"\" === pth) {\n\t\t\t\t\t\t\t\t\t\tobservePath(ob, pth.split(\".\"));\n\t\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\t\tobserveObjectPaths(items.shift(), items, callback, contextCb);\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tobservePath(object, path.split(\".\"));\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else if (!$isFunction(path) && path && path._cpfn) {\n\t\t\t\t\t\t\t// Path is an exprOb returned by a computed property - helper/data function (compiled expr function).\n\t\t\t\t\t\t\t// Get innerCb for updating the object\n\t\t\t\t\t\t\tinnerCb = unobserve ? path.cb : getInnerCb(path);\n\t\t\t\t\t\t\t// innerCb._ctx = callback._ctx; Could pass context (e.g. linkCtx) for use in a depends = function() {} call, so depends is different for different linkCtx's\n\t\t\t\t\t\t\tinnerCb._cId = callback._cId;\n\t\t\t\t\t\t\t// Set the same cbBindingsStore key as for callback, so when callback is disposed, disposal of innerCb happens too.\n\t\t\t\t\t\t\tinnerCb._inId = innerCb._inId || \".obIn\" + observeInnerCbKey++;\n\t\t\t\t\t\t\tif (path.bnd || path.prm && path.prm.length || !path.sb) {\n\t\t\t\t\t\t\t\t// If the exprOb is bound e.g. foo()^sub.path, or has parameters e.g. foo(bar) or is a leaf object (so no sub path) e.g. foo()\n\t\t\t\t\t\t\t\t// then observe changes on the object, or its parameters and sub-path\n\t\t\t\t\t\t\t\tinnerObserve([object], path.path, (path.prm.length ? [path.root||object] : []), path.prm, innerCb, contextCb, unobserve);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif (path.sb) { // Has a subPath\n\t\t\t\t\t\t\t\t// Observe changes on the sub-path\n\t\t\t\t\t\t\t\tif (path.sb.prm) {\n\t\t\t\t\t\t\t\t\tpath.sb.root = object;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t// Set current object on exprOb.ob\n\t\t\t\t\t\t\t\tobserveObjectPaths(path.ob, [path.sb], callback, contextCb);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tvar pth,\n\t\t\t\t\tpths = [], // Array of paths for current object\n\t\t\t\t\tl = paths.length;\n\t\t\t\twhile (l--) { // Step backwards through paths and objects\n\t\t\t\t\tpth = paths[l];\n\t\t\t\t\tif (pth + \"\" === pth || pth && (pth._ar || pth._cpfn)) {\n\t\t\t\t\t\tpths.unshift(pth); // This is a path so add to arr\n\t\t\t\t\t} else { // This is an object\n\t\t\t\t\t\tobserveObjectPaths(pth, pths, callback, contextCb);\n\t\t\t\t\t\tpths = []; // New array for next object\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tvar ns = observeStr,\n\t\t\t\tpaths = this != 1 // Using != for IE<10 bug- see jsviews/issues/237\n\t\t\t\t\t? concat.apply([], arguments) // Flatten the arguments - this is a 'recursive call' with params using the 'wrapped array'\n\t\t\t\t\t\t\t\t\t\t\t\t\t// style - such as innerObserve([object], path.path, [origRoot], path.prm, innerCb, ...);\n\t\t\t\t\t: slice.call(arguments), // Don't flatten - this is the first 'top-level call, to innerObserve.apply(1, paths)\n\t\t\t\tlastArg = paths.pop() || false,\n\t\t\t\tm = paths.length;\n\n//END OF FUNCTIONS\n\t\t\tif (lastArg + \"\" === lastArg) { // If last arg is a string then this observe call is part of an observeAll call,\n\t\t\t\tallPath = lastArg;          // and the last three args are the parentObs array, the filter, and the allPath string.\n\t\t\t\tparentObs = paths.pop();\n\t\t\t\tfilter = paths.pop();\n\t\t\t\tlastArg = !!paths.pop(); // unobserve\n\t\t\t\tm -= 3;\n\t\t\t}\n\t\t\tif (lastArg === !!lastArg) {\n\t\t\t\tunobserve = lastArg;\n\t\t\t\tlastArg = paths[m-1];\n\t\t\t\tlastArg = m && lastArg + \"\" !== lastArg && (!lastArg || $isFunction(lastArg)) ? (m--, paths.pop()) : undefined;\n\t\t\t\tif (unobserve && !m && $isFunction(paths[0])) {\n\t\t\t\t\tlastArg = paths.shift();\n\t\t\t\t}\n\t\t\t}\n\t\t\tcallback = lastArg;\n\t\t\tif (m && $isFunction(paths[m - 1])) {\n\t\t\t\tcontextCb = callback;\n\t\t\t\tlastArg = callback = paths.pop();\n\t\t\t\tm--;\n\t\t\t}\n\n\t\t\tif (unobserve && callback && !callback._cId) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// Use a unique namespace (e.g. obs7) associated with each observe() callback to allow unobserve to remove handlers\n\t\t\tns += callback\n\t\t\t\t? ((inId = callback._inId || \"\"), unobserve)\n\t\t\t\t\t? callback._cId + inId\n\t\t\t\t\t: (cbId = getCbKey(callback)) + inId\n\t\t\t\t: \"\";\n\n\t\t\tif (cbId && !unobserve) {\n\t\t\t\tcbBindings = cbBindingsStore[cbId] = cbBindingsStore[cbId] || {};\n\t\t\t}\n\n\t\t\tinitNsArr = initialNs && initialNs.match(rNotWhite) || [\"\"];\n\t\t\tinitNsArrLen = initNsArr.length;\n\n\t\t\twhile (initNsArrLen--) { // Step through multiple white-space separated namespaces if there are any\n\t\t\t\tinitialNs = initNsArr[initNsArrLen];\n\t\t\t\tif (unobserve && arguments.length < 3) {\n\t\t\t\t\tif (callback) {\n\t\t\t\t\t\tunobserveBinding(callback, cbBindingsStore[callback._cId]); // unobserve(handler) - unobserves this handler, all objects\n\t\t\t\t\t} else if (!paths[0]) {\n\t\t\t\t\t\tfor (p in cbBindingsStore) {\n\t\t\t\t\t\t\tunobserveBinding(callback, cbBindingsStore[p]); // unobserve() - unobserves all\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tobserveObjects(paths);\n\t\t\t}\n\t\t\tif (cbId) {\n\t\t\t\tremoveCbBindings(cbBindings, cbId);\n\t\t\t}\n\n\t\t\t// Return the cbBindings to the top-level caller, along with the cbId\n\t\t\treturn {cbId: cbId, bnd: cbBindings};\n\t\t}\n\n\t\tvar initialNs,\n\t\t\tallowArray = this == 1 ? 0 : 1, // If this == 1, this is a call from observeAndBind - doing binding of datalink expressions. We don't bind\n\t\t\t// arrayChange events in this scenario. Instead, {^{for}} and similar do specific arrayChange binding to the tagCtx.args[0] value, in onAfterLink.\n\t\t\t// Note deliberately using this == 1, rather than this === 1 because of IE<10 bug- see jsviews/issues/237\n\t\t\tpaths = slice.call(arguments),\n\t\t\tpth = paths[0];\n\n\t\tif (pth + \"\" === pth) {\n\t\t\tinitialNs = pth; // The first arg is a namespace, since it is a string\n\t\t\tpaths.shift();\n\t\t}\n\t\treturn innerObserve.apply(1, paths);\n\t};\n\n\t$observable = function(ns, data) {\n\t\tif (arguments.length === 1) {\n\t\t\tdata = ns;\n\t\t\tns = \"\";\n\t\t}\n\t\treturn $isArray(data)\n\t\t\t? new ArrayObservable(ns, data)\n\t\t\t: new ObjectObservable(ns, data);\n\t};\n\n\t//========================== Initialize ==========================\n\n\t$.observable = $observable;\n\t$observable._fltr = function(path, object, parentObs, filter) {\n\t\tif (filter && $isFunction(filter)\n\t\t\t? filter(path, object, parentObs)\n\t\t\t: true // TODO Consider supporting filter being a string or strings to do RegEx filtering based on key and/or path\n\t\t) {\n\t\t\tobject = $isFunction(object)\n\t\t\t\t? object.set && object.call(parentObs[0]) // It is a getter/setter\n\t\t\t\t: object;\n\t\t\treturn typeof object === OBJECT && object;\n\t\t}\n\t};\n\n\t$observable.Object = ObjectObservable;\n\t$observable.Array = ArrayObservable;\n\t$.observe = $observable.observe = $observe;\n\t$.unobserve = $observable.unobserve = $unobserve;\n\t$observable._apply = observe_apply;\n\n\tObjectObservable.prototype = {\n\t\t_data: null,\n\n\t\tobserveAll: $observeAll,\n\t\tunobserveAll: $unobserveAll,\n\n\t\tdata: function() {\n\t\t\treturn this._data;\n\t\t},\n\n\t\tsetProperty: function(path, value, nonStrict) {\n\t\t\tpath = path || \"\";\n\t\t\tvar key, pair, parts,\n\t\t\t\tmulti = path + \"\" !== path, // Hash of paths\n\t\t\t\tself = this,\n\t\t\t\tobject = self._data;\n\n\t\t\tif (object) {\n\t\t\t\tif (multi) {\n\t\t\t\t\tnonStrict = value;\n\t\t\t\t\tif ($isArray(path)) {\n\t\t\t\t\t\t// This is the array format generated by serializeArray. However, this has the problem that it coerces types to string,\n\t\t\t\t\t\t// and does not provide simple support of convertTo and convertFrom functions.\n\t\t\t\t\t\tkey = path.length;\n\t\t\t\t\t\twhile (key--) {\n\t\t\t\t\t\t\tpair = path[key];\n\t\t\t\t\t\t\tself.setProperty(pair.name, pair.value, nonStrict === undefined || nonStrict); //If nonStrict not specified, default to true;\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\t// Object representation where property name is path and property value is value.\n\t\t\t\t\t\tfor (key in path) {\n\t\t\t\t\t\t\tself.setProperty(key, path[key], nonStrict);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} else if (path !== $expando) {\n\t\t\t\t\t// Simple single property case.\n\t\t\t\t\tparts = path.split(/[.^]/);\n\t\t\t\t\twhile (object && parts.length > 1) {\n\t\t\t\t\t\tobject = object[parts.shift()];\n\t\t\t\t\t}\n\t\t\t\t\tif (object) {\n\t\t\t\t\t\tself._setProperty(object, parts[0], value, nonStrict);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn self;\n\t\t},\n\n\t\tremoveProperty: function(path) {\n\t\t\tthis.setProperty(path, remove);\n\t\t\treturn this;\n\t\t},\n\n\t\t_setProperty: function(leaf, path, value, nonStrict) {\n\t\t\tvar setter, getter, removeProp, eventArgs, view,\n\t\t\t\tproperty = path ? leaf[path] : leaf;\n\n\t\t\tif ($isFunction(property) && property.set) {\n\t\t\t\t// Case of property setter/getter - with convention that property is getter and property.set is setter\n\t\t\t\tview = leaf._vw // Case of JsViews 2-way data-linking to an observable context parameter, with a setter.\n\t\t\t\t\t// The view will be the this pointer for getter and setter. Note: this is the one scenario where path is \"\".\n\t\t\t\t\t|| leaf;\n\t\t\t\tgetter = property;\n\t\t\t\tsetter = getter.set === true ? getter : getter.set;\n\t\t\t\tproperty = getter.call(view); // get - only treated as getter if also a setter. Otherwise it is simply a property of type function.\n\t\t\t\t// See unit tests 'Can observe properties of type function'.\n\t\t\t}\n\n\t\t\tif ((property !== value || nonStrict && property != value)\n\t\t\t\t// Optional non-strict equality, since serializeArray, and form-based editors can map numbers to strings, etc.\n\t\t\t\t// Date objects don't support != comparison. Treat as special case.\n\t\t\t\t&& (!(property instanceof Date && value instanceof Date) || property > value || property < value)) {\n\t\t\t\tif (setter) {\n\t\t\t\t\tsetter.call(view, value);   // set\n\t\t\t\t\tvalue = getter.call(view);  // get updated value\n\t\t\t\t} else if (removeProp = value === remove) {\n\t\t\t\t\tif (property !== undefined) {\n\t\t\t\t\t\tdelete leaf[path];\n\t\t\t\t\t\tvalue = undefined;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tpath = undefined; // If value was already undefined, don't trigger handler for removeProp\n\t\t\t\t\t}\n\t\t\t\t} else if (path) {\n\t\t\t\t\tleaf[path] = value;\n\t\t\t\t}\n\t\t\t\tif (path) {\n\t\t\t\t\teventArgs = {change: \"set\", path: path, value: value, oldValue: property, remove: removeProp};\n\t\t\t\t\tif (leaf._ocp) {\n\t\t\t\t\t\teventArgs.ctxPrm = leaf._key;\n\t\t\t\t\t}\n\t\t\t\t\tthis._trigger(leaf, eventArgs);\n\t\t\t\t}\n\t\t\t}\n\t\t},\n\n\t\t_trigger: function(target, eventArgs) {\n\t\t\t$(target).triggerHandler(propertyChangeStr + (this._ns ? \".\" + /^\\S+/.exec(this._ns)[0] : \"\"), eventArgs); // If white-space separated namespaces, use first one only\n\t\t}\n\t};\n\n\tArrayObservable.prototype = {\n\t\t_data: null,\n\n\t\tobserveAll: $observeAll,\n\t\tunobserveAll: $unobserveAll,\n\n\t\tdata: function() {\n\t\t\treturn this._data;\n\t\t},\n\n\t\tinsert: function(index, data) {\n\t\t\tvar _data = this._data;\n\t\t\tif (arguments.length === 1) {\n\t\t\t\tdata = index;\n\t\t\t\tindex = _data.length;\n\t\t\t}\n\t\t\tindex = PARSEINT(index);\n\t\t\tif (index > -1) {\n\t\t\t\tdata = $isArray(data) ? data : [data];\n\t\t\t\t// data can be a single item (including a null/undefined value) or an array of items.\n\t\t\t\t// Note the provided items are inserted without being cloned, as direct references to the provided objects\n\n\t\t\t\tif (data.length) {\n\t\t\t\t\tthis._insert(index, data);\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn this;\n\t\t},\n\n\t\t_insert: function(index, data) {\n\t\t\tvar _data = this._data,\n\t\t\t\toldLength = _data.length;\n\t\t\tif (index > oldLength) {\n\t\t\t\tindex = oldLength;\n\t\t\t}\n\t\t\tsplice.apply(_data, [index, 0].concat(data));\n\t\t\tthis._trigger({change: \"insert\", index: index, items: data}, oldLength);\n\t\t},\n\n\t\tremove: function(index, numToRemove) {\n\t\t\tvar items,\n\t\t\t\t_data = this._data;\n\n\t\t\tif (index === undefined) {\n\t\t\t\tindex = _data.length - 1;\n\t\t\t}\n\n\t\t\tindex = PARSEINT(index);\n\t\t\tnumToRemove = numToRemove ? PARSEINT(numToRemove) : numToRemove === 0 ? 0 : 1; // if null or undefined: remove 1\n\t\t\tif (numToRemove > 0 && index > -1) {\n\t\t\t\titems = _data.slice(index, index + numToRemove);\n\t\t\t\tif (numToRemove = items.length) {\n\t\t\t\t\tthis._remove(index, numToRemove, items);\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn this;\n\t\t},\n\n\t\t_remove: function(index, numToRemove, items) {\n\t\t\tvar _data = this._data,\n\t\t\t\toldLength = _data.length;\n\n\t\t\t_data.splice(index, numToRemove);\n\t\t\tthis._trigger({change: \"remove\", index: index, items: items}, oldLength);\n\t\t},\n\n\t\tmove: function(oldIndex, newIndex, numToMove) {\n\t\t\tnumToMove = numToMove ? PARSEINT(numToMove) : numToMove === 0 ? 0 : 1; // if null or undefined: move 1\n\t\t\toldIndex = PARSEINT(oldIndex);\n\t\t\tnewIndex = PARSEINT(newIndex);\n\n\t\t\tif (numToMove > 0 && oldIndex > -1 && newIndex > -1 && oldIndex !== newIndex) {\n\t\t\t\tthis._move(oldIndex, newIndex, numToMove);\n\t\t\t}\n\t\t\treturn this;\n\t\t},\n\n\t\t_move: function(oldIndex, newIndex, numToMove) {\n\t\t\tvar items,\n\t\t\t\t_data = this._data,\n\t\t\t\toldLength = _data.length,\n\t\t\t\texcess = oldIndex + numToMove - oldLength;\n\t\t\tif (excess > 0) {\n\t\t\t\tnumToMove -= excess;\n\t\t\t}\n\t\t\tif (numToMove) {\n\t\t\t\titems = _data.splice(oldIndex, numToMove); // remove\n\t\t\t\tif (newIndex > _data.length) {\n\t\t\t\t\tnewIndex = _data.length;\n\t\t\t\t}\n\t\t\t\tsplice.apply(_data, [newIndex, 0].concat(items)); //re-insert\n\t\t\t\tif (newIndex !== oldIndex) {\n\t\t\t\t\tthis._trigger({change: \"move\", oldIndex: oldIndex, index: newIndex, items: items}, oldLength);\n\t\t\t\t}\n\t\t\t}\n\t\t},\n\n\t\trefresh: function(newItems) {\n\t\t\tfunction insertAdded() {\n\t\t\t\tif (k) {\n\t\t\t\t\tself.insert(j-k, addedItems); // Not found in original array - so insert\n\t\t\t\t\tdataLength += k;\n\t\t\t\t\ti += k;\n\t\t\t\t\tk = 0;\n\t\t\t\t\taddedItems = [];\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// For refresh operation we iteratively step through the target array and sort by move/add/remove operations on the source array until they match\n\t\t\tvar i, j, k, newItem, num,\n\t\t\t\tself = this,\n\t\t\t\taddedItems = [],\n\t\t\t\tdata = self._data,\n\t\t\t\toldItems = data.slice(),\n\t\t\t\toldLength = data.length,\n\t\t\t\tdataLength = oldLength,\n\t\t\t\tnewLength = newItems.length;\n\t\t\tself._srt = true; // Flag for sorting during refresh\n\t\t\tfor (j=k=0; j<newLength; j++) {\n\t\t\t\tif ((newItem = newItems[j]) === data[j-k]) {\n\t\t\t\t\tinsertAdded();\n\t\t\t\t} else {\n\t\t\t\t\tfor (i=j-k; i<dataLength && newItem !== data[i]; i++) {}\n\t\t\t\t\tif (i<dataLength) {\n\t\t\t\t\t\tinsertAdded();\n\t\t\t\t\t\tnum = 0;\n\t\t\t\t\t\twhile (num++ < newLength-i && newItems[j+num] === data[i+num]);\n\t\t\t\t\t\tself.move(i, j, num); // Found newItem in original array - so move it to new position\n\t\t\t\t\t\tj += num - 1;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tk++;\n\t\t\t\t\t\taddedItems.push(newItem); // Not found in original array - so insert\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tinsertAdded();\n\t\t\tif (dataLength > j) {\n\t\t\t\tself.remove(j, dataLength - j);\n\t\t\t}\n\t\t\tself._srt = undefined; // We have finished sort operations during refresh\n\t\t\tif (oldLength || newLength) {\n\t\t\t\tself._trigger({change: \"refresh\", oldItems: oldItems}, oldLength);\n\t\t\t}\n\t\t\treturn self;\n\t\t},\n\n\t\t_trigger: function(eventArgs, oldLength) {\n\t\t\tvar self = this,\n\t\t\t\t_data = self._data,\n\t\t\t\tlength = _data.length,\n\t\t\t\t$_data = $([_data]);\n\t\t\tif (self._srt) {\n\t\t\t\teventArgs.refresh = true; // We are sorting during refresh\n\t\t\t} else if (length !== oldLength) { // We have finished sort operations during refresh\n\t\t\t\t$_data.triggerHandler(propertyChangeStr, {change: \"set\", path: \"length\", value: length, oldValue: oldLength});\n\t\t\t}\n\t\t\t$_data.triggerHandler(arrayChangeStr + (self._ns ? \".\" + /^\\S+/.exec(self._ns)[0] : \"\"), eventArgs); // If white-space separated namespaces, use first one only\n\t\t}\n\t};\n\n\t$eventSpecial[propertyChangeStr] = $eventSpecial[arrayChangeStr] = {\n\t\t// Register a jQuery special 'remove' event, to access the data associated with handlers being removed by jQuery.off().\n\t\t// We get data.cb._cId from the event handleObj and get the corresponding cbBindings hash from the cbBindingsStore,\n\t\t// then remove this object from that bindings hash - if the object does not have any other handlers associated with the same callback.\n\t\tremove: function (handleObj) {\n\t\t\tvar cbBindings, found, events, l, data,\n\t\t\t\tevData = handleObj.data;\n\t\t\tif ((evData) && (evData.off = true, evData = evData.cb)) { //Set off = true as marker for disposed event\n\t\t\t\t// Get the cb._cId from handleObj.data.cb._cId\n\t\t\t\tif (cbBindings = cbBindingsStore[evData._cId]) {\n\t\t\t\t\t// There were bindings for this callback. If this was the last one, we'll remove it.\n\t\t\t\t\tevents = $._data(this).events[handleObj.type];\n\t\t\t\t\tl = events.length;\n\t\t\t\t\twhile (l-- && !found) {\n\t\t\t\t\t\tfound = (data = events[l].data) && data.cb && data.cb._cId === evData._cId;\n\t\t\t\t\t\t// Found another one with same callback (though may be a different innerCallback)\n\t\t\t\t\t}\n\t\t\t\t\tif (!found) {\n\t\t\t\t\t\t// This was the last handler for this callback and object, so remove the binding entry\n\t\t\t\t\t\tdelete cbBindings[$data(this).obId];\n\t\t\t\t\t\tremoveCbBindings(cbBindings, evData._cId);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t};\n\n//==========================\n// dataMap with data-linking\n//==========================\n\n\t$views.map = function(mapDef) {\n\t\tfunction Map(source, options, oldMapOrTarget, unbound) {\n\t\t\tvar changing, updatedMap,\n\t\t\t\tmap = this;\n\t\t\tif (map.src) {\n\t\t\t\tmap.unmap(); // We are re-mapping a new source\n\t\t\t}\n\t\t\tif (options) {\n\t\t\t\toptions.map = map;\n\t\t\t}\n\t\t\tif (typeof source === OBJECT || $isFunction(source)) {\n\t\t\t\tmap.src = source;\n\t\t\t\tif (unbound) {\n\t\t\t\t\tmap.tgt = mapDef.getTgt(source, options);\n\t\t\t\t} else {\n\t\t\t\t\tif (oldMapOrTarget) {\n\t\t\t\t\t\tmap.tgt = oldMapOrTarget.tgt || $isArray(oldMapOrTarget) && oldMapOrTarget; // Can provide an existing map, or a target array to be used on new map\n\t\t\t\t\t}\n\t\t\t\t\tmap.tgt = map.tgt || [];\n\t\t\t\t\tmap.options = options || map.options;\n\t\t\t\t\tif (updatedMap = map.update()) {\n\t\t\t\t\t\tmap = updatedMap; // If updating returns another map, then we can replace this one (so no need to bind it)\n\t\t\t\t\t} else {\n\t\t\t\t\t\tif (mapDef.obsSrc) {\n\t\t\t\t\t\t\t$observable(map.src).observeAll(map.obs = function(ev, eventArgs) {\n\t\t\t\t\t\t\t\tif (!changing && !eventArgs.refresh) {\n\t\t\t\t\t\t\t\t\tchanging = true;\n\t\t\t\t\t\t\t\t\tmapDef.obsSrc(map, ev, eventArgs);\n\t\t\t\t\t\t\t\t\tchanging = undefined;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}, map.srcFlt);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (mapDef.obsTgt) {\n\t\t\t\t\t\t\t$observable(map.tgt).observeAll(map.obt = function(ev, eventArgs) {\n\t\t\t\t\t\t\t\tif (!changing && !map.tgt._updt) {\n\t\t\t\t\t\t\t\t\tchanging = true;\n\t\t\t\t\t\t\t\t\tmapDef.obsTgt(map, ev, eventArgs);\n\t\t\t\t\t\t\t\t\tchanging = undefined;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}, map.tgtFlt);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif ($isFunction(mapDef)) {\n\t\t\t// Simple map declared as function\n\t\t\tmapDef = {\n\t\t\t\tgetTgt: mapDef\n\t\t\t};\n\t\t}\n\n\t\tif (mapDef.baseMap) {\n\t\t\tmapDef = $.extend({}, mapDef.baseMap, mapDef);\n\t\t}\n\n\t\tmapDef.map = function(source, options, oldMap, unbound) {\n\t\t\treturn new Map(source, options, oldMap, unbound);\n\t\t};\n\n\t\t(Map.prototype = {\n\t\t\tsrcFlt: mapDef.srcFlt || shallowFilter, // default to shallowFilter\n\t\t\ttgtFlt: mapDef.tgtFlt || shallowFilter,\n\t\t\tupdate: function(options) {\n\t\t\t\tvar oldMap, newMap,\n\t\t\t\t\tmap = this,\n\t\t\t\t\ttgt = map.tgt;\n\t\t\t\tif (!tgt._updt) {\n\t\t\t\t\ttgt._updt = true;\n\t\t\t\t\toldMap = map.options && map.options.map;\n\t\t\t\t\t$observable(tgt).refresh(mapDef.getTgt(map.src, map.options = options || map.options));\n\t\t\t\t\ttgt._updt = false;\n\t\t\t\t\tnewMap = map.options && map.options.map;\n\t\t\t\t\tif (newMap && oldMap !== newMap) {\n\t\t\t\t\t\treturn newMap;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t},\n\t\t\tobserve: function(deps, linkCtx) { // Listen to observable changes of mapProps, and call map.update when change happens\n\t\t\t\tvar map = this,\n\t\t\t\t\toptions = map.options;\n\t\t\t\tif (map.obmp) {\n\t\t\t\t\t// There is a previous handler observing the mapProps\n\t\t\t\t\t$unobserve(map.obmp);\n\t\t\t\t}\n\t\t\t\tmap.obmp = function() {\n\t\t\t\t\t// Observe changes in the mapProps (\"filter\", \"sort\", \"reverse\", \"start\", \"end\")\n\t\t\t\t\tvar newTagCtx = linkCtx.fn(linkCtx.data, linkCtx.view, $sub)[options.index]; // Updated tagCtx props and args\n\t\t\t\t\t$.extend(options.props, newTagCtx.props); // Update props to new values\n\t\t\t\t\toptions.args = newTagCtx.args; // Update args to new values\n\t\t\t\t\tmap.update(); // Update the map target array, based on new mapProp values\n\t\t\t\t};\n\t\t\t\t$observable._apply(1, linkCtx.data, dependsPaths(deps, linkCtx.tag, map.obmp), map.obmp, linkCtx._ctxCb);\n\t\t\t},\n\t\t\tunmap: function() {\n\t\t\t\tvar map = this;\n\t\t\t\tif (map.src && map.obs) {\n\t\t\t\t\t$observable(map.src).unobserveAll(map.obs, map.srcFlt);\n\t\t\t\t}\n\t\t\t\tif (map.tgt && map.obt) {\n\t\t\t\t\t$observable(map.tgt).unobserveAll(map.obt, map.tgtFlt);\n\t\t\t\t}\n\t\t\t\tif (map.obmp) {\n\t\t\t\t\t$unobserve(map.obmp);\n\t\t\t\t}\n\t\t\t\tmap.src = undefined;\n\t\t\t},\n\t\t\tmap: Map,\n\t\t\t_def: mapDef\n\t\t}).constructor = Map;\n\n\t\treturn mapDef;\n\t};\n\n\t$sub.advSet = function() { // refresh advanced settings\n\t\t$sub._gccb = this._gccb; // getContextCallback method\n\t\tglobal._jsv = $subSettings.advanced._jsv\n\t\t\t? { // create global _jsv, for accessing views, etc\n\t\t\t\t\tcbBindings: cbBindingsStore\n\t\t\t\t}\n\t\t\t: undefined; // In IE8 cannot do delete global._jsv\n\t};\n\t$sub._dp = dependsPaths;\n\t$sub._gck = getCbKey;\n\t$sub._obs = $observe;\n}\n\n//<<<<<<<<<<<<<<<<<<<<<<<<<<<<<< JsViews >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>\n/* JsViews:\n * Interactive data-driven views using templates and data-linking.\n * See https://www.jsviews.com/#jsviews and http://github.com/BorisMoore/jsviews\n * Copyright 2019, Boris Moore\n * Released under the MIT License.\n */\n\n//========================== Top-level vars ==========================\n\n$viewsSettings = $views.settings;\n$subSettings = $sub.settings;\n$subSettingsAdvanced = $subSettings.advanced;\n$converters = $views.converters;\n$.templates = $templates = $views.templates;\n$tags = $views.tags;\nrFirstElem = /<(?!script)(\\w+)[>\\s]/;\n\nif ($.link) { return $; } // JsViews is already loaded\n\n$subSettings.trigger = true;\n\nvar activeBody, rTagDatalink, $view, $viewsLinkAttr, linkViewsSel, wrapMap, viewStore, oldAdvSet, useInput,\n\tisIE = window.navigator.userAgent,\n\tTEXTCONTENT = document.textContent !== undefined ? \"textContent\" : \"innerText\",\n\tjsvAttrStr = \"data-jsv\",\n\telementChangeStr = \"change.jsv\",\n\tonBeforeChangeStr = \"onBeforeChange\",\n\tonAfterChangeStr = \"onAfterChange\",\n\tonAfterCreateStr = \"onAfterCreate\",\n\tCHECKED = \"checked\",\n\tCHECKBOX = \"checkbox\",\n\tRADIO = \"radio\",\n\tNONE = \"none\",\n\tVALUE = \"value\",\n\tSCRIPT = \"SCRIPT\",\n\tTRUE = \"true\",\n\tcloseScript = '\"></script>',\n\topenScript = '<script type=\"jsv',\n\tdeferAttr = jsvAttrStr + \"-df\",\n\tbindElsSel = \"script,[\" + jsvAttrStr + \"]\",\n\tfnSetters = {\n\t\tvalue: \"val\",\n\t\tinput: \"val\",\n\t\thtml: HTML,\n\t\ttext: \"text\"\n\t},\n\tvalueBinding = {from: VALUE, to: VALUE},\n\tisCleanCall = 0,\n\toldCleanData = $.cleanData,\n\toldJsvDelimiters = $viewsSettings.delimiters,\n\tsafeFragment = document.createDocumentFragment(),\n\tqsa = document.querySelector,\n\n\t// elContent maps tagNames which have only element content, so may not support script nodes.\n\telContent = {ol: 1, ul: 1, table: 1, tbody: 1, thead: 1, tfoot: 1, tr: 1, colgroup: 1, dl: 1, select: 1, optgroup: 1, svg: 1, svg_ns: 1},\n\tbadParent = {tr: \"table\"},\n\tvoidElems = {br: 1, img: 1, input: 1, hr: 1, area: 1, base: 1, col: 1, link: 1, meta: 1,\n\t\tcommand: 1, embed: 1, keygen: 1, param: 1, source: 1, track: 1, wbr: 1},\n\tdisplayStyles = {},\n\tbindingStore = {},\n\tbindingKey = 1,\n\trViewPath = /^#(view\\.?)?/,\n\trConvertMarkers = /((\\/>)|<\\/(\\w+)>|)(\\s*)([#/]\\d+(?:_|(\\^)))`(\\s*)(<\\w+(?=[\\s\\/>]))?|\\s*(?:(<\\w+(?=[\\s\\/>]))|<\\/(\\w+)>(\\s*)|(\\/>)\\s*|(>)|$)/g,\n\trOpenViewMarkers = /(#)()(\\d+)(_)/g,\n\trOpenMarkers = /(#)()(\\d+)([_^])/g,\n\trViewMarkers = /(?:(#)|(\\/))(\\d+)(_)/g,\n\trTagMarkers = /(?:(#)|(\\/))(\\d+)(\\^)/g,\n\trOpenTagMarkers = /(#)()(\\d+)(\\^)/g,\n\trMarkerTokens = /(?:(#)|(\\/))(\\d+)([_^])([-+@\\d]+)?/g,\n\trSplitBindings = /&(\\d+)\\+?/g,\n\trShallowArrayPath = /^[^.]*$/, // No '.' in path\n\tgetComputedStyle = global.getComputedStyle,\n\t$inArray = $.inArray;\n\nisIE = isIE.indexOf('MSIE ')>0 || isIE.indexOf('Trident/')>0;\n\n$observable = $.observable;\n\nif (!$observable) {\n\t// JsObservable is not loaded.\n\tthrow requiresStr + \"JsObservable\"; // jquery.observable.js must be loaded before JsViews\n}\n\n$observe = $observable.observe;\n\n//========================== Top-level functions ==========================\n\n//===============\n// Event handlers\n//===============\n\nfunction updateValues(sourceValues, tagElse, bindId, ev) {\n// Observably update a data value targeted by the binding.to binding of a 2way data-link binding. Called when elem changes\n// Called when linkedElem of a tag control changes: as updateValue(val, index, tagElse, bindId, ev) - this: undefined\n// Called directly as tag.updateValues(val1, val2, val3, ...) - this: tag\n\tvar linkCtx, cvtBack, cnvtName, target, view, binding, sourceValue, origVals, sourceElem, sourceEl,\n\t\ttos, to, tcpTag, exprOb, contextCb, l, m, tag;\n\n\tif (bindId && bindId._tgId) {\n\t\ttag = bindId;\n\t\tbindId = tag._tgId;\n\t\tif (!tag.bindTo) {\n\t\t\tdefineBindToDataTargets(bindingStore[bindId], tag); // If this tag is updating for the first time, we need to create the 'to' bindings first\n\t\t\ttag.bindTo = [0];\n\t\t}\n\t}\n\tif ((binding = bindingStore[bindId]) && (tos = binding.to)) {\n\t\ttos = tos[tagElse||0];\n\t\t// The binding has a 'to' field, which is of the form [tosForElse0, tosForElse1, ...]\n\t\t// where tosForElseX is of the form [[[targetObject, toPath], [targetObject, toPath], ...], cvtBack]\n\t\tlinkCtx = binding.linkCtx;\n\t\tsourceElem = linkCtx.elem;\n\t\tview = linkCtx.view;\n\t\ttag = linkCtx.tag;\n\t\tif (!tag && tos._cxp) {\n\t\t\ttag = tos._cxp.path !== _ocp && tos._cxp.tag;\n\t\t\tsourceValue = sourceValues[0];\n\t\t\tsourceValues = [];\n\t\t\tsourceValues[tos._cxp.ind] = sourceValue;\n\t\t}\n\n\t\tif (tag) {\n\t\t\ttag._.chg = 1; // Set 'changing' marker to prevent tag update from updating itself\n\t\t\tif (cnvtName = tag.convertBack) {\n\t\t\t\tif ($isFunction(cnvtName)) {\n\t\t\t\t\tcvtBack = cnvtName;\n\t\t\t\t} else {\n\t\t\t\t\tcvtBack = view.getRsc(\"converters\", cnvtName);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (sourceElem.nodeName === \"SELECT\") {\n\t\t\t// data-link <select> to string or (multiselect) array of strings\n\t\t\tif (sourceElem.multiple && sourceValues[0] === null) {\n\t\t\t\t// Case where sourceValues was undefined, and set to [null] by $source[setter]() above\n\t\t\t\tsourceValues = [[]];\n\t\t\t}\n\t\t\tsourceElem._jsvSel = sourceValues;\n\t\t}\n\t\torigVals = sourceValues;\n\t\tif (cvtBack) {\n\t\t\tsourceValues = cvtBack.apply(tag, sourceValues);\n\t\t\tif (sourceValues === undefined) {\n\t\t\t\ttos = []; // If cvtBack does not return anything, do not update target.\n\t\t\t\t//(But cvtBack may be designed to modify observable values from code as a side effect)\n\t\t\t}\n\t\t\tsourceValues = $isArray(sourceValues) ? sourceValues : [sourceValues];\n\t\t\t// If there are multiple tos (e.g. multiple args on data-linked input) then cvtBack can update not only\n\t\t\t// the first arg, but all of them by returning an array.\n\t\t}\n\n\t\tl = tos.length;\n\t\twhile (l--) {\n\t\t\tif (to = tos[l]) {\n\t\t\t\tto = to + \"\" === to ? [linkCtx.data, to] : to; // [object, path]\n\t\t\t\ttarget = to[0];\n\t\t\t\ttcpTag = to.tag; // If this is a tag contextual parameter - the owner tag\n\t\t\t\tsourceValue = (target && target._ocp && !target._vw\n\t\t\t\t\t? origVals  // If to target is for tag contextual parameter set to static expression (or uninitialized) - we are\n\t\t\t\t\t// binding to tag.ctx.foo._ocp - and we use original values, without applying cvtBack converter\n\t\t\t\t\t: sourceValues // Otherwise use the converted value\n\t\t\t\t)[l];\n\t\t\t\tif (sourceValue !== undefined && (!tag || !tag.onBeforeUpdateVal || tag.onBeforeUpdateVal(ev, {\n\t\t\t\t\t\tchange: \"change\",\n\t\t\t\t\t\tdata: target,\n\t\t\t\t\t\tpath: to[1],\n\t\t\t\t\t\tindex: l,\n\t\t\t\t\t\ttagElse: tagElse,\n\t\t\t\t\t\tvalue: sourceValue\n\t\t\t\t\t}) !== false)) {\n\t\t\t\t\tif (tcpTag) { // We are modifying a tag contextual parameter ~foo (e.g. from within block) so update 'owner' tag: tcpTag\n\t\t\t\t\t\tif ((m = tcpTag._.toIndex[to.ind]) !== undefined) {\n\t\t\t\t\t\t\ttcpTag.updateValue(sourceValue, m, to.tagElse, undefined, undefined, ev); // if doesn't map, don't update, or update scoped tagCtxPrm. But should initialize from outer from binding...\n\t\t\t\t\t\t}\n\t\t\t\t\t\ttcpTag.setValue(sourceValue, to.ind, to.tagElse);\n\t\t\t\t\t} else if (sourceValue !== undefined && target) {\n\t\t\t\t\t\tif ((tcpTag = ev && (sourceEl = ev.target)._jsvInd === l && sourceEl._jsvLkEl) && (m = tcpTag._.fromIndex[l]) !== undefined) {\n\t\t\t\t\t\t\t// The source is a tag linkedElem (linkedElement: [..., \"elemSelector\", ...], which is updating\n\t\t\t\t\t\t\ttcpTag.setValue(origVals[l], m, sourceEl._jsvElse);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (target._cpfn) {\n\t\t\t\t\t\t\tcontextCb = linkCtx._ctxCb; // This is the exprOb for a computed property\n\t\t\t\t\t\t\texprOb = target;\n\t\t\t\t\t\t\ttarget = linkCtx.data;\n\t\t\t\t\t\t\tif (exprOb._cpCtx) { // Computed value for a contextual parameter\n\t\t\t\t\t\t\t\ttarget = exprOb.data; // The data for the contextual view (where contextual param expression evaluated/assigned)\n\t\t\t\t\t\t\t\tcontextCb = exprOb._cpCtx; // Context callback for contextual view\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\twhile (exprOb && exprOb.sb) { // Step through chained computed values to leaf one...\n\t\t\t\t\t\t\t\ttarget = contextCb(exprOb, target);\n\t\t\t\t\t\t\t\texprOb = exprOb.sb;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\t$observable(target).setProperty(to[1], sourceValue); // 2way binding change event - observably updating bound object\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tif (tag) {\n\t\ttag._.chg = undefined; // Clear marker\n\t\treturn tag;\n\t}\n}\n\nfunction onElemChange(ev) {\n\tvar bindId, val,\n\t\tsource = ev.target,\n\t\tfromAttr = defaultAttr(source),\n\t\tsetter = fnSetters[fromAttr];\n\n\tif (!source._jsvTr || ev.delegateTarget !== activeBody && ev.target.type !== \"number\" || ev.type === \"input\") {\n\t\t// If this is an element using trigger, ignore event delegated (bubbled) to activeBody\n\t\tval = $isFunction(fromAttr)\n\t\t\t? fromAttr(source)\n\t\t\t: (source = $(source), setter\n\t\t\t\t? source[setter]()\n\t\t\t\t: source.attr(fromAttr));\n\n\t\tev.target._jsvChg = 1; // // Set 'changing' marker to prevent linkedElem change event triggering its own refresh\n\t\trSplitBindings.lastIndex = 0; // Ensure starts at zero\n\t\twhile (bindId = rSplitBindings.exec(ev.target._jsvBnd)) {\n\t\t\t// _jsvBnd is a string with the syntax: \"&bindingId1&bindingId2\"\n\t\t\tupdateValue(val, source._jsvInd, source._jsvElse, undefined, bindId[1], ev);\n\t\t}\n\t\tev.target._jsvChg = undefined; // Clear marker\n\t}\n}\n\nfunction onDataLinkedTagChange(ev, eventArgs) {\n\t// Update or initial rendering of any tag (including {{:}}) whether inline or data-linked element.\n\tvar attr, sourceValue, noUpdate, forceUpdate, hasError, onError, bindEarly, tagCtx, l,\n\t\tlinkCtx = this,\n\t\tlinkFn = linkCtx.fn,\n\t\ttag = linkCtx.tag,\n\t\tsource = linkCtx.data,\n\t\ttarget = linkCtx.elem,\n\t\tcvt = linkCtx.convert,\n\t\tparentElem = target.parentNode,\n\t\tview = linkCtx.view,\n\t\toldLinkCtx = view._lc,\n\t\tonEvent = eventArgs && changeHandler(view, onBeforeChangeStr, tag);\n\n\tif (parentElem && (!onEvent || onEvent.call(tag || linkCtx, ev, eventArgs) !== false)\n\t\t\t// If data changed, the ev.data is set to be the path. Use that to filter the handler action...\n\t\t\t&& (!eventArgs || ev.data.prop === \"*\" || ev.data.prop === eventArgs.path)) {\n\n\t\t// Set linkCtx on view, dynamically, just during this handler call\n\t\tview._lc = linkCtx;\n\t\tif (eventArgs) {\n\t\t\tlinkCtx.eventArgs = eventArgs;\n\t\t}\n\t\tif (eventArgs || linkCtx._toLk) {\n\t\t\t// If eventArgs are defined, this is a data update\n\t\t\t// Otherwise this is the initial data-link rendering call. Bind on this the first time it gets called\n\t\t\tlinkCtx._toLk = 0; // Remove flag to skip unneccessary rebinding next time\n\t\t\tif (linkFn._er) {\n\t\t\t\t// data-link=\"exprUsingTagOrCvt with onerror=...\" - e.g. {tag ... {cvt:... {:... convert='cvt'\n\t\t\t\ttry {\n\t\t\t\t\tsourceValue = linkFn(source, view, $sub); // Compiled link expression\n\t\t\t\t\t// For data-link=\"{:xxx}\" with no cvt or cvtBk returns value. Otherwise returns tagCtxs\n\t\t\t\t} catch (e) {\n\t\t\t\t\thasError = linkFn._er;\n\t\t\t\t\tonError = onRenderError(e,view,(new Function(\"data,view\", \"return \" + hasError + \";\"))(source, view));\n\t\t\t\t\tsourceValue = [{props: {}, args: [onError], tag: tag}];\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tsourceValue = linkFn(source, view, $sub); // Compiled link expression\n\t\t\t\t// For data-link=\"{:xxx}\" with no cvt or cvtBk returns value. Otherwise returns tagCtxs\n\t\t\t}\n\t\t\t// Compiled link expression for linkTag: return value for data-link=\"{:xxx}\" with no cvt or cvtBk, otherwise tagCtx or tagCtxs\n\t\t\tattr = tag && tag.attr || linkCtx.attr || (linkCtx._dfAt = defaultAttr(target, true, cvt !== undefined));\n\t\t\tif (attr === VALUE && (tag && tag.parentElem || linkCtx.elem).type === CHECKBOX) {\n\t\t\t\tattr = CHECKED;\n\t\t\t}\n\t\t\t// For {{: ...}} without a convert or convertBack, (tag and linkFn._tag undefined) we already have the sourceValue, and we are done\n\t\t\tif (tag) {\n\t\t\t\t// Existing tag instance\n\t\t\t\tforceUpdate = hasError || tag._er;\n\t\t\t\t// If the new tagCtxs hasError or the previous tagCtxs had error, then force update\n\t\t\t\tsourceValue = sourceValue[0] ? sourceValue : [sourceValue];\n\n\t\t\t\t// Tag will update unless tag.onUpdate is false or is a function which returns false\n\t\t\t\tnoUpdate = !forceUpdate && (tag.onUpdate === false || eventArgs && $isFunction(tag.onUpdate) && tag.onUpdate(ev, eventArgs, sourceValue) === false);\n\n\t\t\t\tmergeCtxs(tag, sourceValue, forceUpdate); // Merge new tagCtxs (in sourceValue var) with current tagCtxs on tag instance\n\n\t\t\t\tif (tag._.chg && (attr === HTML || attr === VALUE) || noUpdate || attr === NONE) {\n\t\t\t\t\t// This is an update coming from the tag itself (linkedElem change), or else onUpdate returned false, or attr === \"none\"\n\t\t\t\t\tcallAfterLink(tag, ev, eventArgs);\n\t\t\t\t\tif (!tag._.chg) {\n\t\t\t\t\t\t// onUpdate returned false, or attr === \"none\" - so don't refresh the tag: we just use the new tagCtxs merged\n\t\t\t\t\t\t// from the sourceValue (which may optionally have been modifed in onUpdate()...) and then bind, and we are done\n\t\t\t\t\t\tobserveAndBind(linkCtx, source, target);\n\t\t\t\t\t}\n\t\t\t\t\t// Remove dynamically added linkCtx from view\n\t\t\t\t\tview._lc = oldLinkCtx;\n\t\t\t\t\tif (eventArgs && (onEvent = changeHandler(view, onAfterChangeStr, tag))) {\n\t\t\t\t\t\tonEvent.call(tag || linkCtx, ev, eventArgs);\n\t\t\t\t\t}\n\t\t\t\t\tif (tag.tagCtx.props.dataMap) {\n\t\t\t\t\t\ttag.tagCtx.props.dataMap.map(tag.tagCtx.args[0], tag.tagCtx, tag.tagCtx.map, isRenderCall || !tag._.bnd);\n\t\t\t\t\t}\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tif (tag.onUnbind) {\n\t\t\t\t\ttag.onUnbind(tag.tagCtx, linkCtx, tag.ctx, ev, eventArgs);\n\t\t\t\t}\n\n\t\t\t\ttag.linkedElems = tag.linkedElem = tag.mainElem = tag.displayElem = undefined;\n\t\t\t\tl = tag.tagCtxs.length;\n\t\t\t\twhile (l--) {\n\t\t\t\t\ttagCtx = tag.tagCtxs[l];\n\t\t\t\t\ttagCtx.linkedElems = tagCtx.mainElem = tagCtx.displayElem = undefined;\n\t\t\t\t}\n\n\t\t\t\tsourceValue = tag.tagName === \":\" // Call convertVal if it is a {{cvt:...}} - otherwise call renderTag\n\t\t\t\t\t? $sub._cnvt(tag.convert, view, sourceValue[0]) // convertVal()    // convertVal(converter, view, tagCtx, onError)\n\t\t\t\t\t: $sub._tag(tag, view, view.tmpl, sourceValue, true, onError); // renderTag(tagName, parentView, tmpl, tagCtxs, isUpdate, onError)\n\t\t\t} else if (linkFn._tag) {\n\t\t\t\t// For {{: ...}} with either cvt or cvtBack we call convertVal to get the sourceValue and instantiate the tag\n\t\t\t\t// If cvt is undefined then this is a tag, and we call renderTag to get the rendered content and instantiate the tag\n\t\t\t\tcvt = cvt === \"\" ? TRUE : cvt; // If there is a cvtBack but no cvt, set cvt to \"true\"\n\t\t\t\tsourceValue = cvt // Call convertVal if it is a {{cvt:...}} - otherwise call renderTag\n\t\t\t\t\t? $sub._cnvt(cvt, view, sourceValue[0] || sourceValue)                 // convertVal(converter, view, tagCtx, onError)\n\t\t\t\t\t: $sub._tag(linkFn._tag, view, view.tmpl, sourceValue, true, onError); // renderTag(tagName, parentView, tmpl, tagCtxs, isUpdate, onError)\n\n\t\t\t\taddLinkMethods(tag = linkCtx.tag); // In both convertVal and renderTag we have instantiated a tag\n\t\t\t\tattr = linkCtx.attr || attr; // linkCtx.attr may have been set to tag.attr during tag instantiation in renderTag\n\t\t\t}\n\t\t\tif (bindEarly = tag && (!tag.inline || linkCtx.fn._lr) && tag.template) {\n\t\t\t\t// Data-linked tags with templated contents need to be data-linked before their contents, so that observable updates\n\t\t\t\t// will trigger the parent tags before the child tags.\n\t\t\t\tobserveAndBind(linkCtx, source, target);\n\t\t\t}\n\t\t\tupdateContent(sourceValue, linkCtx, attr, tag);\n\t\t\tlinkCtx._noUpd = 0; // For data-link=\"^{...}\" remove _noUpd flag so updates on subsequent calls\n\n\t\t\tif (tag) {\n\t\t\t\ttag._er = hasError;\n\t\t\t\tcallAfterLink(tag, ev, eventArgs);\n\t\t\t}\n\t\t}\n\n\t\tif (!bindEarly) {\n\t\t\tobserveAndBind(linkCtx, source, target);\n\t\t}\n\n\t\tif (tag && tag._.ths) {\n\t\t\t// Tag has a this=expr binding for which we have created an additional 'to' (defineBindToDataTargets) target (at index bindTo.length)\n\t\t\t// We now have the this pointer, so we push it to the binding, using updateValue(index)\n\t\t\ttag.updateValue(tag, tag.bindTo ? tag.bindTo.length : 1); // If bindTo not defined yet, it will be [0], so length 1\n\t\t}\n\n\t\tif (eventArgs && (onEvent = changeHandler(view, onAfterChangeStr, tag))) {\n\t\t\tonEvent.call(tag || linkCtx, ev, eventArgs);\n\t\t}\n\t\t// Remove dynamically added linkCtx from view\n\t\tview._lc = oldLinkCtx;\n\t}\n}\n\nfunction setDefer(elem, value) {\n\telem._df = value; // Use both an expando and an attribute to track deferred tokens. Attribute is needed for querySelectorAll for getViewInfos (childTags)\n\telem[(value ? \"set\" : \"remove\") + \"Attribute\"](deferAttr, \"\");\n}\n\nfunction updateContent(sourceValue, linkCtx, attr, tag) {\n\t// When called for a tag, either in tag.refresh() or onDataLinkedTagChange(), returns tag\n\t// When called (in onDataLinkedTagChange) for target HTML returns true\n\t// When called (in onDataLinkedTagChange) for other targets returns boolean for \"changed\"\n\tvar setter, prevNode, nextNode, late, nodesToRemove, useProp, tokens, id, openIndex, closeIndex, testElem, nodeName, cStyle, jsvSel,\n\t\trenders = attr !== NONE && sourceValue !== undefined && !linkCtx._noUpd && !((attr === VALUE || attr === HTML) && (!tag && linkCtx.elem._jsvChg)),\n\t\t// For data-link=\"^{...}\", don't update the first time (no initial render) - e.g. to leave server rendered values.\n\t\tsource = linkCtx.data,\n\t\ttarget = tag && tag.parentElem || linkCtx.elem,\n\t\ttargetParent = target.parentNode,\n\t\t$target = $(target),\n\t\tview = linkCtx.view,\n\t\ttargetVal = linkCtx._val,\n\t\tchange = tag;\n\n\tif (tag) {\n\t\t// Initialize the tag with element references\n\t\ttag._.unlinked = true; // Set to unlinked, so initialization is triggered after re-rendering, e.g. for setting linkedElem, and calling onBind\n\t\ttag.parentElem = tag.parentElem || (linkCtx.expr || tag._elCnt) ? target : targetParent;\n\t\tprevNode = tag._prv;\n\t\tnextNode = tag._nxt;\n\t}\n\tif (!renders) {\n\t\tlinkCtx._val = sourceValue;\n\t\treturn;\n\t}\n\n\tif (attr === \"visible\") {\n\t\tattr = \"css-display\";\n\t}\n\tif (/^css-/.test(attr)) {\n\t\tif (linkCtx.attr === \"visible\") {\n\t\t\t// Get the current display style\n\t\t\tcStyle = (target.currentStyle || getComputedStyle.call(global, target, \"\")).display;\n\n\t\t\tif (sourceValue) {\n\t\t\t\t// We are showing the element.\n\t\t\t\t// Get the cached 'visible' display value from the -jsvd expando\n\t\t\t\tsourceValue = target._jsvd\n\t\t\t\t\t// Or, if not yet cached, get the current display value\n\t\t\t\t\t|| cStyle;\n\t\t\t\tif (sourceValue === NONE && !(sourceValue = displayStyles[nodeName = target.nodeName])) {\n\t\t\t\t\t// Currently display value is 'none', and the 'visible' style has not been cached.\n\t\t\t\t\t// We create an element to find the correct 'visible' display style for this nodeName\n\t\t\t\t\ttestElem = document.createElement(nodeName);\n\t\t\t\t\tdocument.body.appendChild(testElem);\n\n\t\t\t\t\t// Get the default style for this HTML tag to use as 'visible' style\n\t\t\t\t\tsourceValue\n\t\t\t\t\t\t// and cache it as a hash against nodeName\n\t\t\t\t\t\t= displayStyles[nodeName]\n\t\t\t\t\t\t= (testElem.currentStyle || getComputedStyle.call(global, testElem, \"\")).display;\n\t\t\t\t\tdocument.body.removeChild(testElem);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t// We are hiding the element.\n\t\t\t\t// Cache the current display value as 'visible' style, on _jsvd expando, for when we show the element again\n\t\t\t\ttarget._jsvd = cStyle;\n\t\t\t\tsourceValue = NONE; // Hide the element\n\t\t\t}\n\t\t}\n\t\tif (change = change || targetVal !== sourceValue) {\n\t\t\t$.style(target, attr.slice(4), sourceValue);\n\t\t}\n\t} else if (attr !== \"link\") { // attr === \"link\" is for tag controls which do data binding but have no rendered output or target\n\t\tif (/^data-/.test(attr)) {\n\t\t\t$.data(target, attr.slice(5), sourceValue); // Support for binding to data attributes: data-foo{:expr}: data-foo attribute will be\n\t\t\t// expr.toString(), but $.data(element, \"foo\") and $(element).data(\"foo\") will actually return value of expr, even if of type object\n\t\t} else if (/^prop-/.test(attr)) {\n\t\t\tuseProp = true;\n\t\t\tattr = attr.slice(5);\n\t\t} else if (attr === CHECKED) {\n\t\t\tuseProp = true;\n\t\t\tsourceValue = sourceValue && sourceValue !== \"false\";\n\t\t\t// The string value \"false\" can occur with data-link=\"checked{attr:expr}\" - as a result of attr, and hence using convertVal()\n\t\t\t// We will set the \"checked\" property\n\t\t\t// We will compare this with the current value\n\t\t} else if (attr === RADIO) {\n\t\t\t// This is a special binding attribute for radio buttons, which corresponds to the default 'to' binding.\n\t\t\t// This allows binding both to value (for each input) and to the default checked radio button (for each input in named group,\n\t\t\t// e.g. binding to parent data).\n\t\t\t// Place value binding first: <input type=\"radio\" data-link=\"value{:name} {:#get('data').data.currency:} \" .../>\n\t\t\t// or (allowing any order for the binding expressions):\n\t\t\t// <input type=\"radio\" value=\"{{:name}}\" data-link=\"{:#get('data').data.currency:} value^{:name}\" .../>\n\t\t\tuseProp = true;\n\t\t\tattr = CHECKED;\n\t\t\tsourceValue = target.value === sourceValue;\n\t\t\t// If the data value corresponds to the value attribute of this radio button input, set the checked property to true\n\t\t\t// Otherwise set the checked property to false\n\t\t} else if (attr === \"selected\" || attr === \"disabled\" || attr === \"multiple\" || attr === \"readonly\") {\n\t\t\tsourceValue = (sourceValue && sourceValue !== \"false\") ? attr : null;\n\t\t\t// Use attr, not prop, so when the options (for example) are changed dynamically, but include the previously selected value,\n\t\t\t// they will still be selected after the change\n\t\t} else if (attr === VALUE && target.nodeName === \"SELECT\") {\n\t\t\ttarget._jsvSel = $isArray(sourceValue)\n\t\t\t\t? sourceValue\n\t\t\t\t: \"\" + sourceValue; // If not array, coerce to string\n\t\t}\n\n\t\tif (setter = fnSetters[attr]) {\n\t\t\tif (attr === HTML) {\n\t\t\t\tif (tag && tag.inline) {\n\t\t\t\t\tnodesToRemove = tag.nodes(true);\n\t\t\t\t\tif (tag._elCnt) {\n\t\t\t\t\t\tif (prevNode && prevNode !== nextNode) { // nextNode !== prevNode\n\t\t\t\t\t\t\t// This prevNode will be removed from the DOM, so transfer the view tokens on prevNode to nextNode of this 'viewToRefresh'\n\t\t\t\t\t\t\ttransferViewTokens(prevNode, nextNode, target, tag._tgId, \"^\", true);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t// nextNode === prevNode, or there is no nextNode and so the target._df may have tokens\n\t\t\t\t\t\t\ttokens = prevNode ? prevNode.getAttribute(jsvAttrStr) : target._df;\n\t\t\t\t\t\t\tid = tag._tgId + \"^\";\n\t\t\t\t\t\t\topenIndex = tokens.indexOf(\"#\" + id) + 1;\n\t\t\t\t\t\t\tcloseIndex = tokens.indexOf(\"/\" + id);\n\n\t\t\t\t\t\t\tif (openIndex && closeIndex > 0) {\n\t\t\t\t\t\t\t\t// If prevNode, or target._df, include tokens referencing view and tag bindings contained within the open and close tokens\n\t\t\t\t\t\t\t\t// of the updated tag control, they need to be processed (disposed)\n\t\t\t\t\t\t\t\topenIndex += id.length;\n\t\t\t\t\t\t\t\tif (closeIndex > openIndex) {\n\t\t\t\t\t\t\t\t\tdisposeTokens(tokens.slice(openIndex, closeIndex)); // Dispose view and tag bindings\n\t\t\t\t\t\t\t\t\ttokens = tokens.slice(0, openIndex) + tokens.slice(closeIndex);\n\n\t\t\t\t\t\t\t\t\tif (prevNode) {\n\t\t\t\t\t\t\t\t\t\tprevNode.setAttribute(jsvAttrStr, tokens); // Remove tokens of replaced content\n\t\t\t\t\t\t\t\t\t} else if (target._df) { // Remove tokens of replaced content\n\t\t\t\t\t\t\t\t\t\tsetDefer(target, tokens);\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tprevNode = prevNode\n\t\t\t\t\t\t\t? prevNode.previousSibling\n\t\t\t\t\t\t\t: nextNode\n\t\t\t\t\t\t\t\t? nextNode.previousSibling\n\t\t\t\t\t\t\t\t: target.lastChild;\n\t\t\t\t\t}\n\t\t\t\t\t// Remove HTML nodes\n\t\t\t\t\t$(nodesToRemove).remove(); // Note if !tag._elCnt removing the nodesToRemove will process and dispose view and tag bindings contained within the updated tag control\n\n\t\t\t\t\t// Insert and link new content\n\t\t\t\t\tlate = view.link(view.data, target, prevNode, nextNode, sourceValue, tag && {tag: tag._tgId});\n\t\t\t\t} else {\n\t\t\t\t\t// data-linked value targeting innerHTML: data-link=\"html{:expr}\" or contenteditable=\"true\"\n\t\t\t\t\trenders = renders && targetVal !== sourceValue;\n\t\t\t\t\tif (renders) {\n\t\t\t\t\t\t$target.empty();\n\t\t\t\t\t\tlate = view.link(source, target, prevNode, nextNode, sourceValue, tag && {tag: tag._tgId});\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif (change = change || targetVal !== sourceValue) {\n\t\t\t\t\tif (attr === \"text\" && target.children && !target.children[0]) {\n\t\t\t\t\t\t// This code is faster then $target.text()\n\t\t\t\t\t\ttarget[TEXTCONTENT] = sourceValue === null ? \"\" : sourceValue;\n\t\t\t\t\t} else {\n\t\t\t\t\t\t$target[setter](sourceValue);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif ((jsvSel = targetParent._jsvSel)\n\t\t\t\t\t// Setting value of <option> element\n\t\t\t\t\t&& (attr === VALUE || !$target.attr(VALUE))) { // Setting value attribute, or setting textContent if attribute is null\n\t\t\t\t\t// Set/unselect selection based on value set on parent <select>. Works for multiselect too\n\t\t\t\t\ttarget.selected = $inArray(\"\" + sourceValue, $isArray(jsvSel) ? jsvSel : [jsvSel]) > -1;\n\t\t\t\t}\n\t\t\t}\n\t\t} else if (change = change || targetVal !== sourceValue) {\n\t\t\t// Setting an attribute to undefined should remove the attribute\n\t\t\t$target[useProp ? \"prop\" : \"attr\"](attr, sourceValue === undefined && !useProp ? null : sourceValue);\n\t\t}\n\t}\n\tlinkCtx._val = sourceValue;\n\tlateLink(late); // Do any deferred linking (lateRender)\n\treturn change;\n}\n\nfunction arrayChangeHandler(ev, eventArgs) { // array change handler for 'array' views\n\tvar self = this,\n\t\tonBeforeChange = changeHandler(self, onBeforeChangeStr, self.tag),\n\t\tonAfterChange = changeHandler(self, onAfterChangeStr, self.tag);\n\tif (!onBeforeChange || onBeforeChange.call(self, ev, eventArgs) !== false) {\n\t\tif (eventArgs) {\n\t\t\t// This is an observable action (not a trigger/handler call from pushValues, or similar, for which eventArgs will be null)\n\t\t\tvar action = eventArgs.change,\n\t\t\t\tindex = eventArgs.index,\n\t\t\t\titems = eventArgs.items;\n\t\t\tself._.srt = eventArgs.refresh; // true if part of a 'sort' on refresh\n\t\t\tswitch (action) {\n\t\t\t\tcase \"insert\":\n\t\t\t\t\tself.addViews(index, items);\n\t\t\t\t\tbreak;\n\t\t\t\tcase \"remove\":\n\t\t\t\t\tself.removeViews(index, items.length);\n\t\t\t\t\tbreak;\n\t\t\t\tcase \"move\":\n\t\t\t\t\tself.moveViews(eventArgs.oldIndex, index, items.length);\n\t\t\t\t\tbreak;\n\t\t\t\tcase \"refresh\":\n\t\t\t\t\tself._.srt = undefined;\n\t\t\t\t\tself.fixIndex(0);\n\t\t\t\t\t// Other cases: (e.g.undefined, for setProperty on observable object) etc. do nothing\n\t\t\t}\n\t\t}\n\t\tif (onAfterChange) {\n\t\t\tonAfterChange.call(self, ev, eventArgs);\n\t\t}\n\t}\n}\n\n//=============================\n// Utilities for event handlers\n//=============================\n\nfunction setArrayChangeLink(view) {\n\t// Add/remove arrayChange handler on view\n\tvar handler, arrayBinding,\n\t\ttype = view.type, // undefined if view is being removed\n\t\tdata = view.data,\n\t\tbound = view._.bnd; // true for top-level link() or data-link=\"{for}\", or the for tag instance for {^{for}} (or for any custom tag that has an onArrayChange handler)\n\n\tif (!view._.useKey && bound) {\n\t\t// This is an array view. (view._.useKey not defined => data is array), and is data-bound to collection change events\n\n\t\tif (arrayBinding = view._.bndArr) {\n\t\t\t// First remove the current handler if there is one\n\t\t\t$([arrayBinding[1]]).off(arrayChangeStr, arrayBinding[0]);\n\t\t\tview._.bndArr = undefined;\n\t\t}\n\t\tif (bound !== !!bound) {\n\t\t\t// bound is not a boolean, so it is the data-linked tag that 'owns' this array binding - e.g. {^{for...}}\n\t\t\tif (type) {\n\t\t\t\tbound._.arrVws[view._.id] = view;\n\t\t\t} else {\n\t\t\t\tdelete bound._.arrVws[view._.id]; // if view.type is undefined, view is being removed\n\t\t\t}\n\t\t} else if (type && data) {\n\t\t\t// If this view is not being removed, but the data array has been replaced, then bind to the new data array\n\t\t\thandler = function(ev) {\n\t\t\t\tif (!(ev.data && ev.data.off)) {\n\t\t\t\t\t// Skip if !!ev.data.off: - a handler that has already been removed (maybe was on handler collection at call time - then removed by another handler)\n\t\t\t\t\t// If view.type is undefined, do nothing. (Corresponds to case where there is another handler on the same data whose\n\t\t\t\t\t// effect was to remove this view, and which happened to precede this event in the trigger sequence. So although this\n\t\t\t\t\t// event has been removed now, it is still called since already on the trigger sequence)\n\t\t\t\t\tarrayChangeHandler.apply(view, arguments);\n\t\t\t\t}\n\t\t\t};\n\t\t\t$([data]).on(arrayChangeStr, handler);\n\t\t\tview._.bndArr = [handler, data];\n\t\t}\n\t}\n}\n\nfunction defaultAttr(elem, to, linkGetVal) {\n\t// to: true - default attribute for setting data value on HTML element; false: default attribute for getting value from HTML element\n\t// Merge in the default attribute bindings for this target element\n\tvar nodeName = elem.nodeName.toLowerCase(),\n\t\tattr =\n\t\t\t$subSettingsAdvanced._fe[nodeName] // get form element binding settings for input textarea select or optgroup\n\t\t\t|| elem.contentEditable === TRUE && {to: HTML, from: HTML}; // Or if contentEditable set to \"true\" set attr to \"html\"\n\treturn attr\n\t\t? (to\n\t\t\t? ((nodeName === \"input\" && elem.type === RADIO) // For radio buttons, bind from value, but bind to 'radio' - special value.\n\t\t\t\t? RADIO\n\t\t\t\t: attr.to)\n\t\t\t: attr.from)\n\t\t: to\n\t\t\t? linkGetVal ? \"text\" : HTML // Default innerText for data-link=\"a.b.c\" or data-link=\"{:a.b.c}\" (with or without converters)- otherwise innerHTML\n\t\t\t: \"\"; // Default is not to bind from\n}\n\n//==============================\n// Rendering and DOM insertion\n//==============================\n\nfunction renderAndLink(view, index, tmpl, views, data, context, refresh) {\n\tvar html, linkToNode, prevView, nodesToRemove, bindId,\n\t\tparentNode = view.parentElem,\n\t\tprevNode = view._prv,\n\t\tnextNode = view._nxt,\n\t\telCnt = view._elCnt;\n\n\tif (prevNode && prevNode.parentNode !== parentNode) {\n\t\terror(\"Missing parentNode\");\n\t\t// Abandon, since node has already been removed, or wrapper element has been inserted between prevNode and parentNode\n\t}\n\n\tif (refresh) {\n\t\tnodesToRemove = view.nodes();\n\t\tif (elCnt && prevNode && prevNode !== nextNode) {\n\t\t\t// This prevNode will be removed from the DOM, so transfer the view tokens on prevNode to nextNode of this 'viewToRefresh'\n\t\t\ttransferViewTokens(prevNode, nextNode, parentNode, view._.id, \"_\", true);\n\t\t}\n\t\t// Remove child views\n\t\tview.removeViews(undefined, undefined, true);\n\t\tlinkToNode = nextNode;\n\n\t\tif (elCnt) {\n\t\t\tprevNode = prevNode\n\t\t\t\t? prevNode.previousSibling\n\t\t\t\t: nextNode\n\t\t\t\t\t? nextNode.previousSibling\n\t\t\t\t\t: parentNode.lastChild;\n\t\t}\n\n\t\t// Remove HTML nodes\n\t\t$(nodesToRemove).remove();\n\n\t\tfor (bindId in view._.bnds) {\n\t\t\t// The view bindings may have already been removed above in: $(nodesToRemove).remove();\n\t\t\t// If not, remove them here:\n\t\t\tremoveViewBinding(bindId);\n\t\t}\n\t} else {\n\t\t// addViews. Only called if view is of type \"array\"\n\t\tif (index) {\n\t\t\t// index is a number, so indexed view in view array\n\t\t\tprevView = views[index - 1];\n\t\t\tif (!prevView) {\n\t\t\t\treturn false; // If subview for provided index does not exist, do nothing\n\t\t\t}\n\t\t\tprevNode = prevView._nxt;\n\t\t}\n\t\tif (elCnt) {\n\t\t\tlinkToNode = prevNode;\n\t\t\tprevNode = linkToNode\n\t\t\t\t? linkToNode.previousSibling         // There is a linkToNode, so insert after previousSibling, or at the beginning\n\t\t\t\t: parentNode.lastChild;              // If no prevView and no prevNode, index is 0 and the container is empty,\n\t\t\t\t// so prevNode = linkToNode = null. But if prevView._nxt is null then we set prevNode to parentNode.lastChild\n\t\t\t\t// (which must be before the prevView) so we insert after that node - and only link the inserted nodes\n\t\t} else {\n\t\t\tlinkToNode = prevNode.nextSibling;\n\t\t}\n\t}\n\thtml = tmpl.render(data, context, view._.useKey && refresh, view, refresh || index, true);\n\t// Pass in view._.useKey as test for noIteration (which corresponds to when self._.useKey > 0 and self.data is an array)\n\n\t// Link the new HTML nodes to the data\n\tlateLink(view.link(data, parentNode, prevNode, linkToNode, html, prevView));\n}\n\n//=====================\n// addBindingMarkers\n//=====================\n\nfunction addBindingMarkers(value, view, tag) {\n\t// Insert binding markers into the rendered template output, which will get converted to appropriate\n\t// data-jsv attributes (element-only content) or script marker nodes (phrasing or flow content), in convertMarkers,\n\t// within view.link, prior to inserting into the DOM. Linking will then bind based on these markers in the DOM.\n\t// Added view markers: #m_...VIEW.../m_\n\t// Added tag markers: #m^...TAG..../m^\n\tvar id, end;\n\tif (tag) {\n\t\t// This is a binding marker for a data-linked tag {^{...}}\n\t\tend = \"^`\";\n\t\taddLinkMethods(tag); // This is {^{>...}} or {^{tag ...}}, {{cvt:...} or {^{:...}}, and tag was defined in convertVal or renderTag\n\t\tid = tag._tgId;\n\t\tif (!id) {\n\t\t\tbindingStore[id = bindingKey++] = tag; // Store the tag temporarily, ready for databinding.\n\t\t\t// During linking, in addDataBinding, the tag will be attached to the linkCtx,\n\t\t\t// and then in observeAndBind, bindingStore[bindId] will be replaced by binding info.\n\t\t\ttag._tgId = \"\" + id;\n\t\t}\n\t} else {\n\t\t// This is a binding marker for a view\n\t\t// Add the view to the store of current linked views\n\t\tend = \"_`\";\n\t\tviewStore[id = view._.id] = view;\n\t}\n\t// Example: \"#23^TheValue/23^\"\n\treturn \"#\" + id + end\n\t\t+ (value != undefined ? value : \"\") // For {^{:name}} this gives the equivalent semantics to compiled\n\t\t\t\t\t\t\t\t\t\t\t// (v=data.name)!=null?v:\"\"; used in {{:name}} or data-link=\"name\"\n\t\t+ \"/\" + id + end;\n}\n\n//==============================\n// Data-linking and data binding\n//==============================\n\n//---------------\n// observeAndBind\n//---------------\n\nfunction observeAndBind(linkCtx, source, target) {\n\tvar binding, l, k, linkedElem, exprFnDeps, exprOb, prop, propDeps, depends, tagDepends, bindId, linkedElems,\n\t\ttag = linkCtx.tag,\n\t\tcvtBk = linkCtx.convertBack,\n\t\thandler = linkCtx._hdl;\n\tsource = typeof source === \"object\" && source; // If not an object set to false\n\n\tif (tag) {\n\t\t// Use the 'depends' paths set on linkCtx.tag, or on the converter\n\t\t// - which may have been set on declaration or in events: init, render, onAfterLink etc.\n\t\tif (depends = tag.convert) {\n\t\t\tdepends = depends === TRUE ? tag.tagCtx.props.convert : depends;\n\t\t\tdepends = linkCtx.view.getRsc(\"converters\", depends) || depends;\n\t\t\tdepends = depends && depends.depends;\n\t\t\tdepends = depends && $sub._dp(depends, source, handler); // dependsPaths\n\t\t}\n\t\tif (tagDepends = tag.tagCtx.props.depends || tag.depends) {\n\t\t\ttagDepends = $sub._dp(tagDepends, tag, handler);\n\t\t\tdepends = depends ? depends.concat(tagDepends) : tagDepends;\n\t\t}\n\t\tlinkedElems = tag.linkedElems;\n\t}\n\tdepends = depends || [];\n\tif (!linkCtx._depends || (\"\" + linkCtx._depends !== \"\" + depends)) {\n\t\t// Only bind the first time, or if the new depends (toString) has changed from when last bound\n\n\t\texprFnDeps = linkCtx.fn.deps.slice(); // Make a copy of the dependency paths for the compiled linkCtx expression - to pass to observe(). In getInnerCb(),\n\t\t// (and whenever the object is updated, in innerCb), we will set exprOb.ob to the current object returned by that computed expression, for this view.\n\n\t\tif (linkCtx._depends) {\n\t\t\tbindId = linkCtx._depends.bdId;\n\t\t\t// Unobserve previous binding\n\t\t\t$observable._apply(1, [source], exprFnDeps, linkCtx._depends, handler, linkCtx._ctxCb, true);\n\t\t}\n\n\t\tif (tag) {\n\t\t\t// Add dependency paths for declared boundProps (so no need to write ^myprop=... to get binding) and for linkedProp too if there is one\n\t\t\tl = tag.boundProps.length;\n\t\t\twhile (l--) {\n\t\t\t\tprop = tag.boundProps[l];\n\t\t\t\tk = tag._.bnd.paths.length;\n\t\t\t\twhile (k--) { // Iterate across tagCtxs\n\t\t\t\t\tpropDeps = tag._.bnd.paths[k][\"_\" + prop];\n\t\t\t\t\tif (propDeps && propDeps.length && propDeps.skp) { // Not already a bound prop ^prop=expression;\n\t\t\t\t\t\texprFnDeps = exprFnDeps.concat(propDeps); // Add dependencies for this prop expression\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tl = exprFnDeps.length;\n\t\twhile (l--) {\n\t\t\texprOb = exprFnDeps[l];\n\t\t\tif (exprOb._cpfn) {\n\t\t\t\t// This path is an 'exprOb', corresponding to a computed property returning an object. We replace the exprOb by\n\t\t\t\t// a view-binding-specific exprOb instance. The current object will be stored as exprOb.ob.\n\t\t\t\texprFnDeps[l] = $extend({}, exprOb);\n\t\t\t}\n\t\t}\n\t\tbinding = $observable._apply(\n\t\t\t1, // Use as 'this' pointer - arbitrary\n\t\t\t[source],\n\t\t\texprFnDeps, // flatten the paths - to gather all the dependencies across args and bound params\n\t\t\tdepends,\n\t\t\thandler,\n\t\t\tlinkCtx._ctxCb);\n\t\t// The binding returned by $observe has a bnd array with the source objects of the individual bindings.\n\n\t\tif (!bindId) {\n\t\t\tbindId = linkCtx._bndId || \"\" + bindingKey++;\n\t\t\tlinkCtx._bndId = undefined;\n\t\t\t// Store the binding key on the view and on the element, for disposal when the view is removed\n\t\t\ttarget._jsvBnd = (target._jsvBnd || \"\") + \"&\" + bindId;\n\t\t\tlinkCtx.view._.bnds[bindId] = bindId;\n\t\t}\n\n\t\tbinding.elem = target; // The target of all the individual bindings\n\t\tbinding.linkCtx = linkCtx;\n\t\tbinding._tgId = bindId;\n\n\t\tdepends.bdId = bindId;\n\t\tlinkCtx._depends = depends;\n\t\t// Store the binding.\n\t\tbindingStore[bindId] = binding; // Note: If this corresponds to a data-linked tag, we are replacing the\n\t\t// temporarily stored tag by the stored binding. The tag will now be at binding.linkCtx.tag\n\n\t\tif (linkedElems || cvtBk !== undefined || tag && tag.bindTo) {\n\t\t\tdefineBindToDataTargets(binding, tag, cvtBk);\n\t\t}\n\t\tif (linkedElems) {\n\t\t\tl = linkedElems.length;\n\t\t\twhile (l--) {\n\t\t\t\tlinkedElem = linkedElems[l];\n\t\t\t\tk = linkedElem && linkedElem.length;\n\t\t\t\twhile (k--) {\n\t\t\t\t\tlinkedElem[k]._jsvLkEl = tag;\n\t\t\t\t\tbindLinkedElChange(tag, linkedElem[k]);\n\t\t\t\t\tlinkedElem[k]._jsvBnd = \"&\" + bindId + \"+\"; // Add a \"+\" for cloned binding - so removing\n\t\t\t\t\t// elems with cloned bindings will not remove the 'parent' binding from the bindingStore.\n\t\t\t\t}\n\t\t\t}\n\t\t} else if (cvtBk !== undefined) {\n\t\t\tbindLinkedElChange(tag, target);\n\t\t}\n\n\t\tif (tag && !tag.inline) {\n\t\t\tif (!tag.flow) {\n\t\t\t\ttarget.setAttribute(jsvAttrStr, (target.getAttribute(jsvAttrStr)||\"\") + \"#\" + bindId + \"^/\" + bindId + \"^\");\n\t\t\t}\n\t\t\ttag._tgId = \"\" + bindId;\n\t\t}\n\t}\n}\n\n//-------\n// $.link\n//-------\n\nfunction lateLink(late) {\n\t// Do any deferred linking (lateRender)\n\tvar lnkCtx;\n\tif (late) {\n\t\twhile (lnkCtx = late.pop()) {\n\t\t\tlnkCtx._hdl();\n\t\t}\n\t}\n}\n\nfunction tmplLink(to, from, context, noIteration, parentView, prevNode, nextNode) {\n\treturn $link(this, to, from, context, noIteration, parentView, prevNode, nextNode);\n}\n\nfunction $link(tmplOrLinkExpr, to, from, context, noIteration, parentView, prevNode, nextNode) {\n\t// When linking from a template, prevNode and nextNode parameters are ignored\n\tif (context === true) {\n\t\tnoIteration = context; // passing boolean as third param - noIteration\n\t\tcontext = undefined;\n\t} else if (typeof context !== \"object\") {\n\t\tcontext = undefined; // context must be a boolean (noIteration) or a plain object\n\t} else {\n\t\tcontext = $extend({}, context);\n\t}\n\tif (tmplOrLinkExpr && to) {\n\t\tto = to.jquery ? to : $(to); // to is a jquery object or an element or selector\n\n\t\tif (!activeBody) {\n\t\t\tactiveBody = document.body;\n\t\t\tuseInput = \"oninput\" in activeBody;\n\t\t\t$(activeBody)\n\t\t\t\t.on(elementChangeStr, onElemChange)\n\t\t\t\t.on('blur.jsv', '[contenteditable]', onElemChange);\n\t\t}\n\n\t\tvar i, k, html, vwInfos, view, placeholderParent, targetEl, refresh, topLevelCall, late,\n\t\t\tonRender = addBindingMarkers,\n\t\t\treplaceMode = context && context.target === \"replace\",\n\t\t\tl = to.length;\n\n\t\twhile (l--) { // iterate over 'to' targets. (Usually one, but can be multiple)\n\t\t\ttargetEl = to[l];\n\n\t\t\tparentView = parentView || $view(targetEl);\n\t\t\tif (topLevelCall = parentView === topView) {\n\t\t\t\ttopView.data = (topView.ctx = context || {}).root = from;\n\t\t\t}\n\t\t\tif (\"\" + tmplOrLinkExpr === tmplOrLinkExpr) {\n\t\t\t\t// tmplOrLinkExpr is a string: treat as data-link expression.\n\t\t\t\taddDataBinding(late = [], tmplOrLinkExpr, targetEl, parentView, undefined, \"expr\", from, context);\n\t\t\t} else {\n\t\t\t\tif (tmplOrLinkExpr.markup !== undefined) {\n\t\t\t\t\t// This is a call to template.link()\n\t\t\t\t\tif (replaceMode) {\n\t\t\t\t\t\tplaceholderParent = targetEl.parentNode;\n\t\t\t\t\t}\n\t\t\t\t\tparentView._.scp = true; // Set scope flag on parentView for link() call - used to set view.isTop for outermost view of created linked content\n\t\t\t\t\thtml = tmplOrLinkExpr.render(from, context, noIteration, parentView, undefined, onRender, true);\n\t\t\t\t\tparentView._.scp = undefined;\n\t\t\t\t\t// TODO Consider finding a way to bind data (link) within template without html being different for each view, the HTML can\n\t\t\t\t\t// be evaluated once outside the while (l--), and pushed into a document fragment, then cloned and inserted at each target.\n\n\t\t\t\t\tif (placeholderParent) {\n\t\t\t\t\t\t// This is target=\"replace\" mode\n\t\t\t\t\t\tprevNode = targetEl.previousSibling;\n\t\t\t\t\t\tnextNode = targetEl.nextSibling;\n\t\t\t\t\t\t$.cleanData([targetEl], true);\n\t\t\t\t\t\tplaceholderParent.removeChild(targetEl);\n\n\t\t\t\t\t\ttargetEl = placeholderParent;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tprevNode = nextNode = undefined; // When linking from a template, prevNode and nextNode parameters are ignored\n\t\t\t\t\t\t$(targetEl).empty();\n\t\t\t\t\t}\n\t\t\t\t} else if (tmplOrLinkExpr === true && parentView === topView) {\n\t\t\t\t\t// $.link(true, selector, data, ctx) - where selector points to elem in top-level content. (If not top-level content, no-op)\n\t\t\t\t\trefresh = {lnk: \"top\"};\n\t\t\t\t} else {\n\t\t\t\t\tbreak; // no-op - $.link(true, selector, data, ctx) targeting within previously linked rendered template\n\t\t\t\t}\n\n// TODO Consider deferred linking API feature on per-template basis - {@{ instead of {^{ which allows the user to see the rendered content\n// before that content is linked, with better perceived perf. Have view.link return a deferred, and pass that to onAfterLink...\n// or something along those lines.\n// setTimeout(function() {\n\n\t\t\t\tif (targetEl._df && !nextNode) {\n\t\t\t\t\t// We are inserting new content and the target element has some deferred binding annotations,and there is no nextNode.\n\t\t\t\t\t// Those views may be stale views (that will be recreated in this new linking action) so we will first remove them\n\t\t\t\t\t// (if not already removed).\n\t\t\t\t\tvwInfos = viewInfos(targetEl._df, true, rOpenViewMarkers);\n\n\t\t\t\t\tfor (i = 0, k = vwInfos.length; i < k; i++) {\n\t\t\t\t\t\tview = vwInfos[i];\n\t\t\t\t\t\tif ((view = viewStore[view.id]) && view.data !== undefined) {\n\t\t\t\t\t\t\t// If this is the _prv (prevNode) for a view, remove the view\n\t\t\t\t\t\t\t// - unless view.data is undefined, in which case it is already being removed\n\t\t\t\t\t\t\tview.parent.removeViews(view._.key, undefined, true);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tsetDefer(targetEl); // remove defer tokens\n\t\t\t\t}\n\n\t\t\t\t// Link the content of the element, since this is a call to template.link(), or to $(el).link(true, ...),\n\t\t\t\tlate = parentView.link(from, targetEl, prevNode, nextNode, html, refresh, context);\n//});\n\t\t\t}\n\t\t\tlateLink(late); // Do any deferred linking (lateRender)\n\t\t}\n\t}\n\treturn to; // Allow chaining, to attach event handlers, etc.\n}\n\n//----------\n// view.link\n//----------\n\nfunction viewLink(outerData, parentNode, prevNode, nextNode, html, refresh, context, validateOnly) {\n\t// Optionally insert HTML into DOM using documentFragments (and wrapping HTML appropriately).\n\t// Data-link existing contents of parentNode, or the inserted HTML, if provided\n\n\t// Depending on the content model for the HTML elements, the standard data-linking markers inserted in the HTML by addBindingMarkers during\n\t// template rendering will be converted either to script marker nodes or, for element-only content sections, to data-jsv element annotations.\n\n\t// Data-linking will then add _prv and _nxt to views, where:\n\t//     _prv: References the previous node (script element of type \"jsv123\"), or (for elCnt=true), the first element node in the view (or if none, set _prv = _nxt)\n\t//     _nxt: References the last node (script element of type \"jsv/123\"), or (for elCnt=true), the next element node after the view.\n\n\t//==== nested functions ====\n\tfunction convertMarkers(all, preceding, selfClose, closeTag, spaceBefore, id, boundId, spaceAfter, tag1, tag2, closeTag2, spaceAfterClose, selfClose2, endOpenTag) {\n\t\t// rConvertMarkers = /(^|(\\/>)|<\\/(\\w+)>|)(\\s*)([#/]\\d+(?:_|(\\^)))`(\\s*)(<\\w+(?=[\\s\\/>]))?|\\s*(?:(<\\w+(?=[\\s\\/>]))|<\\/(\\w+)>(\\s*)|(\\/>)\\s*|(>))/g,\n\t\t//                 prec, slfCl, clsTag,  spBefore, id,      bndId  spAfter,tag1,                   tag2,               clTag2,sac  slfCl2, endOpenTag\n\t\t// Convert the markers that were included by addBindingMarkers in template output, to appropriate DOM annotations:\n\t\t// data-jsv attributes (for element-only content) or script marker nodes (within phrasing or flow content).\n\n// TODO consider detecting 'quoted' contexts (attribute strings) so that attribute encoding does not need to encode >\n// Currently rAttrEncode = /[><\"'&]/g includes '>' encoding in order to avoid erroneous parsing of <span title=\"&lt;a/>\"></span>\">\n\t\tvar errorMsg, bndId,\n\t\t\tendOfElCnt = \"\";\n\t\tif (endOpenTag) {\n\t\t\tinTag = 0;\n\t\t\treturn all;\n\t\t}\n\t\ttag = (tag1 || tag2 || \"\").toLowerCase();\n\t\tcloseTag = closeTag || closeTag2;\n\t\tselfClose = selfClose || selfClose2;\n\t\tif (isVoid && !selfClose && (!all || closeTag || tag || id && !inTag)) { // !all = end of string\n\t\t\tisVoid = undefined;\n\t\t\tparentTag = tagStack.shift(); // preceding tag was a void element, with no closing slash, such as <br>.\n\t\t}\n\t\tcloseTag = closeTag || selfClose;\n\t\tif (closeTag) {\n\t\t\tcloseTag = closeTag.toLowerCase();\n\t\t\tinTag = 0;\n\t\t\tisVoid = undefined;\n\t\t\t// TODO: smart insertion of <tbody> - to be completed for robust insertion of deferred bindings etc.\n\t\t\t//if (closeTag === \"table\" && parentTag === \"tbody\") {\n\t\t\t//\tpreceding = \"</tbody>\" + preceding;\n\t\t\t//\tparentTag = \"table\";\n\t\t\t//\ttagStack.shift();\n\t\t\t//}\n\t\t\tif (validate) {\n\t\t\t\tif (selfClose || selfClose2) {\n\t\t\t\t\tif (!voidElems[parentTag] && !/;svg;|;math;/.test(\";\" + tagStack.join(\";\") + \";\")) {\n\t\t\t\t\t\t// Only self-closing elements must be legitimate void elements, such as <br/>, per HTML schema,\n\t\t\t\t\t\t// or under svg or math foreign namespace elements.\n\t\t\t\t\t\terrorMsg = \"'<\" + parentTag + \".../\";\n\t\t\t\t\t}\n\t\t\t\t} else if (voidElems[closeTag]) {\n\t\t\t\t\terrorMsg = \"'</\" + closeTag; // closing tag such as </input>\n\t\t\t\t} else if (!tagStack.length || closeTag !== parentTag) {\n\t\t\t\t\terrorMsg = \"Mismatch: '</\" + closeTag;\n\t\t\t\t}\n\t\t\t\tif (errorMsg) {\n\t\t\t\t\tsyntaxError(errorMsg + \">' in:\\n\" + html);\n\t\t\t\t}\n\t\t\t}\n\t\t\tprevElCnt = elCnt;\n\t\t\tparentTag = tagStack.shift();\n\t\t\telCnt = elContent[parentTag];\n\t\t\tcloseTag2 = closeTag2 ? (\"</\" + closeTag2 + \">\") : \"\";\n\t\t\tif (prevElCnt) {\n\t\t\t\t// If there are ids (markers since the last tag), move them to the defer string\n\t\t\t\tdefer += ids;\n\t\t\t\tids = \"\";\n\t\t\t\tif (!elCnt) {\n\t\t\t\t\tendOfElCnt = closeTag2 + openScript + \"@\" + defer + closeScript + (spaceAfterClose || \"\");\n\t\t\t\t\tdefer = deferStack.shift();\n\t\t\t\t} else {\n\t\t\t\t\tdefer += \"-\"; // Will be used for stepping back through deferred tokens\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (elCnt) {\n\t\t\t// elContent maps tagNames which have only element content, so may not support script nodes.\n\t\t\t// We are in element-only content, can remove white space, and use data-jsv attributes on elements as markers\n\t\t\t// Example: <tr data-jsv=\"/2_#6_\"> - close marker for view 2 and open marker for view 6\n\n\t\t\tif (id) {\n\t\t\t\t// append marker for this id, to ids string\n\t\t\t\tids += id;\n\t\t\t} else {\n\t\t\t\tpreceding = (closeTag2 || selfClose2 || \"\");\n\t\t\t}\n\t\t\tif (tag) {\n\t\t\t\t// TODO: smart insertion of <tbody> - to be completed for robust insertion of deferred bindings etc.\n\t\t\t\t//if (tag === \"<tr\" && parentTag === \"table\") {\n\t\t\t\t//\ttagStack.unshift(parentTag);\n\t\t\t\t//\tparentTag = \"tbody\";\n\t\t\t\t//\tpreceding += \"<\" + parentTag + \">\";\n\t\t\t\t//\tif (defer) {\n\t\t\t\t//\t\tdefer += \"+\"; // Will be used for stepping back through deferred tokens\n\t\t\t\t//\t}\n\t\t\t\t//\t// TODO: move this to design-time validation check\n\t\t\t\t//\t//\terror('\"' + parentTag + '\" has incorrect parent tag');\n\t\t\t\t//}\n\t\t\t\tpreceding += tag;\n\t\t\t\tif (ids) {\n\t\t\t\t\tpreceding += ' ' + jsvAttrStr + '=\"' + ids + '\"';\n\t\t\t\t\tids = \"\";\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\t// We are in phrasing or flow content, so use script marker nodes\n\t\t\t// Example: <script type=\"jsv3/\"></script> - data-linked tag, close marker\n\t\t\t// We validate with inTag so no script markers are inserted in attribute context e.g. for:\n\t\t\t// \"<table {{if ...}}...{{/if}}... >\" or \"<table {{if ...}}...> ...{{/if}}...\"\n\t\t\tpreceding = id\n\t\t\t\t? (preceding + endOfElCnt + spaceBefore + (inTag ? \"\" : openScript + id + closeScript)+ spaceAfter + tag)\n\t\t\t\t: endOfElCnt || all;\n\t\t}\n\n\t\tif (validate && boundId) {\n\t\t\tif (inTag) {\n\t\t\t\t// JsViews data-linking tags are not allowed within element markup.\n\t\t\t\t// See jsviews/issues/303\n\t\t\t\tsyntaxError('{^{ within elem markup (' + inTag + ' ). Use data-link=\"...\"');\n\t\t\t}\n\t\t\tif (id.charAt(0) === \"#\") {\n\t\t\t\ttagStack.unshift(id.slice(1));\n\t\t\t} else if (id.slice(1) !== (bndId = tagStack.shift())) {\n\t\t\t\t// See jsviews/issues/213\n\t\t\t\tsyntaxError('Closing tag for {^{...}} under different elem: <' + bndId + '>');\n\t\t\t}\n\t\t}\n\t\tif (tag) {\n\t\t\tinTag = tag;\n\t\t\t// If there are ids (markers since the last tag), move them to the defer string\n\t\t\ttagStack.unshift(parentTag);\n\t\t\tparentTag = tag.slice(1);\n\t\t\tif (validate && tagStack[0] && tagStack[0] === badParent[parentTag]) {\n\t\t\t\t// Missing <tbody>\n\t\t\t\t// TODO: replace this by smart insertion of <tbody> tags\n\t\t\t\terror('Parent of <tr> must be <tbody>');\n\t\t\t}\n\t\t\tisVoid = voidElems[parentTag];\n\t\t\tif ((elCnt = elContent[parentTag]) && !prevElCnt) {\n\t\t\t\tdeferStack.unshift(defer);\n\t\t\t\tdefer = \"\";\n\t\t\t}\n\t\t\tprevElCnt = elCnt;\n//TODO Consider providing validation which throws if you place <span> as child of <tr>, etc. - since if not caught,\n//this can cause errors subsequently which are difficult to debug.\n//\t\t\t\tif (elContent[tagStack[0]]>2 && !elCnt) {\n//\t\t\t\t\terror(parentTag + \" in \" + tagStack[0]);\n//\t\t\t\t}\n\t\t\tif (defer && elCnt) {\n\t\t\t\tdefer += \"+\"; // Will be used for stepping back through deferred tokens\n\t\t\t}\n\t\t}\n\t\treturn preceding;\n\t}\n\n\tfunction processViewInfos(vwInfos, targetParent) {\n\t\t// If targetParent, we are processing viewInfos (which may include navigation through '+-' paths) and hooking up to the right parentElem etc.\n\t\t// (and elem may also be defined - the next node)\n\t\t// If no targetParent, then we are processing viewInfos on newly inserted content\n\t\tvar deferPath, deferChar, bindChar, parentElem, id, onAftCr, deep,\n\t\t\taddedBindEls = [];\n\n\t\t// In elCnt context (element-only content model), prevNode is the first node after the open, nextNode is the first node after the close.\n\t\t// If both are null/undefined, then open and close are at end of parent content, so the view is empty, and its placeholder is the\n\t\t// 'lastChild' of the parentNode. If there is a prevNode, then it is either the first node in the view, or the view is empty and\n\t\t// its placeholder is the 'previousSibling' of the prevNode, which is also the nextNode.\n\t\tif (vwInfos) {\n\t\t\tif (vwInfos._tkns.charAt(0) === \"@\") {\n\t\t\t\t// We are processing newly inserted content. This is a special script element that was created in convertMarkers() to process deferred bindings,\n\t\t\t\t// and inserted following the target parent element - because no element tags (outside elCnt) were encountered to carry those binding tokens.\n\t\t\t\t// We will step back from the preceding sibling of this element, looking at targetParent elements until we find the one that the current binding\n\t\t\t\t// token belongs to. Set elem to null (the special script element), and remove it from the DOM.\n\t\t\t\ttargetParent = elem.previousSibling;\n\t\t\t\telem.parentNode.removeChild(elem);\n\t\t\t\telem = undefined;\n\t\t\t}\n\t\t\tlen = vwInfos.length;\n\t\t\twhile (len--) {\n\t\t\t\tvwInfo = vwInfos[len];\n//if (prevIds.indexOf(vwInfo.token) < 0) { // This token is a newly created view or tag binding\n\t\t\t\tbindChar = vwInfo.ch;\n\t\t\t\tif (deferPath = vwInfo.path) {\n\t\t\t\t\t// We have a 'deferred path'\n\t\t\t\t\tj = deferPath.length - 1;\n\t\t\t\t\twhile (deferChar = deferPath.charAt(j--)) {\n\t\t\t\t\t\t// Use the \"+\" and\"-\" characters to navigate the path back to the original parent node where the deferred bindings ocurred\n\t\t\t\t\t\tif (deferChar === \"+\") {\n\t\t\t\t\t\t\tif (deferPath.charAt(j) === \"-\") {\n\t\t\t\t\t\t\t\tj--;\n\t\t\t\t\t\t\t\ttargetParent = targetParent.previousSibling;\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\ttargetParent = targetParent.parentNode;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\ttargetParent = targetParent.lastChild;\n\t\t\t\t\t\t}\n\t\t\t\t\t\t// Note: Can use previousSibling and lastChild, not previousElementSibling and lastElementChild,\n\t\t\t\t\t\t// since we have removed white space within elCnt. Hence support IE < 9\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (bindChar === \"^\") {\n\t\t\t\t\tif (tag = bindingStore[id = vwInfo.id]) {\n\t\t\t\t\t\t// The binding may have been deleted, for example in a different handler to an array collectionChange event\n\t\t\t\t\t\t// This is a tag binding\n\t\t\t\t\t\tdeep = targetParent && (!elem || elem.parentNode !== targetParent); // We are stepping back looking for the right targetParent,\n\t\t\t\t\t\t// or we are linking existing content and this element is in elCnt, not an immediate child of the targetParent.\n\t\t\t\t\t\tif (!elem || deep) {\n\t\t\t\t\t\t\ttag.parentElem = targetParent;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (vwInfo.elCnt && deep) {\n\t\t\t\t\t\t\t// With element only content, if there is no following element, or if the binding is deeper than the following element\n\t\t\t\t\t\t\t// then we need to set the open or close token as a deferred binding annotation on the parent\n\t\t\t\t\t\t\tsetDefer(targetParent, (vwInfo.open ? \"#\" : \"/\") + id + bindChar + (targetParent._df || \"\"));\n\t\t\t\t\t\t}\n\t\t\t\t\t\t// This is an open or close marker for a data-linked tag {^{...}}. Add it to bindEls.\n\t\t\t\t\t\taddedBindEls.push([deep ? null : elem, vwInfo]);\n\t\t\t\t\t}\n\t\t\t\t} else if (view = viewStore[id = vwInfo.id]) {\n\t\t\t\t\t// The view may have been deleted, for example in a different handler to an array collectionChange event\n\t\t\t\t\tif (!view.parentElem) {\n\t\t\t\t\t\t// If view is not already extended for JsViews, extend and initialize the view object created in JsRender, as a JsViews view\n\t\t\t\t\t\tview.parentElem = targetParent || elem && elem.parentNode || parentNode;\n\t\t\t\t\t\tview._.onRender = addBindingMarkers;\n\t\t\t\t\t\tview._.onArrayChange = arrayChangeHandler;\n\t\t\t\t\t\tsetArrayChangeLink(view);\n\t\t\t\t\t}\n\t\t\t\t\tparentElem = view.parentElem;\n\t\t\t\t\tif (vwInfo.open) {\n\t\t\t\t\t\t// This is an 'open view' node (preceding script marker node,\n\t\t\t\t\t\t// or if elCnt, the first element in the view, with a data-jsv annotation) for binding\n\t\t\t\t\t\tview._elCnt = vwInfo.elCnt;\n\t\t\t\t\t\tif (targetParent && !elem) {\n\t\t\t\t\t\t\tsetDefer(targetParent, \"#\" + id + bindChar + (targetParent._df || \"\"));\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t// No targetParent, so there is a ._nxt elem (and this is processing tokens on the elem)\n\t\t\t\t\t\t\tif (!view._prv) {\n\t\t\t\t\t\t\t\tsetDefer(parentElem, removeSubStr(parentElem._df, \"#\" + id + bindChar));\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tview._prv = elem;\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\t// This is a 'close view' marker node for binding\n\t\t\t\t\t\tif (targetParent && (!elem || elem.parentNode !== targetParent)) {\n\t\t\t\t\t\t\t// There is no ._nxt so add token to _df. It is deferred.\n\t\t\t\t\t\t\tsetDefer(targetParent, \"/\" + id + bindChar + (targetParent._df || \"\"));\n\t\t\t\t\t\t\tview._nxt = undefined;\n\t\t\t\t\t\t} else if (elem) {\n\t\t\t\t\t\t\t// This view did not have a ._nxt, but has one now, so token may be in _df, and must be removed. (No longer deferred)\n\t\t\t\t\t\t\tif (!view._nxt) {\n\t\t\t\t\t\t\t\tsetDefer(parentElem, removeSubStr(parentElem._df, \"/\" + id + bindChar));\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tview._nxt = elem;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (onAftCr = changeHandler(view, onAfterCreateStr) || onAfterCreate) {\n\t\t\t\t\t\t\tonAftCr.call(view.ctx.tag, view);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n//}\n\t\t\t\t}\n\t\t\t}\n\t\t\tlen = addedBindEls.length;\n\t\t\twhile (len--) {\n\t\t\t\t// These were added in reverse order to addedBindEls. We push them in BindEls in the correct order.\n\t\t\t\tbindEls.push(addedBindEls[len]);\n\t\t\t}\n\t\t}\n\t\treturn !vwInfos || vwInfos.elCnt;\n\t}\n\n\tfunction getViewInfos(vwInfos) {\n\t\t// Used by view.childTags() and tag.childTags()\n\t\t// Similar to processViewInfos in how it steps through bindings to find tags. Only finds data-linked tags.\n\t\tvar level, parentTag, named;\n\n\t\tif (vwInfos) {\n\t\t\tlen = vwInfos.length;\n\t\t\tfor (j = 0; j < len; j++) {\n\t\t\t\tvwInfo = vwInfos[j];\n\t\t\t\t// This is an open marker for a data-linked tag {^{...}}, within the content of the tag whose id is get.id. Add it to bindEls.\n\t\t\t\t// Note - if bindingStore[vwInfo.id]._is === \"tag\" then getViewInfos is being called too soon - during first linking pass\n\t\t\t\ttag = bindingStore[vwInfo.id];\n\t\t\t\tif (!tag._is && tag.linkCtx) {\n\t\t\t\t\tparentTag = tag = tag.linkCtx.tag;\n\t\t\t\t\tnamed = tag.tagName === tagName;\n\t\t\t\t\tif (!tag.flow || named) {\n\t\t\t\t\t\tif (!deep) {\n\t\t\t\t\t\t\tlevel = 1;\n\t\t\t\t\t\t\twhile (parentTag = parentTag.parent) {\n\t\t\t\t\t\t\t\tlevel++;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\ttagDepth = tagDepth || level; // The level of the first tag encountered.\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif ((deep || level === tagDepth) && (!tagName || named)) {\n\t\t\t\t\t\t\t// Filter on top-level or tagName as appropriate\n\t\t\t\t\t\t\ttags.push(tag);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tfunction dataLink() {\n\t\t//================ Data-link and fixup of data-jsv annotations ================\n\t\tvar j, index,\n\t\t\ttokens = \"\",\n\t\t\twrap = {},\n\t\t\tselector = linkViewsSel + (get ? \",[\" + deferAttr + \"]\" : \"\");\n\t\t\t// If a childTags() call, get = \",[\" + deferAttr + \"]\" - since we need to include elements that have a ._df expando for deferred tokens\n\n\t\telems = qsa ? parentNode.querySelectorAll(selector) : $(selector, parentNode).get();\n\t\tl = elems.length;\n\n\t\t// The prevNode will be in the returned query, since we called markPrevOrNextNode() on it.\n\t\t// But it may have contained nodes that satisfy the selector also.\n\t\tif (prevNode && prevNode.innerHTML) {\n\t\t\t// Find the last contained node of prevNode, to use as the prevNode - so we only link subsequent elems in the query\n\t\t\tprevNodes = qsa ? prevNode.querySelectorAll(selector) : $(selector, prevNode).get();\n\t\t\tprevNode = prevNodes.length ? prevNodes[prevNodes.length - 1] : prevNode;\n\t\t}\n\n\t\ttagDepth = 0;\n\t\tfor (i = 0; i < l; i++) {\n\t\t\telem = elems[i];\n\t\t\tif (prevNode && !found) {\n\t\t\t\t// If prevNode is set, not false, skip linking. If this element is the prevNode, set to false so subsequent elements will link.\n\t\t\t\tfound = (elem === prevNode);\n\t\t\t} else if (nextNode && elem === nextNode) {\n\t\t\t\t// If nextNode is set then break when we get to nextNode\n\t\t\t\tif (get) {\n\t\t\t\t\ttokens += markerNodeInfo(elem);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t} else if (elem.parentNode) {\n\t\t\t\t// elem has not been removed from DOM\n\t\t\t\tif (get) {\n\t\t\t\t\ttokens += markerNodeInfo(elem);\n\t\t\t\t\tif (elem._df) {\n\t\t\t\t\t\tj = i + 1;\n\t\t\t\t\t\twhile (j < l && elem.contains(elems[j])) {\n\t\t\t\t\t\t\tj++;\n\t\t\t\t\t\t}\n\t\t\t\t\t\t// Add deferred tokens after any tokens on descendant elements of this one\n\t\t\t\t\t\twrap[j-1] = elem._df;\n\t\t\t\t\t}\n\t\t\t\t\tif (wrap[i]) {\n\t\t\t\t\t\ttokens += wrap[i] || \"\";\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tif (isLink && (vwInfo = viewInfos(elem, undefined, rViewMarkers)) && (vwInfo = vwInfo[0])) {\n\t\t\t\t\t\t// If this is a link(trueOrString ...) call we will avoid re-binding to elems that are within template-rendered views\n\t\t\t\t\t\tskip = skip ? (vwInfo.id !== skip && skip) : vwInfo.open && vwInfo.id;\n\t\t\t\t\t}\n\t\t\t\t\tif (!skip && processInfos(viewInfos(elem))\n\t\t\t\t\t\t// If a link() call, processViewInfos() adds bindings to bindEls, and returns true for non-script nodes, for adding data-link bindings\n\t\t\t\t\t\t// If a childTags() call, getViewInfos returns array of tag bindings.\n\t\t\t\t\t\t\t&& elem.getAttribute($viewsLinkAttr)) {\n\t\t\t\t\t\tbindEls.push([elem]); // A data-linked element so add to bindEls too\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (get) {\n\t\t\ttokens += parentNode._df || \"\";\n\t\t\tif (index = tokens.indexOf(\"#\" + get.id) + 1) {\n\t\t\t\t// We are looking for view.childTags() or tag.childTags() - so start after the open token of the parent view or tag.\n\t\t\t\ttokens = tokens.slice(index + get.id.length);\n\t\t\t}\n\t\t\tindex = tokens.indexOf(\"/\" + get.id);\n\t\t\tif (index + 1) {\n\t\t\t\t// We are looking for view.childTags() or tag.childTags() - so don't look beyond the close token of the parent view or tag.\n\t\t\t\ttokens = tokens.slice(0, index);\n\t\t\t}\n\t\t\t// Call getViewInfos to add the found childTags to the tags array\n\t\t\tgetViewInfos(viewInfos(tokens, undefined, rOpenTagMarkers));\n\t\t}\n\n\t\tif (html === undefined && parentNode.getAttribute($viewsLinkAttr)) {\n\t\t\tbindEls.push([parentNode]); // Support data-linking top-level element directly (not within a data-linked container)\n\t\t}\n\n\t\t// Remove temporary marker script nodes they were added by markPrevOrNextNode\n\t\tunmarkPrevOrNextNode(prevNode, elCnt);\n\t\tunmarkPrevOrNextNode(nextNode, elCnt);\n\n\t\tif (get) {\n\t\t\treturn; // We have added childTags to the tags array, so we are done\n\t\t}\n\n\t\tif (elCnt && defer + ids) {\n\t\t\t// There are some views with elCnt, for which the open or close did not precede any HTML tag - so they have not been processed yet\n\t\t\telem = nextNode;\n\t\t\tif (defer) {\n\t\t\t\tif (nextNode) {\n\t\t\t\t\tprocessViewInfos(viewInfos(defer + \"+\", true), nextNode);\n\t\t\t\t} else {\n\t\t\t\t\tprocessViewInfos(viewInfos(defer, true), parentNode);\n\t\t\t\t}\n\t\t\t}\n\t\t\tprocessViewInfos(viewInfos(ids, true), parentNode);\n\t\t\t// If there were any tokens on nextNode which have now been associated with inserted HTML tags, remove them from nextNode\n\t\t\tif (nextNode) {\n\t\t\t\ttokens = nextNode.getAttribute(jsvAttrStr);\n\t\t\t\tif (l = tokens.indexOf(prevIds) + 1) {\n\t\t\t\t\ttokens = tokens.slice(l + prevIds.length - 1);\n\t\t\t\t}\n\t\t\t\tnextNode.setAttribute(jsvAttrStr, ids + tokens);\n\t\t\t}\n\t\t}\n\n// if (context.lazyLink) {\n// setTimeout(doLinking) (doLinking is function wrapper of following lines)\n// See Future tasks, and https://github.com/BorisMoore/jsviews/issues/368.\n// Could call context.lazyLink as callback, on async completion - or return promise.\n\t\t//================ Bind the data-linked elements and tags ================\n\t\tl = bindEls.length;\n\t\tfor (i = 0; i < l; i++) {\n\t\t\telem = bindEls[i];\n\t\t\tlinkInfo = elem[1];\n\t\t\telem = elem[0];\n\t\t\tif (linkInfo) {\n\t\t\t\tif (tag = bindingStore[linkInfo.id]) {\n\t\t\t\t\tif (linkCtx = tag.linkCtx) {\n\t\t\t\t\t\t// The tag may have been stored temporarily on the bindingStore - or may have already been replaced by the actual binding\n\t\t\t\t\t\ttag = linkCtx.tag;\n\t\t\t\t\t\ttag.linkCtx = linkCtx;\n\t\t\t\t\t}\n\t\t\t\t\tif (linkInfo.open) {\n\t\t\t\t\t\t// This is an 'open linked tag' binding annotation for a data-linked tag {^{...}}\n\t\t\t\t\t\tif (elem) {\n\t\t\t\t\t\t\ttag.parentElem = elem.parentNode;\n\t\t\t\t\t\t\ttag._prv = elem;\n\t\t\t\t\t\t}\n\t\t\t\t\t\ttag._elCnt = linkInfo.elCnt;\n\t\t\t\t\t\t// We data-link depth-first (\"on the way in\"), which is better for perf - and allows setting parent tags etc.\n\t\t\t\t\t\tview = tag.tagCtx.view;\n\n\t\t\t\t\t\t// Add data binding (unless skipped due to lateRender)\n\t\t\t\t\t\taddDataBinding(late, undefined, tag._prv, view, linkInfo.id);\n\t\t\t\t\t} else {\n\t\t\t\t\t\ttag._nxt = elem;\n\t\t\t\t\t\tif (tag._.unlinked && !tag._toLk) {\n\t\t\t\t\t\t\t// This is a 'close linked tag' binding annotation (and data-binding was not skipped due to lateRender)\n\t\t\t\t\t\t\ttagCtx = tag.tagCtx;\n\t\t\t\t\t\t\tview = tagCtx.view;\n\t\t\t\t\t\t\tcallAfterLink(tag);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t// Add data binding for a data-linked element (with data-link attribute)\n\t\t\t\taddDataBinding(late, elem.getAttribute($viewsLinkAttr), elem, $view(elem), undefined, isLink, outerData, context);\n\t\t\t}\n\t\t}\n//});\n\t}\n\t//==== /end of nested functions ====\n\n\tvar inTag, linkCtx, tag, i, l, j, len, elems, elem, view, vwInfo, linkInfo, prevNodes, token, prevView, nextView,\n\t\tnode, tags, deep, tagName, tagCtx, validate, tagDepth, depth, fragment, copiedNode, firstTag, parentTag,\n\t\tisVoid, wrapper, div, tokens, elCnt, prevElCnt, htmlTag, ids, prevIds, found, skip, isLink, get,\n\t\tself = this,\n\t\tthisId = self._.id + \"_\",\n\t\tdefer = \"\",\n\t\t// The marker ids for which no tag was encountered (empty views or final closing markers) which we carry over to container tag\n\t\tbindEls = [],\n\t\ttagStack = [],\n\t\tdeferStack = [],\n\t\tlate = [],\n\t\tonAfterCreate = changeHandler(self, onAfterCreateStr),\n\t\tprocessInfos = processViewInfos;\n\n\tif (refresh) {\n\t\tif (refresh.tmpl) {\n\t\t\t// refresh is the prevView, passed in from addViews()\n\t\t\tprevView = \"/\" + refresh._.id + \"_\";\n\t\t} else {\n\t\t\tisLink = refresh.lnk; // Top-level linking\n\t\t\tif (refresh.tag) {\n\t\t\t\tthisId = refresh.tag + \"^\";\n\t\t\t\trefresh = true;\n\t\t\t}\n\t\t\tif (get = refresh.get) {\n\t\t\t\tprocessInfos = getViewInfos;\n\t\t\t\ttags = get.tags;\n\t\t\t\tdeep = get.deep;\n\t\t\t\ttagName = get.name;\n\t\t\t}\n\t\t}\n\t\trefresh = refresh === true;\n\t}\n\n\tparentNode = parentNode\n\t\t? (\"\" + parentNode === parentNode\n\t\t\t? $(parentNode)[0]  // It is a string, so treat as selector\n\t\t\t: parentNode.jquery\n\t\t\t\t? parentNode[0]   // A jQuery object - take first element.\n\t\t\t\t: parentNode)\n\t\t: (self.parentElem    // view.link()\n\t\t\t|| document.body);  // link(null, data) to link the whole document\n\n\tvalidate = !$subSettingsAdvanced.noValidate && parentNode.contentEditable !== TRUE;\n\tparentTag = parentNode.tagName.toLowerCase();\n\telCnt = !!elContent[parentTag];\n\n\tprevNode = prevNode && markPrevOrNextNode(prevNode, elCnt);\n\tnextNode = nextNode && markPrevOrNextNode(nextNode, elCnt) || null;\n\n\tif (html != undefined) {\n\t\t//================ Insert html into DOM using documentFragments (and wrapping HTML appropriately). ================\n\t\t// Also convert markers to DOM annotations, based on content model.\n\t\t// Corresponds to nextNode ? $(nextNode).before(html) : $(parentNode).html(html);\n\t\t// but allows insertion to wrap correctly even with inserted script nodes. jQuery version will fail e.g. under tbody or select.\n\t\t// This version should also be slightly faster\n\t\tdiv = document.createElement(\"div\");\n\t\twrapper = div;\n\t\tprevIds = ids = \"\";\n\t\thtmlTag = parentNode.namespaceURI === \"http://www.w3.org/2000/svg\" ? \"svg_ns\" : (firstTag = rFirstElem.exec(html)) && firstTag[1] || \"\";\n\t\tif (elCnt) {\n\t\t\t// Now look for following view, and find its tokens, or if not found, get the parentNode._df tokens\n\t\t\tnode = nextNode;\n\t\t\twhile (node && !(nextView = viewInfos(node))) {\n\t\t\t\tnode = node.nextSibling;\n\t\t\t}\n\t\t\tif (tokens = nextView ? nextView._tkns : parentNode._df) {\n\t\t\t\ttoken = prevView || \"\";\n\t\t\t\tif (refresh || !prevView) {\n\t\t\t\t\ttoken += \"#\" + thisId;\n\t\t\t\t}\n\t\t\t\tj = tokens.indexOf(token);\n\t\t\t\tif (j + 1) {\n\t\t\t\t\tj += token.length;\n\t\t\t\t\t// Transfer the initial tokens to inserted nodes, by setting them as the ids variable, picked up in convertMarkers\n\t\t\t\t\tprevIds = ids = tokens.slice(0, j);\n\t\t\t\t\ttokens = tokens.slice(j);\n\t\t\t\t\tif (nextView) {\n\t\t\t\t\t\tnode.setAttribute(jsvAttrStr, tokens);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tsetDefer(parentNode, tokens);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t//================ Convert the markers to DOM annotations, based on content model. ================\n//\t\t\toldElCnt = elCnt;\n\t\tisVoid = undefined;\n\t\thtml = (\"\" + html).replace(rConvertMarkers, convertMarkers);\n//\t\t\tif (!!oldElCnt !== !!elCnt) {\n//\t\t\t\terror(\"Parse: \" + html); // Parse error. Content not well-formed?\n//\t\t\t}\n\t\tif (validate && tagStack.length) {\n\t\t\tsyntaxError(\"Mismatched '<\" + parentTag + \"...>' in:\\n\" + html); // Unmatched tag\n\t\t}\n\t\tif (validateOnly) {\n\t\t\treturn;\n\t\t}\n\t\t// Append wrapper element to doc fragment\n\t\tsafeFragment.appendChild(div);\n\n\t\t// Go to html and back, then peel off extra wrappers\n\t\t// Corresponds to jQuery $(nextNode).before(html) or $(parentNode).html(html);\n\t\t// but supports svg elements, and other features missing from jQuery version (and this version should also be slightly faster)\n\t\thtmlTag = wrapMap[htmlTag] || wrapMap.div;\n\t\tdepth = htmlTag[0];\n\t\twrapper.innerHTML = htmlTag[1] + html + htmlTag[2];\n\t\twhile (depth--) {\n\t\t\twrapper = wrapper.lastChild;\n\t\t}\n\t\tsafeFragment.removeChild(div);\n\t\tfragment = document.createDocumentFragment();\n\t\twhile (copiedNode = wrapper.firstChild) {\n\t\t\tfragment.appendChild(copiedNode);\n\t\t}\n\t\t// Insert into the DOM\n\t\tparentNode.insertBefore(fragment, nextNode);\n\t}\n\tdataLink();\n\n\treturn late;\n}\n\nfunction addDataBinding(late, linkMarkup, node, currentView, boundTagId, isLink, data, context) {\n\t// Add data binding for data-linked elements or {^{...}} data-linked tags\n\tvar tmpl, tokens, attr, convertBack, tagExpr, linkFn, linkCtx, tag, rTagIndex, hasElse, lastIndex,\n\t\tlinkExpressions = [];\n\n\tif (boundTagId) {\n\t\t// boundTagId is a string for {^{...}} data-linked tag. So only one linkTag in linkMarkup\n\t\t// data and context arguments are undefined\n\t\ttag = bindingStore[boundTagId];\n\t\ttag = tag.linkCtx ? tag.linkCtx.tag : tag;\n\n\t\tlinkCtx = tag.linkCtx || {\n\t\t\ttype: \"inline\",\n\t\t\tdata: currentView.data,                   // source\n\t\t\telem: tag._elCnt ? tag.parentElem : node, // target\n\t\t\tview: currentView,\n\t\t\tctx: currentView.ctx,\n\t\t\tattr: HTML, // Script marker nodes are associated with {^{ and always target HTML.\n\t\t\tfn: tag._.bnd,\n\t\t\ttag: tag,\n\t\t\t// Pass the boundTagId in the linkCtx, so that it can be picked up in observeAndBind\n\t\t\t_bndId: boundTagId\n\t\t};\n\t\ttag.linkCtx = linkCtx;\n\t\tbindDataLinkTarget(linkCtx, late);\n\t\ttag._toLk = linkCtx._bndId; // If data binding happened, remove _toLk flag from tag\n\t} else if (linkMarkup && node) {\n\t\t// Data-linked element\n\n\t\t// If isLink then this is a top-level linking: .link(expression, target, data, ....) or\n\t\t// .link(true, target, data, ....) scenario - and data and context are passed in separately from the view\n\t\tdata = isLink ? data : currentView.data;\n\n\t\t// Compiled linkFn expressions could be stored in the tmpl.links array of the template\n\t\t// TODO - consider also caching globally so that if {{:foo}} or data-link=\"foo\" occurs in different places,\n\t\t// the compiled template for this is cached and only compiled once...\n\t\t//links = currentView.links || currentView.tmpl.links;\n\n\t\ttmpl = currentView.tmpl;\n\n//\t\t\tif (!(linkTags = links[linkMarkup])) {\n\t\t// This is the first time this view template has been linked, so we compile the data-link expressions, and store them on the template.\n\n\t\tlinkMarkup = normalizeLinkTag(linkMarkup, defaultAttr(node));\n\t\tlastIndex = rTagDatalink.lastIndex = 0;\n\t\twhile (tokens = rTagDatalink.exec(linkMarkup)) { // TODO require } to be followed by whitespace or $, and remove the \\}(!\\}) option.\n\t\t\tlinkExpressions.push(tokens);\n\t\t\tlastIndex = rTagDatalink.lastIndex;\n\t\t}\n\t\tif (lastIndex < linkMarkup.length) {\n\t\t\tsyntaxError(linkMarkup);\n\t\t}\n\t\twhile (tokens = linkExpressions.shift()) {\n\t\t\t// Iterate over the data-link expressions, for different target attrs,\n\t\t\t// e.g. <input data-link=\"{:firstName:} title{>~description(firstName, lastName)}\"\n\t\t\t// tokens: [all, attr, bindOnly, tagExpr, tagName, converter, colon, html, comment, code, params]\n\t\t\trTagIndex = rTagDatalink.lastIndex;\n\t\t\tattr = tokens[1];\n\t\t\ttagExpr = tokens[3];\n\t\t\twhile (linkExpressions[0] && linkExpressions[0][4] === \"else\") { // If this is {sometag...} and is followed by an {else...} add to tagExpr\n\t\t\t\ttagExpr += delimCloseChar1 + delimOpenChar0 + linkExpressions.shift()[3];\n\t\t\t\thasElse = true;\n\t\t\t}\n\t\t\tif (hasElse) { // If an {else} has been added, need also to add closing {{/sometag}}\n\t\t\t\ttagExpr += delimCloseChar1 + delimOpenChar0 + delimOpenChar1 + \"/\" + tokens[4] + delimCloseChar0;\n\t\t\t}\n\t\t\tlinkCtx = {\n\t\t\t\ttype: isLink || \"link\",\n\t\t\t\tdata: data, // source\n\t\t\t\telem: node, // target\n\t\t\t\tview: currentView,\n\t\t\t\tctx: context,\n\t\t\t\tattr: attr,\n\t\t\t\t_toLk : 1, // Flag to data-link on initial data-link call rendering call\n\t\t\t\t_noUpd : tokens[2] // Flag for data-link=\"^{...}\" so on initial data-link call will bind, but not render)\n\t\t\t};\n\n\t\t\tconvertBack = undefined;\n\t\t\tif (tokens[6]) {\n\t\t\t\tconvertBack = tokens[10] || undefined;\n\t\t\t\tlinkCtx.convert = tokens[5] || \"\";\n\t\t\t\tif (convertBack !== undefined && defaultAttr(node)) {\n\t\t\t\t\tif (attr) {\n\t\t\t\t\t\tsyntaxError(tagExpr + \"- Remove target: \" + attr);\n\t\t\t\t\t}\n\t\t\t\t\t// Default target, so allow 2 way binding\n\t\t\t\t\tlinkCtx.convertBack = convertBack = convertBack.slice(1);\n\t\t\t\t}\n\t\t\t}\n\t\t\t// Compile the linkFn expression which evaluates and binds a data-link expression\n\t\t\t// TODO - optimize for the case of simple data path with no conversion, helpers, etc.:\n\t\t\t//     i.e. data-link=\"a.b.c\". Avoid creating new instances of Function every time. Can use a default function for all of these...\n\n\t\t\tlinkCtx.expr = attr + tagExpr;\n\t\t\tlinkFn = tmpl.links[tagExpr];\n\t\t\tif (!linkFn) {\n\t\t\t\ttmpl.links[tagExpr] = linkFn = $sub.tmplFn(tagExpr.replace(rEscapeQuotes, \"\\\\$&\"), tmpl, true, convertBack, hasElse);\n\t\t\t}\n\t\t\tlinkCtx.fn = linkFn;\n\t\t\tbindDataLinkTarget(linkCtx, late);\n\t\t\t// We store rTagIndex in local scope, since this addDataBinding method can sometimes be called recursively,\n\t\t\t// and each is using the same rTagDatalink instance.\n\t\t\trTagDatalink.lastIndex = rTagIndex;\n\t\t}\n//\t\t}\n\t}\n}\n\nfunction bindDataLinkTarget(linkCtx, late) {\n\t// Add data link bindings for a link expression in data-link attribute markup\n\tfunction handler(ev, eventArgs) {\n\t\tonDataLinkedTagChange.call(linkCtx, ev, eventArgs);\n\t\t// If the link expression uses a custom tag, the onDataLinkedTagChange call will call renderTag, which will set tagCtx on linkCtx\n\t}\n\tvar view,\n\t\tlinkCtxType = linkCtx.type;\n\tif (linkCtxType === \"top\" || linkCtxType === \"expr\") {\n\t\t// Top-level linking: .link(expressionOrTrue, data, context) - so we need to create a view for the linking, with the data and ctx\n\t\t// which may be different than the current context of the target. Note that this view is not a standard data-linked view, so it will\n\t\t// be disposed only when its parent view is disposed.\n\t\tlinkCtx.view = new $sub.View(\n\t\t\t$sub.extendCtx(linkCtx.ctx, linkCtx.view.ctx),\n\t\t\t\"link\", linkCtx.view, linkCtx.data, linkCtx.expr, undefined, addBindingMarkers);\n\t}\n\tlinkCtx._ctxCb = $sub._gccb(view = linkCtx.view); // getContextCallback: _ctxCb, for filtering/appending to dependency paths: function(path, object) { return [(object|path)*]}\n\tlinkCtx._hdl = handler;\n\t// handler._ctx = linkCtx; Could pass linkCtx for use in a depends = function() {} call, so depends is different for different linkCtx's\n\tif (linkCtx.elem.nodeName === \"SELECT\" && linkCtxType === \"link\" && !linkCtx.attr) {\n\t\tvar $elem = $(linkCtx.elem);\n\t\t$elem.on(\"jsv-domchange\", function() {\n\t\t\t// If the options have changed dynamically under the select, we need to refresh the data-linked selection, using the new options\n\t\t\tif (!arguments[3].refresh) { // eventArgs.refresh !== true - so a refresh action will only set the selection once\n\t\t\t\tvar source = linkCtx.fn(view.data, view, $sub);\n\t\t\t\t$elem.val(linkCtx.convert || linkCtx.convertBack ? $sub._cnvt(linkCtx.convert, view, source) : source);\n\t\t\t}\n\t\t});\n\t}\n\n\tif (linkCtx.fn._lr) {\n\t\tlinkCtx._toLk = 1;\n\t\tlate.push(linkCtx); // lateRender - defer rendering and linking (sync but after first linking pass)\n\t} else {\n\t\thandler(true);\n\t}\n}\n\n//=====================\n// Data-linking helpers\n//=====================\n\nfunction removeSubStr(str, substr) {\n\tvar k;\n\treturn str\n\t\t? (k = str.indexOf(substr),\n\t\t\t(k + 1\n\t\t\t\t? str.slice(0, k) + str.slice(k + substr.length)\n\t\t\t\t: str))\n\t\t: \"\";\n}\n\nfunction markerNodeInfo(node) {\n\treturn node &&\n\t\t(\"\" + node === node\n\t\t\t? node\n\t\t\t: node.tagName === SCRIPT\n\t\t\t\t? node.type.slice(3)\n\t\t\t\t: node.nodeType === 1 && node.getAttribute(jsvAttrStr) || \"\");\n}\n\nfunction viewInfos(node, isVal, rBinding) {\n\t// Test whether node is a script marker node, and if so, return metadata\n\tfunction getInfos(all, open, close, id, ch, elPath) {\n\t\tinfos.push({\n\t\t\telCnt: elCnt,\n\t\t\tid: id,\n\t\t\tch: ch,\n\t\t\topen: open,\n\t\t\tclose: close,\n\t\t\tpath: elPath,\n\t\t\ttoken: all\n\t\t});\n\t}\n\tvar elCnt, tokens,\n\t\tinfos = [];\n\tif (tokens = isVal ? node : markerNodeInfo(node)) {\n\t\telCnt = infos.elCnt = node.tagName !== SCRIPT;\n\t\telCnt = tokens.charAt(0) === \"@\" || elCnt;\n\t\tinfos._tkns = tokens;\n\t\t// rMarkerTokens = /(?:(#)|(\\/))(\\d+)([_^])([-+@\\d]+)?/g;\n\t\ttokens.replace(rBinding || rMarkerTokens, getInfos);\n\t\treturn infos;\n\t}\n}\n\nfunction unmarkPrevOrNextNode(node, elCnt) {\n\tif (node) {\n\t\tif (node.type === \"jsv\") {\n\t\t\tnode.parentNode.removeChild(node);\n\t\t} else if (elCnt && node.getAttribute($viewsLinkAttr) === \"\") {\n\t\t\tnode.removeAttribute($viewsLinkAttr);\n\t\t}\n\t}\n}\n\nfunction markPrevOrNextNode(node, elCnt) {\n\tvar marker = node;\n\twhile (elCnt && marker && marker.nodeType !== 1) {\n\t\tmarker = marker.previousSibling;\n\t}\n\tif (marker) {\n\t\tif (marker.nodeType !== 1) {\n\t\t\t// For text nodes, we will add a script node before\n\t\t\tmarker = document.createElement(SCRIPT);\n\t\t\tmarker.type = \"jsv\";\n\t\t\tnode.parentNode.insertBefore(marker, node);\n\t\t} else if (!markerNodeInfo(marker) && !marker.getAttribute($viewsLinkAttr)) {\n\t\t\t// For element nodes, we will add a data-link attribute (unless there is already one)\n\t\t\t// so that this node gets included in the node linking process.\n\t\t\tmarker.setAttribute($viewsLinkAttr, \"\");\n\t\t}\n\t}\n\treturn marker;\n}\n\nfunction normalizeLinkTag(linkMarkup, twoway) {\n\tlinkMarkup = $.trim(linkMarkup);\n\treturn linkMarkup.slice(-1) !== delimCloseChar0\n\t// If simplified syntax is used: data-link=\"expression\", convert to data-link=\"{:expression}\",\n\t// or for inputs, data-link=\"{:expression:}\" for (default) two-way binding\n\t\t? linkMarkup = delimOpenChar1 + \":\" + linkMarkup + (twoway ? \":\" : \"\") + delimCloseChar0\n\t\t: linkMarkup;\n}\n\n//===========================\n// Methods for views and tags\n//===========================\n\nfunction callAfterLink(tag, ev, eventArgs) {\n\tfunction copyFromTagCtxToTag() {\n\t\tlinkedElems = tagCtx.linkedElems || tag.linkedElems || tag.linkedElem && [tag.linkedElem];\n\t\tif (linkedElems) {\n\t\t\ttag.linkedElems = tagCtx.linkedElems = linkedElems;\n\t\t\ttag.linkedElem = linkedElems[0] = tag.linkedElem || linkedElems[0];\n\t\t}\n\t\tif (linkedElem = tagCtx.mainElem || tag.mainElem) {\n\t\t\ttagCtx.mainElem = tag.mainElem = linkedElem;\n\t\t}\n\t\tif (linkedElem = tagCtx.displayElem || tag.displayElem) {\n\t\t\ttagCtx.displayElem = tag.displayElem = linkedElem;\n\t\t}\n\t}\n\n\tvar linkedElems, linkedElements, linkedElem, l, m, $linkCtxElem, linkCtxElem, linkedEl, linkedTag,\n\t\ttagCtxElse, props, val, oldVal, indexTo, i, mapDeps, propDeps,\n\t\ttagCtx = tag.tagCtx,\n\t\ttagCtxs = tag.tagCtxs,\n\t\ttagCtxslength = tagCtxs && tagCtxs.length,\n\t\tlinkCtx = tag.linkCtx,\n\t\tbindTo = tag.bindTo || {};\n\n\tif (tag._.unlinked) { // First call to onAfterLink, or first call after onUpdate: updateContent. Initialize and call onBind and set properties\n\t\t$linkCtxElem = $(linkCtx.elem);\n\t\tif (tag.linkedElement || tag.mainElement || tag.displayElement) {\n\t\t\tif (linkedElements = tag.linkedElement) {\n\t\t\t\t// tag.linkedElement: - selector, or array of selectors, for identifying linked elements in template/rendered content.\n\t\t\t\t// (But for tag bindings on data-linked elements, defaults to data-linked element)\n\t\t\t\ttag.linkedElem = undefined;\n\t\t\t\tl = linkedElements.length;\n\t\t\t\twhile (l--) {\n\t\t\t\t\tif (linkedElements[l]) {\n\t\t\t\t\t\tlinkCtxElem = !tag.inline && $linkCtxElem.filter(linkedElements[l]);\n\t\t\t\t\t\tm = tagCtxslength;\n\t\t\t\t\t\twhile (m--) {\n\t\t\t\t\t\t\ttagCtxElse = tagCtxs[m];\n\t\t\t\t\t\t\tlinkedElems = tagCtxElse.linkedElems = tagCtxElse.linkedElems || new Array(l);\n\t\t\t\t\t\t\tlinkedElem = linkCtxElem[0] ? linkCtxElem : tagCtxElse.contents(true, linkedElements[l]);\n\t\t\t\t\t\t\tif (linkedElem[0] && linkedElem[0].type !== RADIO) {\n\t\t\t\t\t\t\t\tlinkedElems[l] = linkedElem.eq(0);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (linkedElements = tag.mainElement) {\n\t\t\t\t// tag.mainElement: - selector for identifying mainElem in template/rendered content\n\t\t\t\t// (But for tag bindings on data-linked elements, defaults to data-linked element)\n\t\t\t\tlinkCtxElem = !tag.inline && $linkCtxElem.filter(linkedElements);\n\t\t\t\tm = tagCtxslength;\n\t\t\t\twhile (m--) {\n\t\t\t\t\ttagCtxElse = tagCtxs[m];\n\t\t\t\t\tlinkedElem = linkCtxElem[0] ? linkCtxElem : tagCtxElse.contents(true, linkedElements).eq(0);\n\t\t\t\t\tif (linkedElem[0]) {\n\t\t\t\t\t\ttagCtxElse.mainElem = linkedElem;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (linkedElements = tag.displayElement) {\n\t\t\t\t// tag.displayElement: - selector for identifying displayElem in template/rendered content\n\t\t\t\t// (But for tag bindings on data-linked elements, defaults to data-linked element)\n\t\t\t\tlinkCtxElem = !tag.inline && $linkCtxElem.filter(linkedElements);\n\t\t\t\tm = tagCtxslength;\n\t\t\t\twhile (m--) {\n\t\t\t\t\ttagCtxElse = tagCtxs[m];\n\t\t\t\t\tlinkedElem = linkCtxElem[0] ? linkCtxElem : tagCtxElse.contents(true, linkedElements).eq(0);\n\t\t\t\t\tif (linkedElem[0]) {\n\t\t\t\t\t\ttagCtxElse.displayElem = linkedElem;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tcopyFromTagCtxToTag();\n\t\t}\n\t\tif (tag.onBind) {\n\t\t\ttag.onBind(tagCtx, linkCtx, tag.ctx, ev, eventArgs);\n\t\t\tcopyFromTagCtxToTag();\n\t\t}\n\t}\n\n\tm = tagCtxslength;\n\twhile (m--) {\n\t\ttagCtxElse = tagCtxs[m];\n\t\tprops = tagCtxElse.props;\n\n\t\tif (tag._.unlinked && tagCtxElse.map && tag.mapProps) {\n\t\t\t// Compile the dependency paths for observable changes in mapProps (e.g. start, end, filter)\n\t\t\ti = tag.mapProps.length;\n\t\t\tmapDeps = props.mapDepends || tag.mapDepends || []; // dependency paths\n\t\t\tmapDeps = $isArray(mapDeps) ? mapDeps : [mapDeps];\n\t\t\twhile (i--) { // Iterate through mapProps\n\t\t\t\tvar prop = tag.mapProps[i];\n\t\t\t\tpropDeps = tag._.bnd.paths[m][\"_\" + prop]; // paths for mapProps on this tagCtx\n\t\t\t\tif (propDeps && propDeps.length && propDeps.skp) { // Not already a bound prop ^prop=expression;\n\t\t\t\t\tmapDeps = mapDeps.concat(propDeps); // Add dependencies for this prop expression\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (mapDeps.length) {\n\t\t\t\ttagCtxElse.map.observe(mapDeps, linkCtx); // Listen to observable changes of mapProps, and call map.update when change happens\n\t\t\t}\n\t\t}\n\t\tif (linkedElem = tagCtxElse.mainElem || !tag.mainElement && tagCtxElse.linkedElems && tagCtxElse.linkedElems[0]) {\n\t\t\t// linkedElem is the mainElem (defaulting to linkedElem)\n\t\t\tif (linkedElem[0] && props.id && !linkedElem[0].id) {\n\t\t\t\tlinkedElem[0].id = props.id;\n\t\t\t}\n\t\t\tif (tag.setSize) {\n\t\t\t\tif (val = !bindTo.height && props.height || tag.height) {\n\t\t\t\t\tlinkedElem.height(val);\n\t\t\t\t}\n\t\t\t\tif (val = !bindTo.width && props.width || tag.width) {\n\t\t\t\t\tlinkedElem.width(val);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (val = (linkedElem = tagCtxElse.displayElem || linkedElem) && (!bindTo[\"class\"] && props[\"class\"] || tag.className)) {\n\t\t\t// This code supports dynamic binding to class - where it adds the class if absent, and removes/adds if a previous value is present\n\t\t\toldVal = linkedElem[0]._jsvCl;\n\t\t\tif (val !== oldVal) {\n\t\t\t\tif (linkedElem.hasClass(oldVal)) {\n\t\t\t\t\tlinkedElem.removeClass(oldVal);\n\t\t\t\t}\n\t\t\t\tlinkedElem.addClass(val);\n\t\t\t\tlinkedElem[0]._jsvCl = val;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (tag.onAfterLink) {\n\t\ttag.onAfterLink(tagCtx, linkCtx, tag.ctx, ev, eventArgs);\n\t\tcopyFromTagCtxToTag();\n\t}\n\n\tif (!tag.flow && !tag._.chg) {\n\t\tif (tag._tgId && tag._.unlinked && (tag.linkedElems || tag.bindTo)) {\n\t\t\tdefineBindToDataTargets(bindingStore[tag._tgId], tag);\n\t\t}\n\t\tm = tagCtxs.length;\n\t\twhile (m--) {\n\t\t\tprops = tag.cvtArgs(m, 1); // array of bindFrom args/props\n\t\t\tl = props.length;\n\t\t\twhile (l--) {\n\t\t\t\tval = props[l];\n\t\t\t\ttag.setValue(val, l, m);\n\t\t\t}\n\t\t\tif (tag._.unlinked) {\n\t\t\t\ttagCtx = tagCtxs[m];\n\t\t\t\tlinkedElems = tagCtx.linkedElems || !m && tag.linkedElem && [tag.linkedElem];\n\t\t\t\tindexTo = (tag.bindTo || [0]).length;\n\t\t\t\twhile (indexTo--) {\n\t\t\t\t\tif ((linkedElem = linkedElems && linkedElems[indexTo]) && (l = linkedElem.length)) {\n\t\t\t\t\t\twhile (l--) {\n\t\t\t\t\t\t\tlinkedEl = linkedElem[l];\n\t\t\t\t\t\t\tlinkedTag = linkedEl._jsvLkEl;\n\t\t\t\t\t\t\tif (!linkedTag || linkedTag !== tag) {\n\t\t\t\t\t\t\t\t// For data-linked tags, identify the linkedEl with the tag, for \"to\" binding\n\t\t\t\t\t\t\t\t// (For data-linked elements, if not yet bound, we identify later when the linkCtx.elem is bound)\n\t\t\t\t\t\t\t\tlinkedEl._jsvLkEl = tag;\n\t\t\t\t\t\t\t\tlinkedEl._jsvInd = indexTo;\n\t\t\t\t\t\t\t\tlinkedEl._jsvElse = m;\n\t\t\t\t\t\t\t\tbindLinkedElChange(tag, linkedEl);\n\t\t\t\t\t\t\t\tlinkedEl._jsvBnd = \"&\" + tag._tgId + \"+\"; // Add a \"+\" for cloned binding - so removing\n\t\t\t\t\t\t\t\t// elems with cloned bindings will not remove the 'parent' binding from the bindingStore.\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\ttag._.unlinked = undefined;\n\tif (tag._.lt) { // Late tag: Late path: @some.path had not returned @some object, so try again with refresh\n\t\ttag.refresh();\n\t}\n}\n\nfunction asyncOnElemChange(ev) {\n\tvar which = ev.which;\n\tif (!(which > 15 && which < 21 || which > 32 && which < 41 || which > 111 && which < 131 || which === 27 || which === 144)) {\n\t\t// Shift, Ctrl, Alt, Pause, Caplock, Page up/down End, Home, Left, Up, Right, Down, Function keys, Escape, Numlock\n\t\tsetTimeout(function() {\n\t\t\tonElemChange(ev);\n\t\t});\n\t}\n}\n\nfunction bindTriggerEvent($elem, trig, onoff) {\n\t// Bind keydown, or other trigger - (rather than use the default change event bubbled to activeBody)\n\tif (trig === true && useInput && (!isIE || $elem[0].contentEditable !== TRUE)) { // IE oninput event is not raised for contenteditable changes\n\t\t$elem[onoff](\"input.jsv\", onElemChange); // For HTML5 browser with \"oninput\" support - for mouse editing of text\n\t} else {\n\t\ttrig = \"\" + trig === trig ? trig : \"keydown.jsv\"; // Set trigger to (true || truey non-string (e.g. 1) || 'keydown')\n\t\t$elem[onoff](trig, trig.indexOf(\"keydown\") >= 0 ? asyncOnElemChange : onElemChange); // Get 'keydown' with async\n\t}\n}\n\nfunction bindLinkedElChange(tag, linkedElem) {\n\t// Two-way binding for linkedElem - in the case of input, textarea or contentEditable elements.\n\t// Trigger setting may have changed. Unbind previous trigger binding (if any) and bind new one.\n\n\tvar $linkedElem, newTrig,\n\t\toldTrig = linkedElem._jsvTr || false;\n\n\tif (tag) {\n\t\tnewTrig = tag.tagCtx.props.trigger;\n\t\tif (newTrig === undefined) {\n\t\t\tnewTrig = tag.trigger;\n\t\t}\n\t}\n\tif (newTrig === undefined) {\n\t\tnewTrig = $subSettings.trigger;\n\t}\n\t// Trigger is noop except for text box, textarea, contenteditable...\n\tnewTrig = newTrig && (linkedElem.tagName === \"INPUT\" && linkedElem.type !== CHECKBOX && linkedElem.type !== RADIO\n\t\t|| linkedElem.type === \"textarea\" || linkedElem.contentEditable === TRUE) && newTrig || false;\n\n\tif (oldTrig !== newTrig) {\n\t\t$linkedElem = $(linkedElem);\n\t\tbindTriggerEvent($linkedElem, oldTrig, \"off\");\n\t\tbindTriggerEvent($linkedElem, linkedElem._jsvTr = newTrig, \"on\");\n\t}\n}\n\nfunction defineBindToDataTargets(binding, tag, cvtBk) {\n\t// Two-way binding.\n\t// We set the binding.to[1] to be the cvtBack, and binding.to[0] to be either the path to the target, or [object, path] where the target is the\n\t// path on the provided object. So for a computed path with an object call: a.b.getObject().d.e, we set to[0] to be [exprOb, \"d.e\"], and\n\t// we bind to the path on the returned object, exprOb.ob, as target. Otherwise our target is the first path, paths[0], which we will convert\n\t// with contextCb() for paths like ~a.b.c or #x.y.z\n\n\tvar pathIndex, path, lastPath, bindtoOb, to, bindTo, paths, k, obsCtxPrm, linkedCtxParam, contextCb, targetPaths, bindTos, fromIndex,\n\t\ttagElse = 1,\n\t\ttos = [],\n\t\tlinkCtx = binding.linkCtx,\n\t\tsource = linkCtx.data,\n\t\ttargetPathsElses = linkCtx.fn.paths;\n\n\tif (binding && !binding.to) {\n\t\tif (tag) {\n\t\t\tif (!tag.convertBack) {\n\t\t\t\ttag.convertBack = cvtBk;\n\t\t\t}\n\t\t\tbindTo = tag.bindTo;\n\t\t\ttagElse = tag.tagCtxs ? tag.tagCtxs.length : 1;\n\t\t}\n\t\twhile (tagElse--) {\n\t\t\tbindTos = [];\n\t\t\tif (targetPaths = targetPathsElses[tagElse]) {\n\t\t\t\tbindTo = targetPaths._jsvto ? [\"jsvto\"] : (bindTo || [0]);\n\t\t\t\tif (!tagElse && tag && tag._.ths) {\n\t\t\t\t\t// Tag has a this=expr bindign for which we will create an additional 'to' target (at index bindTo.length)\n\t\t\t\t\tbindTo = bindTo.concat(\"this\");\n\t\t\t\t}\n\t\t\t\tk = bindTo.length;\n\t\t\t\twhile (k--) {\n\t\t\t\t\tpath = \"\";\n\t\t\t\t\tcontextCb = linkCtx._ctxCb;\n\t\t\t\t\tpaths = bindTo[k];\n\t\t\t\t\tpaths = targetPaths[+paths === paths ? paths : \"_\" + paths]; // If path is a string, prepend \"_\" to avoid collision (e.g. with array.length if path is \"length\")\n\t\t\t\t\tif (pathIndex = paths && paths.length) {\n\t\t\t\t\t\tlastPath = paths[pathIndex - 1];\n\t\t\t\t\t\tif (lastPath._cpfn) { // Computed property exprOb\n\n\t\t\t\t\t\t\tbindtoOb = lastPath;\n\t\t\t\t\t\t\twhile (lastPath.sb && lastPath.sb._cpfn) {\n\t\t\t\t\t\t\t\tpath = lastPath = lastPath.sb;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tpath = lastPath.sb || path && path.path;\n\t\t\t\t\t\t\tlastPath = path ? path.slice(1) : bindtoOb.path;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tto = path\n\t\t\t\t\t\t\t? [bindtoOb, // 'exprOb' for this expression and view-binding. So bindtoOb.ob is current object returned by expression.\n\t\t\t\t\t\t\t\t\tlastPath]\n\t\t\t\t\t\t\t: resolveDataTargetPath(lastPath, source, contextCb); // Get 'to' for target path: lastPath\n\t\t\t\t\t} else {\n\t\t\t\t\t\t// Contextual parameter ~foo with no external binding - has ctx.foo = [{_ocp: xxx}] and binds to ctx.foo._ocp\n\t\t\t\t\t\tlinkedCtxParam = tag.linkedCtxParam;\n\t\t\t\t\t\tto = [];\n\t\t\t\t\t\tfromIndex = tag._.fromIndex;\n\t\t\t\t\t\tif (fromIndex && linkedCtxParam && linkedCtxParam[fromIndex[k]]) {\n\t\t\t\t\t\t\t// This is a tag binding, with linked tag contextual parameters\n\t\t\t\t\t\t\tto = [tag.tagCtxs[tagElse].ctx[linkedCtxParam[fromIndex[k]]][0], _ocp];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif ((obsCtxPrm = to._cxp) && obsCtxPrm.tag && lastPath.indexOf(\".\")<0) {\n\t\t\t\t\t\t// This is a binding for a tag contextual parameter (e.g. <input data-link=\"~wd\"/> within a tag block content\n\t\t\t\t\t\tto = obsCtxPrm;\n\t\t\t\t\t}\n\t\t\t\t\tbindTos.unshift(to);\n\t\t\t\t}\n\t\t\t}\n\t\t\ttos.unshift(bindTos);\n\t\t}\n\t\tbinding.to = tos;\n\t}\n}\n\nfunction resolveDataTargetPath(targetPath, source, contextCb) {\n\t// Iteratively process targetPath, resolving ~a.b.c paths for contextual parameters\n\tvar path, bindtoOb, to, l, obsCtxPrm, view, topCp, data;\n\n\twhile (targetPath && targetPath !== _ocp && (to = contextCb(path = targetPath.split(\"^\").join(\".\"), source)) && (l = to.length)) {\n\t\tif (obsCtxPrm = to[0]._cxp) { // Two-way binding to a contextual parameter reference, ~foo (declared as ~foo=expr on a parent tag)\n\t\t\ttopCp = topCp || obsCtxPrm;\n\t\t\tview = to[0][0];\n\t\t\tif (_ocp in view) {\n\t\t\t\tdata = view;\n\t\t\t\tview = view._vw;\n\t\t\t} else {\n\t\t\t\tdata = view.data;\n\t\t\t}\n\t\t\ttopCp.path = targetPath = to[0][1];\n\t\t\tto = [topCp.data = data, targetPath];\n\t\t\t\tcontextCb = $sub._gccb(view);\n\t\t\t\tif (targetPath._cpfn) { // computed property\n\t\t\t\t\tbindtoOb = targetPath;\n\t\t\t\t\tbindtoOb.data = to[0];\n\t\t\t\t\tbindtoOb._cpCtx = contextCb;\n\t\t\t\t\twhile (targetPath.sb && targetPath.sb._cpfn) {\n\t\t\t\t\t\tpath = targetPath = targetPath.sb;\n\t\t\t\t\t}\n\t\t\t\t\tpath = targetPath.sb || path && path.path;\n\t\t\t\t\ttargetPath = path ? path.slice(1) : bindtoOb.path;\n\t\t\t\t\tto = [\n\t\t\t\t\t\tbindtoOb, // 'exprOb' for this expression and view-binding. So bindtoOb.ob is current object returned by expression.\n\t\t\t\t\t\ttargetPath\n\t\t\t\t\t];\n\t\t\t\t} else if (obsCtxPrm.tag && obsCtxPrm.path === _ocp) {\n\t\t\t\t\tto = obsCtxPrm;\n\t\t\t\t}\n\t\t} else { // Two-way binding to a helper - e.g. ~address.street, or computed, e.g. ~fullName(), or view property e.g. #data.foo\n\t\t\tto = l>1\n\t\t\t\t? [to[l-2], to[l-1]] // With path: [object, path]\n\t\t\t\t: [to[l-1]];         // No path, (e.g. [function] for computed with setter)\n\t\t}\n\t\tsource = to[0];\n\t\ttargetPath = to[1];\n\t}\n\tto = to || [source, path];\n\tto._cxp = topCp;\n\treturn to;\n}\n\nfunction mergeCtxs(tag, newCtxs, replace) { // Merge updated tagCtxs into tag.tagCtxs\n\tvar tagCtx, newTagCtx, latePath,\n\t\tview = tag.tagCtx.view,\n\t\ttagCtxs = tag.tagCtxs || [tag.tagCtx],\n\t\tl = tagCtxs.length,\n\t\trefresh = !newCtxs;\n\n\tif (refresh) {\n\t\tnewCtxs = tag._.bnd.call(view.tmpl, (tag.linkCtx || view).data, view, $sub);\n\t\tif (newCtxs.lt) {\n\t\t\treturn; // We are calling tag.refresh() but a late path (@a.b.c) has not yet returned an object (@a) so cancel the refresh()\n\t\t}\n\t\ttag._.lt = undefined; // All late paths are now resolved, so this is no longer a late tag\n\t\tnewCtxs = $isArray(newCtxs) ? newCtxs : [newCtxs];\n\t}\n\n\tif (replace) {\n\t\t// Replace previous tagCtxs by new ones, rather than merging\n\t\ttagCtxs = tag.tagCtxs = newCtxs;\n\t\ttag.tagCtx = tagCtxs[0];\n\t\taddLinkMethods(tag);\n\t} else {\n\t\twhile (l--) {\n\t\t\ttagCtx = tagCtxs[l];\n\t\t\tnewTagCtx = newCtxs[l];\n\t\t\t$observable(tagCtx.props).setProperty(newTagCtx.props);\n\t\t\t$extend(tagCtx.ctx, newTagCtx.ctx); // We don't support propagating ctx variables, ~foo, observably, to nested views. So extend, not setProperty...\n\t\t\ttagCtx.args = newTagCtx.args;\n\t\t\tif (refresh) {\n\t\t\t\ttagCtx.tmpl = newTagCtx.tmpl;\n\t\t\t}\n\t\t}\n\t}\n\t$sub._thp(tag, tagCtxs[0]); // tagHandlersFromProps\n\treturn tagCtxs;\n}\n\n//=========\n// Disposal\n//=========\n\nfunction clean(elems) {\n\t// Remove data-link bindings, or contained views\n\tvar l, elem, bindings,\n\t\telemArray = [],\n\t\tlen = elems.length,\n\t\ti = len;\n\twhile (i--) {\n\t\t// Copy into an array, so that deletion of nodes from DOM will not cause our 'i' counter to get shifted\n\t\t// (Note: This seems as fast or faster than elemArray = [].slice.call(elems); ...)\n\t\telemArray.push(elems[i]);\n\t}\n\ti = len;\n\twhile (i--) {\n\t\telem = elemArray[i];\n\t\tif (elem.parentNode) {\n\t\t\t// Has not already been removed from the DOM\n\t\t\tif (bindings = elem._jsvBnd) {\n\t\t\t\t// Get propertyChange bindings for this element\n\t\t\t\t// This may be an element with data-link, or the opening script marker node for a data-linked tag {^{...}}\n\t\t\t\t// bindings is a string with the syntax: \"(&bindingId)*\"\n\t\t\t\tbindings = bindings.slice(1).split(\"&\");\n\t\t\t\telem._jsvBnd = \"\";\n\t\t\t\tl = bindings.length;\n\t\t\t\twhile (l--) {\n\t\t\t\t\t// Remove associated bindings\n\t\t\t\t\tremoveViewBinding(bindings[l], elem._jsvLkEl, elem); // unbind bindings with this bindingId on this view\n\t\t\t\t}\n\t\t\t}\n\t\t\tdisposeTokens(markerNodeInfo(elem) + (elem._df || \"\"), elem);\n\t\t}\n\t}\n}\n\nfunction removeViewBinding(bindId, linkedElemTag, elem) {\n\t// Unbind\n\tvar objId, linkCtx, tag, object, obsId, tagCtxs, l, map, linkedElem, trigger, view, tagCtx, linkedElems, allLinkedElems,\n\t\tbinding = bindingStore[bindId];\n\n\tif (linkedElemTag) {\n\t\telem._jsvLkEl = undefined;\n\t} else if (binding && (!elem || elem === binding.elem)) { // Test that elem is actually binding.elem, since cloned elements can have inappropriate markerNode info\n\t\tdelete bindingStore[bindId]; // Delete already, so call to onDispose handler below cannot trigger recursive deletion (through recursive call to jQuery cleanData)\n\t\tfor (objId in binding.bnd) {\n\t\t\tobject = binding.bnd[objId];\n\t\t\tobsId = binding.cbId;\n\t\t\tif ($isArray(object)) {\n\t\t\t\t$([object]).off(arrayChangeStr + obsId).off(propertyChangeStr + obsId); // There may be either or both of arrayChange and propertyChange\n\t\t\t} else {\n\t\t\t\t$(object).off(propertyChangeStr + obsId);\n\t\t\t}\n\t\t\tdelete binding.bnd[objId];\n\t\t}\n\n\t\tif (linkCtx = binding.linkCtx) {\n\t\t\tif (tag = linkCtx.tag) {\n\t\t\t\tif (tagCtxs = tag.tagCtxs) {\n\t\t\t\t\tl = tagCtxs.length;\n\t\t\t\t\twhile (l--) {\n\t\t\t\t\t\ttagCtx = tagCtxs[l];\n\t\t\t\t\t\tif (map = tagCtx.map) {\n\t\t\t\t\t\t\tmap.unmap(); //unobserve\n\t\t\t\t\t\t}\n\t\t\t\t\t\t// Copy linkedElems in case tag.linkedElem or tag.linkedElems are undefined in onUnbind\n\t\t\t\t\t\tif (linkedElems = tagCtx.linkedElems) {\n\t\t\t\t\t\t\tallLinkedElems = (allLinkedElems || []).concat(linkedElems);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (tag.onUnbind) {\n\t\t\t\t\ttag.onUnbind(tag.tagCtx, linkCtx, tag.ctx);\n\t\t\t\t}\n\t\t\t\tif (tag.onDispose) {\n\t\t\t\t\ttag.onDispose();\n\t\t\t\t}\n\n\t\t\t\tif (!tag._elCnt) {\n\t\t\t\t\tif (tag._prv) {\n\t\t\t\t\t\ttag._prv.parentNode.removeChild(tag._prv);\n\t\t\t\t\t}\n\t\t\t\t\tif (tag._nxt) {\n\t\t\t\t\t\ttag._nxt.parentNode.removeChild(tag._nxt);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tlinkedElems = allLinkedElems || [$(linkCtx.elem)];\n\t\t\tl = linkedElems.length;\n\t\t\twhile (l--) {\n\t\t\t\tlinkedElem = linkedElems[l];\n\t\t\t\tif (trigger = linkedElem && linkedElem[0] && linkedElem[0]._jsvTr) {\n\t\t\t\t\tbindTriggerEvent(linkedElem, trigger, \"off\");\n\t\t\t\t\tlinkedElem[0]._jsvTr = undefined;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tview = linkCtx.view;\n\t\t\tif (view.type === \"link\") {\n\t\t\t\tview.parent.removeViews(view._.key, undefined, true); // A \"link\" view is associated with the binding, so should be disposed with binding.\n\t\t\t} else {\n\t\t\t\tdelete view._.bnds[bindId];\n\t\t\t}\n\t\t}\n\t\tdelete cbBindingsStore[binding.cbId];\n\t}\n}\n\nfunction $unlink(to) {\n\tif (to) {\n\t\tto = to.jquery ? to : $(to);\n\t\tto.each(function() {\n\t\t\tvar innerView;\n\t\t\t//TODO fix this for better perf. Rather that calling inner view multiple times which does querySelectorAll each time, consider a single querySelectorAll\n\t\t\t// or simply call view.removeViews() on the top-level views under the target 'to' node, then clean(...)\n\t\t\t// And/or replace each() by for() or while()\n\t\t\twhile ((innerView = $view(this, true)) && innerView.parent) {\n\t\t\t\tinnerView.parent.removeViews(innerView._.key, undefined, true);\n\t\t\t}\n\t\t\tclean(this.getElementsByTagName(\"*\"));\n\t\t});\n\t\tclean(to);\n\t} else {\n\t\t// Call to $.unlink() is equivalent to $.unlink(true, \"body\")\n\t\tif (activeBody) {\n\t\t\t$(activeBody)\n\t\t\t\t.off(elementChangeStr, onElemChange)\n\t\t\t\t.off('blur.jsv', '[contenteditable]', onElemChange);\n\t\t\tactiveBody = undefined;\n\t\t}\n\t\ttopView.removeViews();\n\t\tclean(document.body.getElementsByTagName(\"*\"));\n\t}\n}\n\n//========\n// Helpers\n//========\n\nfunction inputAttrib(elem) {\n\treturn elem.type === CHECKBOX ? elem[CHECKED] : elem.value;\n}\n\nfunction changeHandler(view, name, tag) {\n\t// Get onBeforeChange, onAfterChange, onAfterCreate handler - if there is one;\n\treturn tag && tag[name] || view.ctx[name] && view.ctxPrm(name) || $views.helpers[name];\n}\n\n//========================== Initialize ==========================\n\n//=====================\n// JsRender integration\n//=====================\n\naddLinkMethods($sub.View.prototype); // Modify the View prototype to include link methods\n\n$sub.onStore.template = function(name, item, parentTmpl) {\n\tif (item === null) {\n\t\tdelete $.link[name];\n\t\tdelete $.render[name];\n\t} else {\n\t\titem.link = tmplLink;\n\n\t\tif (name && !parentTmpl && name !== \"jsvTmpl\") {\n\t\t\t$.render[name] = item;\n\t\t\t$.link[name] = function() {\n\t\t\t\treturn tmplLink.apply(item, arguments);\n\t\t\t};\n\t\t}\n\t}\n};\n\n$sub.viewInfos = viewInfos; // Expose viewInfos() as public helper method\n\n// Define JsViews version of delimiters(), and initialize\n($viewsSettings.delimiters = function() {\n\t// Run delimiters initialization in context of jsrender.js\n\tvar ret = oldJsvDelimiters.apply(0, arguments);\n\n\tif (oldJsvDelimiters !== $viewsDelimiters) {\n\t\t// If JsRender was loaded before JsViews, then need also to initialize and set globals in that JsRender instance\n\t\tret = $viewsDelimiters.apply(0, arguments);\n\t}\n\n\t// Data-linking must use new delimiters\n\trTagDatalink = new RegExp(\"(?:^|\\\\s*)([\\\\w-]*)(\\\\\" + linkChar + \")?(\\\\\" + delimOpenChar1 + $sub.rTag + \"(:\\\\w*)?\\\\\" + delimCloseChar0 + \")\", \"g\");\n\treturn ret;\n})(); // jshint ignore:line\n\n$sub.addSetting(\"trigger\");\n\n//====================================\n// Additional members for linked views\n//====================================\n\nfunction transferViewTokens(prevNode, nextNode, parentElem, id, viewOrTagChar, refresh) {\n\t// Transfer tokens on prevNode of viewToRemove/viewToRefresh to nextNode or parentElem._df\n\t// view marker tokens: #m_...VIEW.../m_\n\t// tag marker tokens: #m^...TAG..../m^\n\n\tvar i, l, vwInfos, vwInfo, viewOrTag, viewId, tokens,\n\t\tprecedingLength = 0,\n\t\temptyView = prevNode === nextNode;\n\n\tif (prevNode) {\n\t\t// prevNode is either the first node in the viewOrTag, or has been replaced by the vwInfos tokens string\n\t\tvwInfos = viewInfos(prevNode) || [];\n\t\tfor (i = 0, l = vwInfos.length; i < l; i++) {\n\t\t\t// Step through views or tags on the prevNode\n\t\t\tvwInfo = vwInfos[i];\n\t\t\tviewId = vwInfo.id;\n\t\t\tif (viewId === id && vwInfo.ch === viewOrTagChar) {\n\t\t\t\tif (refresh) {\n\t\t\t\t\t// This is viewOrTagToRefresh, this is the last viewOrTag to process...\n\t\t\t\t\tl = 0;\n\t\t\t\t} else {\n\t\t\t\t\t// This is viewOrTagToRemove, so we are done...\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!emptyView) {\n\t\t\t\tviewOrTag = vwInfo.ch === \"_\"\n\t\t\t\t\t? viewStore[viewId]                 // A view: \"#m_\" or \"/m_\"\n\t\t\t\t\t: bindingStore[viewId].linkCtx.tag; // A tag   \"#m^\" or \"/m^\"\n\t\t\t\tif (viewOrTag) {\n\t\t\t\t\tif (vwInfo.open) {                    // A \"#m_\" or \"#m^\" token\n\t\t\t\t\t\tviewOrTag._prv = nextNode;\n\t\t\t\t\t} else if (vwInfo.close) {            // A \"/m_\" or \"/m^\" token\n\t\t\t\t\t\tviewOrTag._nxt = nextNode;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tprecedingLength += viewId.length + 2;\n\t\t}\n\n\t\tif (precedingLength) {\n\t\t\tprevNode.setAttribute(jsvAttrStr, prevNode.getAttribute(jsvAttrStr).slice(precedingLength));\n\t\t}\n\t\ttokens = nextNode ? nextNode.getAttribute(jsvAttrStr) : parentElem._df;\n\t\tif (l = tokens.indexOf(\"/\" + id + viewOrTagChar) + 1) {\n\t\t\ttokens = vwInfos._tkns.slice(0, precedingLength) + tokens.slice(l + (refresh ? -1 : id.length + 1));\n\t\t}\n\t\tif (tokens) {\n\t\t\tif (nextNode) {\n\t\t\t\t// If viewOrTagToRemove was an empty viewOrTag, we will remove both #n and /n\n\t\t\t\t// (and any intervening tokens) from the nextNode (=== prevNode)\n\t\t\t\t// If viewOrTagToRemove was not empty, we will take tokens preceding #n from prevNode,\n\t\t\t\t// and concatenate with tokens following /n on nextNode\n\t\t\t\tnextNode.setAttribute(jsvAttrStr, tokens);\n\t\t\t} else {\n\t\t\t\tsetDefer(parentElem, tokens);\n\t\t\t}\n\t\t}\n\t} else {\n\t\t// !prevNode, so there may be a deferred nodes token on the parentElem. Remove it.\n\t\tsetDefer(parentElem, removeSubStr(parentElem._df, \"#\" + id + viewOrTagChar));\n\t\tif (!refresh && !nextNode) {\n\t\t\t// If this viewOrTag is being removed, and there was no .nxt, remove closing token from deferred tokens\n\t\t\tsetDefer(parentElem, removeSubStr(parentElem._df, \"/\" + id + viewOrTagChar));\n\t\t}\n\t}\n}\n\nfunction disposeTokens(tokens, elem) {\n\tvar i, l, vwItem, vwInfos;\n\tif (vwInfos = viewInfos(tokens, true, rOpenMarkers)) {\n\t\tfor (i = 0, l = vwInfos.length; i < l; i++) {\n\t\t\tvwItem = vwInfos[i];\n\t\t\tif (vwItem.ch === \"_\") {\n\t\t\t\tif ((vwItem = viewStore[vwItem.id]) && vwItem.type && (!elem || vwItem._prv === elem || vwItem.parentElem === elem )) {\n\t\t\t\t\t// If this is the _prv (prevNode) for a view, remove the view\n\t\t\t\t\t// - unless view.type is undefined, in which case it is already being removed\n\t\t\t\t\t// (or unless the elem is not related - e.g. a cloned element which 'accidentally' picked up the data-jsv atttribute of the ._df expando)\n\t\t\t\t\tvwItem.parent.removeViews(vwItem._.key, undefined, true);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tremoveViewBinding(vwItem.id, undefined, elem); // unbind bindings with this bindingId on this view\n\t\t\t}\n\t\t}\n\t}\n}\n\n//============================================\n// Add link methods to data-linked view or tag\n//============================================\n\nfunction updateValue(val, index, tagElse, async, bindId, ev) {\n// async, bindId and ev not documented - used internally, e.g. for paged and sorted arrays on tags with dataMap, such as {{for}}\n// Observably update a data value targeted by the binding.to binding of a 2way data-link binding. Called when elem changes\n// Called when linkedElem of a tag control changes: as updateValue(val, index, tagElse, bindId, ev) - this: undefined\n// Called directly as tag.updateValue(val, index, tagElse) - this: tag\n\tvar self = this,\n\t\tvalues = [];\n\tif (self && self._tgId) {\n\t\tbindId = self;\n\t}\n\tvalues[index||0] = val;\n\tif (async) {\n\t\tsetTimeout(function() {\n\t\t\tupdateValues(values, tagElse, bindId, ev);\n\t\t});\n\t} else {\n\t\tupdateValues(values, tagElse, bindId, ev);\n\t}\n\treturn self;\n}\n\nfunction setValues() {\n// tagCtx.setValues() calls tag.setValue() on that tagCtx for each bindTo target\n\tvar m = arguments.length;\n\twhile (m--) {\n\t\tthis.tag.setValue(arguments[m], m, this.index);\n\t}\n}\n\nfunction addLinkMethods(tagOrView) { // tagOrView is View prototype or tag instance\n\n\tvar l, m, tagCtx, boundProps, bindFrom, key, theTag, theView;\n\n\ttagOrView.contents = function(deep, select) {\n\t\t// For a view, a tag or a tagCtx, return jQuery object with the content nodes,\n\t\tif (deep !== !!deep) {\n\t\t\t// deep not boolean, so this is contents(selector)\n\t\t\tselect = deep;\n\t\t\tdeep = undefined;\n\t\t}\n\t\tvar filtered,\n\t\t\tnodes = $(this.nodes());\n\t\tif (nodes[0]) {\n\t\t\tfiltered = select ? nodes.filter(select) : nodes;\n\t\t\tnodes = deep && select ? filtered.add(nodes.find(select)) : filtered;\n\t\t}\n\t\treturn nodes;\n\t};\n\n\ttagOrView.nodes = function(withMarkers, prevNode, nextNode) {\n\t\t// For a view, a tag or a tagCtx, return top-level nodes\n\t\t// Do not return any script marker nodes, unless withMarkers is true\n\t\t// Optionally limit range, by passing in prevNode or nextNode parameters\n\n\t\tvar node,\n\t\t\tself = this.contentView || this, // If tagCtx, use tagCtx.contentView\n\t\t\telCnt = self._elCnt,\n\t\t\tprevIsFirstNode = !prevNode && elCnt,\n\t\t\tnodes = [];\n\n\t\tif (!self.args) { // If tagCtx with no content (so no contentView) self is tagCtx: return empty [];\n\t\t\tprevNode = prevNode || self._prv;\n\t\t\tnextNode = nextNode || self._nxt;\n\n\t\t\tnode = prevIsFirstNode\n\t\t\t\t? (prevNode === self._nxt\n\t\t\t\t\t? self.parentElem.lastSibling\n\t\t\t\t\t: prevNode)\n\t\t\t\t: (self.inline === false\n\t\t\t\t\t? prevNode || self.linkCtx.elem.firstChild\n\t\t\t\t\t: prevNode && prevNode.nextSibling);\n\n\t\t\twhile (node && (!nextNode || node !== nextNode)) {\n\t\t\t\tif (withMarkers || elCnt || node.tagName !== SCRIPT) {\n\t\t\t\t\t// All the top-level nodes in the view\n\t\t\t\t\t// (except script marker nodes, unless withMarkers = true)\n\t\t\t\t\t// (Note: If a script marker node, viewInfo.elCnt undefined)\n\t\t\t\t\tnodes.push(node);\n\t\t\t\t}\n\t\t\t\tnode = node.nextSibling;\n\t\t\t}\n\t\t}\n\t\treturn nodes;\n\t};\n\n\ttagOrView.childTags = function(deep, tagName) {\n\t\t// For a view, a tag or a tagCtx, return child tags - at any depth, or as immediate children only.\n\t\tif (deep !== !!deep) {\n\t\t\t// deep not boolean, so this is childTags(tagName) - which looks for top-level tags of given tagName\n\t\t\ttagName = deep;\n\t\t\tdeep = undefined;\n\t\t}\n\n\t\tvar self = this.contentView || this, // If tagCtx, use tagCtx.contentView\n\t\t\tview = self.link ? self : self.tagCtx.view, // This may be a view or a tag. If a tag, get the view from tag.tagCtx.view\n\t\t\tprevNode = self._prv,\n\t\t\telCnt = self._elCnt,\n\t\t\ttags = [];\n\n\t\tif (!self.args) { // If tagCtx with no content (so no contentView) self is tagCtx: return empty [];\n\t\t\tview.link(\n\t\t\t\tundefined,\n\t\t\t\tself.parentElem,\n\t\t\t\telCnt ? prevNode && prevNode.previousSibling : prevNode,\n\t\t\t\tself._nxt,\n\t\t\t\tundefined,\n\t\t\t\t{get:{\n\t\t\t\t\ttags: tags,\n\t\t\t\t\tdeep: deep,\n\t\t\t\t\tname: tagName,\n\t\t\t\t\tid: self.link ? self._.id + \"_\" : self._tgId + \"^\"\n\t\t\t\t}}\n\t\t\t);\n\t\t}\n\t\treturn tags;\n\t};\n\n\tif (tagOrView._is === \"tag\") {\n\t\t//=======================\n\t\t// This is a TAG instance\n\t\t//=======================\n\n\t\ttheTag = tagOrView;\n\n\t\tm = theTag.tagCtxs.length;\n\t\twhile (m--) {\n\t\t\ttagCtx = theTag.tagCtxs[m];\n\n\t\t\ttagCtx.setValues = setValues;\n\t\t\ttagCtx.contents = tagOrView.contents;\n\t\t\ttagCtx.childTags = tagOrView.childTags;\n\t\t\ttagCtx.nodes = tagOrView.nodes;\n\t\t}\n\n\t\tboundProps = theTag.boundProps = theTag.boundProps || [];\n\t\tif (bindFrom = theTag.bindFrom) {\n\t\t\tl = bindFrom.length;\n\t\t\twhile (l--) {\n\t\t\t\tkey = bindFrom[l];\n\t\t\t\tif (key + \"\" === key) {\n\t\t\t\t\tbindFrom[key] = 1;\n\t\t\t\t\tif ($inArray(key, boundProps) < 0) {\n\t\t\t\t\t\tboundProps.push(key); // Add any 'bindFrom' props to boundProps array. (So two-way binding works without writing ^foo=expression)\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\ttheTag.setValue = $sub._gm( // getMethod\n\t\t\ttheTag.constructor.prototype.setValue || function(val) { // base method\n\t\t\t\treturn val;\n\t\t\t},\n\t\t\tfunction(val, indexFrom, tagElse) {\n\t\t\t\tindexFrom = indexFrom || 0;\n\t\t\t\ttagElse = tagElse || 0;\n\n\t\t\t\tvar linkedElem, linkedEl, linkedCtxParam, linkedCtxPrmKey, indexTo, linkedElems,\n\t\t\t\t\ttagCtx = theTag.tagCtxs[tagElse],\n\t\t\t\t\tnewVal = theTag.base.call(theTag, val, indexFrom, tagElse);\n\n\t\t\t\tif (newVal !== undefined) {  // Call tag method tag.setValue(), if implemented\n\t\t\t\t\tval = newVal;\n\t\t\t\t}\n\t\t\t\tif (val !== undefined && (theTag.convert || theTag._.toIndex[indexFrom] === undefined)\n\t\t\t\t\t\t&& (linkedCtxParam = theTag.linkedCtxParam)\n\t\t\t\t\t\t&& linkedCtxParam[indexFrom]\n\t\t\t\t\t\t// If this setValue call corresponds to a tag contextual parameter and the tag has a converter, then we need to set the\n\t\t\t\t\t\t// value of this contextual parameter (since it is not directly bound to the tag argument/property when there is a converter).\n\t\t\t\t\t\t&& (linkedCtxPrmKey = linkedCtxParam[indexFrom])\n\t\t\t\t\t) {\n\t\t\t\t\ttagCtx.ctxPrm(linkedCtxPrmKey, val);\n\t\t\t\t}\n\t\t\t\tindexTo = theTag._.toIndex[indexFrom];\n\t\t\t\tif (indexTo !== undefined) {\n\t\t\t\t\tif (linkedElems = tagCtx.linkedElems || theTag.linkedElem && [theTag.linkedElem]) {\n\t\t\t\t\t\tif ((linkedElem = linkedElems[indexTo]) && (l = linkedElem.length)) {\n\t\t\t\t\t\t\twhile (l--) {\n\t\t\t\t\t\t\t\tlinkedEl = linkedElem[l];\n\t\t\t\t\t\t\t\tif (val !== undefined && !linkedEl._jsvChg && theTag.linkCtx._val !== val) {\n\t\t\t\t\t\t\t\t\tif (linkedEl.value !== undefined) {\n\t\t\t\t\t\t\t\t\t\tif (linkedEl.type === CHECKBOX) {\n\t\t\t\t\t\t\t\t\t\t\tlinkedEl[CHECKED] = val && val !== \"false\";\n\t\t\t\t\t\t\t\t\t\t} else if (linkedEl.type === RADIO) {\n\t\t\t\t\t\t\t\t\t\t\tlinkedEl[CHECKED] = (linkedEl.value === val);\n\t\t\t\t\t\t\t\t\t\t} else if ($isArray(val)) {\n\t\t\t\t\t\t\t\t\t\t\tlinkedEl.value = val; // Don't use jQuery since it replaces array by mapped clone\n\t\t\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\t\t\t$(linkedEl).val(val); // Use jQuery for attrHooks - can't just set value (on select, for example)\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\t\tlinkedEl[linkedEl.contentEditable === TRUE ? \"innerHTML\" : TEXTCONTENT] = val;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tif (tagCtx.props.name) {\n\t\t\t\t\t\t\t\t\tlinkedEl.name = linkedEl.name || tagCtx.props.name;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn theTag;\n\t\t\t}\n\t\t);\n\t\ttheTag.updateValue = updateValue;\n\n\t\ttheTag.updateValues = function() {\n\t\t\treturn updateValues(arguments, undefined, this);\n\t\t};\n\n\t\ttheTag.setValues = function() {\n\t\t// tag.setValues(a, b, c) calls tagCtx.setValues(a, b, c)  on the first tagCtx\n\t\t\tsetValues.apply(theTag.tagCtx, arguments);\n\t\t\treturn theTag;\n\t\t};\n\n\t\ttheTag.refresh = function() {\n\t\t\tvar attr, sourceValue,\n\t\t\t\tlinkCtx = theTag.linkCtx,\n\t\t\t\tview = theTag.tagCtx.view;\n\n\t\t\tif (!(sourceValue = mergeCtxs(theTag))) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif (theTag.onUnbind) {\n\t\t\t\ttheTag.onUnbind(theTag.tagCtx, linkCtx, theTag.ctx);\n\t\t\t\ttheTag._.unlinked = true;\n\t\t\t}\n\t\t\tattr = theTag.inline ? HTML : (linkCtx.attr || defaultAttr(theTag.parentElem, true));\n\t\t\tsourceValue = theTag.tagName === \":\"\n\t\t\t\t? $sub._cnvt(theTag.convert, view, theTag.tagCtx)\n\t\t\t\t: $sub._tag(theTag, view, view.tmpl, sourceValue, true); // Get rendered HTML for tag, based on refreshed tagCtxs\n\n\t\t\tobserveAndBind(linkCtx, linkCtx.data, linkCtx.elem);\n\t\t\tupdateContent(sourceValue, linkCtx, attr, theTag);\n\t\t\tcallAfterLink(theTag);\n\t\t\treturn theTag;\n\t\t};\n\n\t\ttheTag.domChange = function() { // domChange notification support\n\t\t\tvar elem = this.parentElem,\n\t\t\t\thasListener = $._data(elem).events,\n\t\t\t\tdomChangeNotification = \"jsv-domchange\";\n\n\t\t\tif (hasListener && hasListener[domChangeNotification]) {\n\t\t\t\t// Only trigger handler if there is a handler listening for this event. (Note using triggerHandler - so no event bubbling.)\n\t\t\t\t$(elem).triggerHandler(domChangeNotification, arguments);\n\t\t\t}\n\t\t};\n\n\t\t//====================================\n\t\t// End of added link methods for TAG\n\t\t//====================================\n\t} else {\n\t\t//=========================\n\t\t// This is a VIEW prototype\n\t\t//=========================\n\n\t\ttheView = tagOrView;\n\n\t\t// Note: a linked view will also, after linking have nodes[], _prv (prevNode), _nxt (nextNode) ...\n\t\ttheView.addViews = function(index, dataItems) {\n\t\t\t// if view is not an array view, do nothing\n\t\t\tvar i, viewsCount,\n\t\t\t\tview = this,\n\t\t\t\titemsCount = dataItems.length,\n\t\t\t\tviews = view.views;\n\n\t\t\tif (!view._.useKey && itemsCount) {\n\t\t\t\t// view is of type \"array\"\n\t\t\t\tviewsCount = views.length + itemsCount;\n\n\t\t\t\tif (viewsCount === view.data.length // If views not already synced to array (e.g. triggered by array.length propertyChange - jsviews/issues/301)\n\t\t\t\t\t\t&& renderAndLink(view, index, view.tmpl, views, dataItems, view.ctx) !== false) {\n\t\t\t\t\tif (!view._.srt) { // Not part of a 'sort' on refresh\n\t\t\t\t\t\tview.fixIndex(index + itemsCount);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\n\t\ttheView.removeViews = function(index, itemsCount, keepNodes, isMove) {\n\t\t\t// view.removeViews() removes all the child views\n\t\t\t// view.removeViews(index) removes the child view with specified index or key\n\t\t\t// view.removeViews(index, count) removes the specified nummber of child views, starting with the specified index\n\t\t\tfunction removeView(index) {\n\t\t\t\tvar id, bindId, parentElem, prevNode, nextNode, nodesToRemove,\n\t\t\t\t\tviewToRemove = views[index];\n\n\t\t\t\tif (viewToRemove && viewToRemove.link) {\n\t\t\t\t\tid = viewToRemove._.id;\n\t\t\t\t\tif (!keepNodes) {\n\t\t\t\t\t\t// Remove the HTML nodes from the DOM, unless they have already been removed, including nodes of child views\n\t\t\t\t\t\tnodesToRemove = viewToRemove.nodes();\n\t\t\t\t\t}\n\n\t\t\t\t\t// Remove child views, without removing nodes\n\t\t\t\t\tviewToRemove.removeViews(undefined, undefined, true);\n\n\t\t\t\t\tviewToRemove.type = undefined; // Set type to undefined: used as a flag that this view is being removed\n\t\t\t\t\tprevNode = viewToRemove._prv;\n\t\t\t\t\tnextNode = viewToRemove._nxt;\n\t\t\t\t\tparentElem = viewToRemove.parentElem;\n\t\t\t\t\t// If prevNode and nextNode are the same, the view is empty\n\t\t\t\t\tif (!keepNodes) {\n\t\t\t\t\t\t// Remove the HTML nodes from the DOM, unless they have already been removed, including nodes of child views\n\t\t\t\t\t\tif (viewToRemove._elCnt) {\n\t\t\t\t\t\t\t// if keepNodes is false (and transferring of tokens has not already been done at a higher level)\n\t\t\t\t\t\t\t// then transfer tokens from prevNode which is being removed, to nextNode.\n\t\t\t\t\t\t\ttransferViewTokens(prevNode, nextNode, parentElem, id, \"_\");\n\t\t\t\t\t\t}\n\t\t\t\t\t\t$(nodesToRemove).remove();\n\t\t\t\t\t}\n\t\t\t\t\tif (!viewToRemove._elCnt) {\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\tprevNode.parentNode.removeChild(prevNode); // (prevNode.parentNode is parentElem, except if jQuery Mobile or similar has inserted an intermediate wrapper\n\t\t\t\t\t\t\tnextNode.parentNode.removeChild(nextNode);\n\t\t\t\t\t\t} catch (e) {}\n\t\t\t\t\t}\n\t\t\t\t\tsetArrayChangeLink(viewToRemove);\n\t\t\t\t\tfor (bindId in viewToRemove._.bnds) {\n\t\t\t\t\t\tremoveViewBinding(bindId);\n\t\t\t\t\t}\n\t\t\t\t\tdelete viewStore[id];\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tvar current, childView, viewsCount,\n\t\t\t\tview = this,\n\t\t\t\tisArray = !view._.useKey,\n\t\t\t\tviews = view.views;\n\n\t\t\tif (isArray) {\n\t\t\t\tviewsCount = views.length;\n\t\t\t}\n\t\t\tif (index === undefined) {\n\t\t\t\t// Remove all child views\n\t\t\t\tif (isArray) {\n\t\t\t\t\t// views and data are arrays\n\t\t\t\t\tcurrent = viewsCount;\n\t\t\t\t\twhile (current--) {\n\t\t\t\t\t\tremoveView(current);\n\t\t\t\t\t}\n\t\t\t\t\tview.views = [];\n\t\t\t\t} else {\n\t\t\t\t\t// views and data are objects\n\t\t\t\t\tfor (childView in views) {\n\t\t\t\t\t\t// Remove by key\n\t\t\t\t\t\tremoveView(childView);\n\t\t\t\t\t}\n\t\t\t\t\tview.views = {};\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif (itemsCount === undefined) {\n\t\t\t\t\tif (isArray) {\n\t\t\t\t\t\t// The parentView is data array view.\n\t\t\t\t\t\t// Set itemsCount to 1, to remove this item\n\t\t\t\t\t\titemsCount = 1;\n\t\t\t\t\t} else {\n\t\t\t\t\t\t// Remove child view with key 'index'\n\t\t\t\t\t\tremoveView(index);\n\t\t\t\t\t\tdelete views[index];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (isArray && itemsCount\n\t\t\t\t\t&& (isMove || viewsCount - itemsCount === view.data.length)) { // If views not already synced to array (e.g. triggered by array.length propertyChange - jsviews/issues/301)\n\t\t\t\t\tcurrent = index + itemsCount;\n\t\t\t\t\t// Remove indexed items (parentView is data array view);\n\t\t\t\t\twhile (current-- > index) {\n\t\t\t\t\t\tremoveView(current);\n\t\t\t\t\t}\n\t\t\t\t\tviews.splice(index, itemsCount);\n\t\t\t\t\tif (!view._.srt) {\n\t\t\t\t\t\tview.fixIndex(index);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\n\t\ttheView.moveViews = function(oldIndex, index, itemsCount) {\n\t\t\tfunction parts(itemView, str) { // Get the totkens preceding the 'open' token for this view, #n_, and the tokens following (and including) the 'open' token\n\t\t\t\treturn RegExp(\"^(.*)(\" + (str ? \"\\\\/\" : \"#\") + itemView._.id + \"_.*)$\").exec(str || itemView._prv.getAttribute(jsvAttrStr));\n\t\t\t}\n\t\t\tfunction setPrv(itemView, tokens) {\n\t\t\t\tvar prv = itemView._prv;\n\t\t\t\tprv.setAttribute(jsvAttrStr, tokens);\n\t\t\t\ttokens.replace(rTagMarkers, function(all, open, close, id) {\n\t\t\t\t\tbindingStore[id].linkCtx.tag[open ? \"_prv\" : \"_nxt\"] = prv;\n\t\t\t\t});\n\t\t\t\ttokens.replace(rViewMarkers, function(all, open, close, id) {\n\t\t\t\t\tviewStore[id][open ? \"_prv\" : \"_nxt\"] = prv;\n\t\t\t\t});\n\t\t\t}\n\t\t\tvar nodes, childView, nxtView, insertBefore, viewId,\n\t\t\t\tview = this,\n\t\t\t\tselfNxt = view._nxt,\n\t\t\t\tviews = view.views,\n\t\t\t\tbackwards = index < oldIndex,\n\t\t\t\tfirstChange = backwards ? index : oldIndex,\n\t\t\t\tlastChange = backwards ? oldIndex : index,\n\t\t\t\ti = index,\n\t\t\t\tmovedNodes = [],\n\n\t\t\t\tviewsToMove = views.splice(oldIndex, itemsCount); // remove\n\n\t\t\tif (index > views.length) {\n\t\t\t\tindex = views.length;\n\t\t\t}\n\t\t\tviews.splice.apply(views, [index, 0].concat(viewsToMove)); //re-insert\n\n\t\t\titemsCount = viewsToMove.length;\n\t\t\tinsertBefore = index + itemsCount;\n\t\t\tlastChange += itemsCount;\n\n\t\t\tfor (i; i < insertBefore; i++) {\n\t\t\t\tchildView = views[i];\n\t\t\t\tnodes = childView.nodes(true);\n\t\t\t\tmovedNodes = view._elCnt ? movedNodes.concat(nodes) : movedNodes.concat(childView._prv, nodes, childView._nxt);\n\t\t\t}\n\t\t\tmovedNodes = $(movedNodes);\n\n\t\t\tif (insertBefore < views.length) {\n\t\t\t\tmovedNodes.insertBefore(views[insertBefore]._prv);\n\t\t\t} else if (selfNxt) {\n\t\t\t\tmovedNodes.insertBefore(selfNxt);\n\t\t\t} else {\n\t\t\t\tmovedNodes.appendTo(view.parentElem);\n\t\t\t}\n\n\t\t\tif (view._elCnt) {\n\t\t\t\tvar afterParts,\n\t\t\t\t\tendChange = backwards ? firstChange + itemsCount : lastChange - itemsCount,\n\t\t\t\t\tbeforeView = views[firstChange-1],\n\t\t\t\t\tstartView = views[firstChange],\n\t\t\t\t\tendView = views[endChange],\n\t\t\t\t\tafterView = views[lastChange],\n\t\t\t\t\tstartParts = parts(startView),\n\t\t\t\t\tendParts = parts(endView);\n\n\t\t\t\tsetPrv(startView, endParts[1] + startParts[2]);\n\t\t\t\tif (afterView) {\n\t\t\t\t\tafterParts = parts(afterView);\n\t\t\t\t\tsetPrv(afterView, startParts[1] + afterParts[2]);\n\t\t\t\t} else {\n\t\t\t\t\tviews[lastChange-1]._nxt = selfNxt;\n\t\t\t\t\tif (selfNxt) {\n\t\t\t\t\t\tafterParts = parts(view, selfNxt.getAttribute(jsvAttrStr));\n\t\t\t\t\t\tselfNxt.setAttribute(jsvAttrStr, startParts[1] + afterParts[2]);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tafterParts = parts(view, view.parentElem._df);\n\n\t\t\t\t\t\tsetDefer(view.parentElem, startParts[1] + afterParts[2]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tsetPrv(endView, afterParts[1] + endParts[2]);\n\t\t\t}\n\t\t\tview.fixIndex(firstChange);\n\t\t};\n\n\t\ttheView.refresh = function() {\n\t\t\tvar view = this,\n\t\t\t\tparent = view.parent;\n\n\t\t\tif (parent) {\n\t\t\t\trenderAndLink(view, view.index, view.tmpl, parent.views, view.data, undefined, true);\n\t\t\t\tsetArrayChangeLink(view);\n\t\t\t}\n\t\t\treturn view;\n\t\t};\n\n\t\ttheView.fixIndex = function(fromIndex) {\n\t\t\t// Fixup index on following view items...\n\t\t\tvar views = this.views,\n\t\t\t\tindex = views.length;\n\t\t\twhile (fromIndex < index--) {\n\t\t\t\tif (views[index].index !== index) {\n\t\t\t\t\t$observable(views[index]).setProperty(\"index\", index);\n\t\t\t\t\t// This is fixing up index, but not key, and not index on child views. From child views, use view.getIndex()\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\n\t\ttheView.link = viewLink;\n\n\t\t//====================================\n\t\t// End of added link methods for VIEW\n\t\t//====================================\n\t}\n}\n\n//========================\n// JsViews-specific converters\n//========================\n\n$converters.merge = function(val) {\n\t// Special converter used in data-linking to space-separated lists, such as className:\n\t// Currently only supports toggle semantics - and has no effect if toggle string is not specified\n\t// data-link=\"class{merge:boolExpr toggle=className}\"\n\tvar regularExpression,\n\t\tcurrentValue = this.linkCtx.elem.className,\n\t\ttoggle = this.tagCtx.props.toggle;\n\n\tif (toggle) {\n\t\t// We are toggling the class specified by the toggle property,\n\t\t// and the boolean val binding is driving the insert/remove toggle\n\n\t\tregularExpression = toggle.replace(/[\\\\^$.|?*+()[{]/g, \"\\\\$&\");\n\t\t// Escape any regular expression special characters (metacharacters) within the toggle string\n\t\tregularExpression = \"(\\\\s(?=\" + regularExpression + \"$)|(\\\\s)|^)(\" + regularExpression + \"(\\\\s|$))\";\n\t\t// Example: /(\\s(?=myclass$)|(\\s)|^)?(myclass(\\s|$))/ - so matches (\" myclass\" or \" \" or ^ ) followed by (\"myclass \" or \"myclass$\") where ^/$ are beginning/end of string\n\t\tcurrentValue = currentValue.replace(new RegExp(regularExpression), \"$2\");\n\t\tval = currentValue + (val ? (currentValue && \" \") + toggle : \"\");\n\t}\n\treturn val;\n};\n\n//========================\n// JsViews-specific tags\n//========================\n\n$tags({\n\ton: {\n\t\tattr: NONE,\n\t\tbindTo: [], // Don't need to bind to first arg, so prevent the default [0] binding\n\t\tinit: function(tagCtx) {\n\t\t\tvar content,\n\t\t\t\ttag = this,\n\t\t\t\ti = 0,\n\t\t\t\targs = tagCtx.args, // [events,] [selector,] handler\n\t\t\t\tl = args.length;\n\n\t\t\tfor (; i<l && !$isFunction(args[i]); i++); // Handler is first arg of type function\n\t\t\ttag._hi = l>i && i+1; // handler index\n\t\t\tif (tag.inline) {\n\t\t\t\tif (!$sub.rTmpl.exec(content = $.trim(tagCtx.tmpl.markup))) {\n\t\t\t\t\t// Inline {^{on}} tag with no content (or external template content) or with content containing\n\t\t\t\t\t// no HTML or JsRender tags: We will wrap the (text) content, or the operation name in a <button> element\n\t\t\t\t\t// (Otherwise we will attach the handler to the element content after data-linking)\n\t\t\t\t\ttag.template = \"<button>\" + (content || tagCtx.params.args[i] || \"noop\") + \"</button>\";\n\t\t\t\t}\n\t\t\t\ttag.attr = HTML;\n\t\t\t}\n\t\t},\n\t\tonBind: function() {\n\t\t\tif (this.template) { // {^{on/}} with no content has template rendering <button>. Make it the mainElem, so we can set id, size or class\n\t\t\t\tthis.mainElem = this.contents(\"button\");\n\t\t\t}\n\t\t},\n\t\tonAfterLink: function(tagCtx, linkCtx) {\n\t\t\tvar handler, params, find, activeElem,\n\t\t\t\ttag = this,\n\t\t\t\ti = tag._hi,\n\t\t\t\targs = tagCtx.args, // [events,] [selector,] handler\n\t\t\t\tl = args.length,\n\t\t\t\tprops = tagCtx.props,\n\t\t\t\tdata = props.data,\n\t\t\t\tview = tagCtx.view,\n\t\t\t\tcontextOb = props.context; // Context ('this' pointer) for attached handler\n\n\t\t\tif (i) { // There is a handler\n\t\t\t\thandler = args[i-1];\n\t\t\t\tparams = args.slice(i); // Subsequent args are params\n\t\t\t\targs = args.slice(0, i-1); // Preceding args (if any) are events and selector\n\t\t\t\ttag._sel = args[1]; // Selector for descendant elements - for delegated events on those elements, delegating to the activeElem\n\n\t\t\t\tactiveElem = tag.activeElem = tag.activeElem || $(tag.inline\n\t\t\t\t\t? (tag._sel = args[1] || \"*\", tag.parentElem)\n\t\t\t\t\t// If inline, attach to child elements of tag parent element (filtered by selector argument if provided.\n\t\t\t\t\t// (In handler we'll filter out events from sibling elements preceding or following tag.)\n\t\t\t\t\t// This allows us to use the delegated pattern where the attached event works even for added elements satisfying the selector\n\t\t\t\t\t: linkCtx.elem);\n\n\t\t\t\tif (!contextOb) {\n\t\t\t\t\t// Get the path for the preceding object (context object) of handler (which is the last arg), compile function\n\t\t\t\t\t// to return that context object, and run compiled function against data\n\t\t\t\t\tcontextOb = /^(.*)[.^][\\w$]+$/.exec(tagCtx.params.args.slice(-params.length - 1)[0]);\n\t\t\t\t\tcontextOb = contextOb && $sub.tmplFn(delimOpenChar1 + \":\" + contextOb[1] + delimCloseChar0, view.tmpl, true)(linkCtx.data, view);\n\t\t\t\t}\n\n\t\t\t\tif (tag._evs) {\n\t\t\t\t\ttag.onUnbind(tagCtx, linkCtx, tag.ctx);\n\t\t\t\t}\n\n\t\t\t\tactiveElem.on(\n\t\t\t\t\ttag._evs = args[0] || \"click\", // events defaults to \"click\"\n\t\t\t\t\ttag._sel,\n\t\t\t\t\tdata == undefined ? null : data,\n\t\t\t\t\ttag._hlr = function hndlr(ev) {\n\t\t\t\t\t\tvar nodes, length,\n\t\t\t\t\t\t\tfound = !tag.inline;\n\n\t\t\t\t\t\tif (!found) { // If inline, filter out events from sibling elements preceding or following tag.\n\t\t\t\t\t\t\tnodes = tag.contents(\"*\");\n\t\t\t\t\t\t\tl = nodes.length;\n\t\t\t\t\t\t\twhile (!found && l--) {\n\t\t\t\t\t\t\t\tif (nodes[l].contains(ev.target)) {\n\t\t\t\t\t\t\t\t\tfound = true;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (found) { // target elem is indeed within the tag, so call the {on} handler\n\t\t\t\t\t\t\treturn handler.apply(contextOb || linkCtx.data, [].concat(\n\t\t\t\t\t\t\t\tparams, // e.g. par1, par2\n\t\t\t\t\t\t\t\tev,\n\t\t\t\t\t\t\t\t{change: ev.type, view: view, linkCtx: linkCtx},\n\t\t\t\t\t\t\t\tparams.slice.call(arguments, 1) // If triggering event (e.g. jsv-domchange) has additional arguments after ev, pass them too\n\t\t\t\t\t\t\t));\n\t\t\t\t\t\t\t// for {on 'click' handler par1 par2} use handler(par1, par2, ev, domchangeEventArgs)\n\t\t\t\t\t\t\t// for {on 'jsv-domchange' handler par1 par2} use handler(par1, par2, ev, domchangeEventArgs, tagCtx, linkCtx, observableEventArgs)\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t);\n\t\t\t}\n\t\t},\n\t\tonUpdate: false,\n\t\tonUnbind: function() {\n\t\t\tvar self = this,\n\t\t\t\toldIsCleanCall = isCleanCall;\n\t\t\tif (self.activeElem) {\n\t\t\t\tisCleanCall = 0; // Needed when using jquery-1.x, to avoid bug where jQuery calls cleanData on elements that are not being removed\n\t\t\t\tself.activeElem.off(self._evs, self._sel, self._hlr);\n\t\t\t\tisCleanCall = isCleanCall;\n\t\t\t}\n\t\t},\n\t\tcontentCtx: true,\n\t\tsetSize: true,\n\t\tdataBoundOnly: true\n\t},\n\tradiogroup: {\n\t\tboundProps: [\"disabled\"],\n\t\tinit: function(tagCtx) {\n\t\t\tthis.name = tagCtx.props.name || (Math.random() + \"jsv\").slice(9);\n\t\t},\n\t\tonBind: function(tagCtx, linkCtx) {\n\t\t\tvar domChngCntnr, $linkedElem, l,\n\t\t\t\ttag = this,\n\t\t\t\tuseDisable = tagCtx.params.props;\n\t\t\tuseDisable = useDisable && useDisable.disabled;\n\t\t\tif (tag.inline) {\n\t\t\t\t// If the first element is owned by (rendered by) this tag (not by a childTag such as {^{for}})\n\t\t\t\t// use it as container for detecting dom changes\n\t\t\t\tdomChngCntnr = tag.contents(\"*\")[0];\n\t\t\t\tdomChngCntnr = domChngCntnr && $view(domChngCntnr).ctx.tag === tag.parent ? domChngCntnr : tag.parentElem;\n\t\t\t\t$linkedElem = tag.contents(true, \"input[type=radio]\");\n\t\t\t} else {\n\t\t\t\tdomChngCntnr = linkCtx.elem;\n\t\t\t\t$linkedElem = $(\"input[type=radio]\", linkCtx.elem);\n\t\t\t}\n\t\t\ttag.linkedElem = $linkedElem;\n\t\t\tl = $linkedElem.length;\n\t\t\twhile (l--) {\n\t\t\t\t// Configure the name for each radio input element\n\t\t\t\t$linkedElem[l].name = $linkedElem[l].name || tag.name;\n\t\t\t}\n\t\t\t// Establish a domchange listener in case this radiogroup wraps a {^{for}} or {^{if}} or similar which might dynamically insert new radio input elements\n\t\t\t$(domChngCntnr).on(\"jsv-domchange\", function(ev, forOrIfTagCtx) {\n\t\t\t\tvar linkedElem, val,\n\t\t\t\t\tparentTags = forOrIfTagCtx.ctx.parentTags;\n\t\t\t\tif (!tag.inline || domChngCntnr !== tag.parentElem // The domChngCntnr is specific to this tag\n\t\t\t\t\t// The domChngCntnr is the parentElem of this tag, so need to make sure dom change event is for\n\t\t\t\t\t// a content change within this tag, not outside it.\n\t\t\t\t\t|| parentTags && parentTags[tag.tagName] === tag) {\n\t\t\t\t\t// Contents have changed so recreate $linkedElem for the radio input elements (including possible new one just inserted)\n\t\t\t\t\tval = tag.cvtArgs()[0];\n\t\t\t\t\t$linkedElem = tag.linkedElem = tag.contents(true, \"input[type=radio]\");\n\t\t\t\t\tl = $linkedElem.length;\n\t\t\t\t\twhile (l--) {\n\t\t\t\t\t\t// Configure binding and name for each radio input element\n\t\t\t\t\t\tlinkedElem = $linkedElem[l];\n\t\t\t\t\t\tlinkedElem._jsvLkEl = tag;\n\t\t\t\t\t\tlinkedElem.name = linkedElem.name || tag.name;\n\t\t\t\t\t\tlinkedElem._jsvBnd = \"&\" + tag._tgId + \"+\";\n\t\t\t\t\t\tlinkedElem.checked = val === linkedElem.value;\n\t\t\t\t\t\tif (useDisable) {\n\t\t\t\t\t\t\tlinkedElem.disabled = !!tagCtx.props.disabled;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\ttag.linkedElems = tagCtx.linkedElems = [$linkedElem];\n\t\t\t\t}\n\t\t\t});\n\t\t},\n\t\tonAfterLink: function(tagCtx, linkCtx, ctx, ev, eventArgs) {\n\t\t\tvar propParams = tagCtx.params.props;\n\t\t\tif (propParams && propParams.disabled) {\n\t\t\t\tthis.linkedElem.prop(\"disabled\", !!tagCtx.props.disabled);\n\t\t\t}\n\t\t},\n\t\tonUpdate: false, // don't rerender\n\t\tcontentCtx: true,\n\t\tdataBoundOnly: true\n\t}\n});\n\n$extend($tags[\"for\"], {\n\t//onUpdate: function(ev, eventArgs, newTagCtxs) {\n\t\t//Consider adding filtering for perf optimization. However the below prevents update on some scenarios which _should_ update - namely when there is another array on which for also depends.\n\t\t//var i, l, tci, prevArg;\n\t\t//for (tci = 0; (prevArg = this.tagCtxs[tci]) && prevArg.args.length; tci++) {\n\t\t//\tif (prevArg.args[0] !== newTagCtxs[tci].args[0]) {\n\t\t//\t\treturn true;\n\t\t//\t}\n\t\t//}\n\t\t//return false;\n\t//},\n\tsortDataMap: $views.map({\n\t\tgetTgt: $tags[\"for\"].sortDataMap.getTgt, // getTargetSorted\n\t\tobsSrc: function(map, ev, eventArgs) {\n\t\t\tmap.update(); // refresh sorting and filtering\n\t\t},\n\t\tobsTgt: function(map, ev, eventArgs) {\n\t\t\tvar l,\n\t\t\t\titems = eventArgs.items,\n\t\t\t\tsource = map.src;\n\t\t\tif (eventArgs.change === \"remove\") {\n\t\t\t\tl = items.length;\n\t\t\t\twhile (l--) {\n\t\t\t\t\t$observable(source).remove($inArray(items[l], source));\n\t\t\t\t}\n\t\t\t} else if (eventArgs.change === \"insert\") {\n\t\t\t\t$observable(source).insert(items);\n\t\t\t}\n\t\t}\n\t}),\n\tmapProps: [\"filter\", \"sort\", \"reverse\", \"start\", \"end\", \"step\"],\n\tbindTo: [\"paged\", \"sorted\"],\n\tbindFrom: [0],\n\n\tonArrayChange: function(ev, eventArgs, tagCtx, linkCtx) {\n\t\tvar arrayView, propsArr,\n\t\t\ttargetLength = ev.target.length,\n\t\t\ttag = this;\n\t\tif (!tag.rendering) {\n\t\t\tif (tag._.noVws // Child views not supported because target is not html - e.g. data-link=\"title{for ...}\"\n\t\t\t\t|| tag.tagCtxs[1] && ( // There is an {{else}}\n\t\t\t\t\teventArgs.change === \"insert\" && targetLength === eventArgs.items.length // inserting, and new length is same as inserted length, so going from 0 to n\n\t\t\t\t\t|| eventArgs.change === \"remove\" && !targetLength) // removing, and new length 0, so going from n to 0\n\t\t\t\t) {\n\t\t\t\tpropsArr = tagCtx.map && tagCtx.map.propsArr; // Used by {{props}}, which derives from {{for}}\n\t\t\t\ttag.refresh();\n\t\t\t\tif (propsArr) {\n\t\t\t\t\ttagCtx.map.propsArr = propsArr; // Keep previous propsArr with new map\n\t\t\t\t}\n\t\t\t} else for (arrayView in tag._.arrVws) {\n\t\t\t\tarrayView = tag._.arrVws[arrayView];\n\t\t\t\tif (arrayView.data === ev.target) {\n\t\t\t\t\tarrayChangeHandler.apply(arrayView, arguments);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\ttag.domChange(tagCtx, linkCtx, eventArgs);\n\t\tev.done = true;\n\t},\n\tonUpdate: function(ev, eventArgs, tagCtxs) {\n\t\tvar tagCtx, props,\n\t\t\ttag = this,\n\t\t\tl = tagCtxs.length;\n\t\twhile (l--) {\n\t\t\ttagCtx = tagCtxs[l];\n\t\t\tprops = tagCtx.props;\n\t\t\ttagCtx.argDefault = props.end === undefined || tagCtx.args.length > 0; // Default to #data except for auto-create range scenario {{for start=xxx end=yyy step=zzz}}\n\t\t\tprops.dataMap = (tagCtx.argDefault !== false && $isArray(tagCtx.args[0])\n\t\t\t\t&& (props.sort !== undefined || tagCtx.params.props.start || tagCtx.params.props.end || props.step !== undefined || props.filter || props.reverse)) && tag.sortDataMap;\n\t\t}\n\t},\n\tonBind: function(tagCtx, linkCtx, ctx, ev, eventArgs) {\n\t\tvar data,\n\t\t\ttag = this,\n\t\t\ti = 0,\n\t\t\tarrayBindings = tag._ars = tag._ars || {},\n\t\t\ttagCtxs = tag.tagCtxs,\n\t\t\tl = tagCtxs.length,\n\t\t\tselected = tag.selected || 0;\n\n\t\tfor (; i <= selected; i++) {\n\t\t\ttagCtx = tagCtxs[i];    // loop through tagCtxs up to selected\n\t\t\tdata = tagCtx.map\n\t\t\t\t? tagCtx.map.tgt      // 'data' is mapped data\n\t\t\t\t: tagCtx.args.length\n\t\t\t\t\t? tagCtx.args[0]    // or args[0]\n\t\t\t\t\t: tagCtx.view.data; // or defaults to current data.\n\t\t\tif (arrayBindings[i]) { // Is there was a previous binding on this tagCtx, (maybe with data different from new data)\n\t\t\t\t$observe(arrayBindings[i], true); //unobserve previous array\n\t\t\t\tdelete arrayBindings[i];\n\t\t\t}\n\t\t\tif (!arrayBindings[i] && $isArray(data)) {\n\t\t\t\t(function() {\n\t\t\t\t\tvar tagCt = tagCtx;\n\t\t\t\t\t$observe(data, arrayBindings[i] = function(ev, eventArgs) { // Store arrayChangeHandler on tag._ars[i]\n\t\t\t\t\t\ttag.onArrayChange(ev, eventArgs, tagCt, linkCtx);\n\t\t\t\t\t});\n\t\t\t\t})();\n\t\t\t}\n\t\t}\n\t\tfor (i = selected + 1; i < l; i++) { // If there were previous bindings on later tagCtxs, remove them\n\t\t\tif (arrayBindings[i]) {\n\t\t\t\t$observe(arrayBindings[i], true); //unobserve previous binding\n\t\t\t\tdelete arrayBindings[i];\n\t\t\t}\n\t\t}\n\t\tif (eventArgs) {\n\t\t\ttag.domChange(tagCtx, linkCtx, eventArgs);\n\t\t}\n\t},\n\tonAfterLink: function(tagCtx) {\n\t\tvar data, map, props,\n\t\t\ttag = this,\n\t\t\ti = 0,\n\t\t\ttagCtxs = tag.tagCtxs,\n\t\t\tl = tagCtxs.length,\n\t\t\tselected = tag.selected || 0;\n\n\t\tfor (; i <= selected; i++) {\n\t\t\ttagCtx = tagCtxs[i];    // loop through tagCtxs up to selected\n\t\t\tmap = tagCtx.map;\n\t\t\tdata = tagCtx.map\n\t\t\t\t? map.tgt      // 'data' is mapped data\n\t\t\t\t: tagCtx.args.length\n\t\t\t\t\t? tagCtx.args[0]    // or args[0]\n\t\t\t\t\t: tagCtx.view.data; // or defaults to current data.\n\t\t\tif ($isArray(data) && (props = tagCtx.params.props)) {\n\t\t\t\tif (props.paged && !tag.paged) {\n\t\t\t\t\t$.observable(tag).setProperty(\"paged\", data.slice());\n\t\t\t\t\ttag.updateValue(tag.paged, 0, i, true); // Update paged (async, to wait until parent tag has been datalinked)\n\t\t\t\t}\n\t\t\t\tif (props.sorted && !tag.sorted) {\n\t\t\t\t\t$.observable(tag).setProperty(\"sorted\", map && map.sorted || data.slice());\n\t\t\t\t\ttag.updateValue(tag.sorted, 1, i, true); // Update sorted (async, to wait until parent tag has been datalinked)\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t},\n\tonDispose: function() {\n\t\tvar l, tag = this;\n\t\tfor (l in tag._ars) {\n\t\t\t$observe(tag._ars[l], true); //unobserve\n\t\t}\n\t}\n});\n\n$extend($tags[\"if\"], {\n\tonUpdate: function(ev, eventArgs, newTagCtxs) {\n\t\tvar prevArg, different,\n\t\t\ttci = 0;\n\t\tfor (; (prevArg = this.tagCtxs[tci]); tci++) {\n\t\t\tdifferent = prevArg.props.tmpl !== newTagCtxs[tci].props.tmpl || prevArg.args.length && !(prevArg = prevArg.args[0]) !== !newTagCtxs[tci].args[0];\n\t\t\tif ((!this.convert && !!prevArg) || different) {\n\t\t\t\treturn different;\n\t\t\t\t// If there is not a change of template, and there is no converter, and newArg and prevArg are both truthy, return false to cancel update.\n\t\t\t\t// (Even if values on later elses are different, we still don't want to update, since rendered output would be unchanged)\n\t\t\t\t// If newArg and prevArg are different, return true, to update\n\t\t\t\t// If newArg and prevArg are both falsey, move to the next {{else ...}}\n\t\t\t}\n\t\t}\n\t\t// Boolean value of all args are unchanged (falsey), so return false to cancel update\n\t\treturn false;\n\t},\n\tonAfterLink: function(tagCtx, linkCtx, ctx, ev, eventArgs) {\n\t\tif (eventArgs) {\n\t\t\tthis.domChange(tagCtx, linkCtx, eventArgs);\n\t\t}\n\t}\n});\n\nfunction observeProps(map, ev, eventArgs) {\n\tvar target, l, props = map.options.props;\n\tupdatePropsArr(map.propsArr, eventArgs.path, eventArgs.value, eventArgs.remove);\n\tif (props.sort !== undefined || props.start !== undefined || props.end !== undefined || props.step !== undefined || props.filter || props.reverse) {\n\t\tmap.update(); // refresh sorting and filtering\n\t} else if (eventArgs.change === \"set\") {\n\t\ttarget = map.tgt;\n\t\tl = target.length;\n\t\twhile (l-- && target[l].key !== eventArgs.path) {}\n\t\tif (l === -1) {\n\t\t\tif (eventArgs.path && !eventArgs.remove) {\n\t\t\t\t$observable(target).insert({key: eventArgs.path, prop: eventArgs.value});\n\t\t\t}\n\t\t} else if (eventArgs.remove) {\n\t\t\t$observable(target).remove(l);\n\t\t} else {\n\t\t\t$observable(target[l]).setProperty(\"prop\", eventArgs.value);\n\t\t}\n\t}\n}\n\nfunction observeMappedProps(map, ev, eventArgs) {\n\tvar items, l, key, remove,\n\t\tsource = map.src,\n\t\tchange = eventArgs.change;\n\n\tif (change === \"set\") {\n\t\tif (eventArgs.path === \"prop\") {\n\t\t\t$observable(source).setProperty(ev.target.key, eventArgs.value);\n\t\t} else { // path === \"key\"\n\t\t\t$observable(source).removeProperty(eventArgs.oldValue); // When key is modified observably, remove old one and set new one\n\t\t\t$observable(source).setProperty(eventArgs.value, ev.target.prop);\n\t\t}\n\t} else if (change === \"insert\" || (remove = change === \"remove\")) {\n\t\titems = eventArgs.items;\n\t\tl = items.length;\n\t\twhile (l--) {\n\t\t\tif (key = items[l].key) {\n\t\t\t\tupdatePropsArr(map.propsArr, key, items[l].prop, remove);\n\t\t\t\tif (remove) {\n\t\t\t\t\t$observable(source).removeProperty(key);\n\t\t\t\t\tdelete source[key];\n\t\t\t\t} else {\n\t\t\t\t\t$observable(source).setProperty(key, items[l].prop);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\nfunction updatePropsArr(propsArr, key, prop, remove) {\n\tvar l = propsArr.length;\n\twhile (l-- && propsArr[l].key !== key) {}\n\tif (l === -1) {\n\t\tif (key && !remove) {\n\t\t\tpropsArr.push({key: key, prop: prop});\n\t\t}\n\t} else if (remove) {\n\t\tpropsArr.splice(l, 1);\n\t}\n}\n\nfunction shallowArrayFilter(path /*, object, parentObs*/) { // Filter used by {{props}} for the mappedProps target array\n\treturn rShallowArrayPath.test(path); // No '.' in path\n}\n\n$tags(\"props\", {\n\tbaseTag: \"for\",\n\tdataMap: $views.map({\n\t\tgetTgt: $tags.props.dataMap.getTgt, // getTargetProps\n\t\tobsSrc: observeProps,\n\t\tobsTgt: observeMappedProps,\n\t\ttgtFlt: shallowArrayFilter\n\t}),\n\tflow: true\n});\n\n//========================\n// Extend jQuery namespace\n//========================\n\n$extend($, {\n\n\t//=======================\n\t// jQuery $.view() plugin\n\t//=======================\n\n\tview: $view = function(node, inner, type) {\n\t\t// $.view() returns top view\n\t\t// $.view(node) returns view that contains node\n\t\t// $.view(selector) returns view that contains first selected element\n\t\t// $.view(nodeOrSelector, type) returns nearest containing view of given type\n\t\t// $.view(nodeOrSelector, \"root\") returns root containing view (child of top view)\n\t\t// $.view(nodeOrSelector, true, type) returns nearest inner (contained) view of given type\n\n\t\tfunction getInnerView(nd, isVl) {\n\t\t\tif (nd) {\n\t\t\t\tvwInfos = viewInfos(nd, isVl, rOpenViewMarkers);\n\t\t\t\tfor (j = 0, k = vwInfos.length; j < k; j++) {\n\t\t\t\t\tif ((view = viewStore[vwInfos[j].id]) && (view = view && type ? view.get(true, type) : view)) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (inner !== !!inner) {\n\t\t\t// inner not boolean, so this is view(nodeOrSelector, type)\n\t\t\ttype = inner;\n\t\t\tinner = undefined;\n\t\t}\n\t\tvar view, vwInfos, i, j, k, l, elems,\n\t\t\tlevel = 0,\n\t\t\tbody = document.body;\n\n\t\tif (node && node !== body && topView._.useKey > 1) {\n\t\t\t// Perf optimization for common cases\n\n\t\t\tnode = \"\" + node === node\n\t\t\t\t? $(node)[0]\n\t\t\t\t: node.jquery\n\t\t\t\t\t? node[0]\n\t\t\t\t\t: node;\n\n\t\t\tif (node) {\n\t\t\t\tif (inner) {\n\t\t\t\t\tgetInnerView(node._df, true);\n\t\t\t\t\tif (!view && node.tagName) { // Not a text node\n\t\t\t\t\t\t// Treat supplied node as a container element and return the first view encountered.\n\t\t\t\t\t\telems = qsa ? node.querySelectorAll(bindElsSel) : $(bindElsSel, node).get();\n\t\t\t\t\t\tl = elems.length;\n\t\t\t\t\t\tfor (i = 0; !view && i < l; i++) {\n\t\t\t\t\t\t\tgetInnerView(elems[i]);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\treturn view;\n\t\t\t\t}\n\t\t\t\twhile (node) {\n\t\t\t\t\t// Move back through siblings and up through parents to find preceding node which is a _prv (prevNode)\n\t\t\t\t\t// script marker node for a non-element-content view, or a _prv (first node) for an elCnt view\n\t\t\t\t\tif (vwInfos = viewInfos(node, undefined, rViewMarkers)) {\n\t\t\t\t\t\tl = vwInfos.length;\n\t\t\t\t\t\twhile (l--) {\n\t\t\t\t\t\t\tview = vwInfos[l];\n\t\t\t\t\t\t\tif (view.open) {\n\t\t\t\t\t\t\t\tif (level < 1) {\n\t\t\t\t\t\t\t\t\tview = viewStore[view.id];\n\t\t\t\t\t\t\t\t\treturn view && type ? view.get(type) : view || topView;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tlevel--;\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t// level starts at zero. If we hit a view.close, then we move level to 1, and we don't return a view until\n\t\t\t\t\t\t\t\t// we are back at level zero (or a parent view with level < 0)\n\t\t\t\t\t\t\t\tlevel++;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tnode = node.previousSibling || node.parentNode;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn topView;\n\t},\n\n\tlink: $link,\n\tunlink: $unlink,\n\n\t//=====================\n\t// override $.cleanData\n\t//=====================\n\tcleanData: function(elems) {\n\t\tif (elems.length && isCleanCall) {\n\t\t\t// Remove JsViews bindings. Also, remove from the DOM any corresponding script marker nodes\n\t\t\tclean(elems);\n\t\t}\n\t\toldCleanData.apply($, arguments);\n\t}\n});\n\n// Possible future addition - e.g. for ckeditor tag control\n//$views.utility = {\n//\tvalidate: function(html) {\n//\t\ttry {\n//\t\t\ttopView.link(undefined, document.createElement(\"div\"), undefined, undefined, html, undefined, undefined, 1);\n//\t\t}\n//\t\tcatch (e) {\n//\t\t\treturn e.message;\n//\t\t}\n//\t}\n//};\n\n//===============================\n// Extend jQuery instance plugins\n//===============================\n\n$extend($.fn, {\n\tlink: function(expr, from, context, noIteration, parentView, prevNode, nextNode) {\n\t\treturn $link(expr, this, from, context, noIteration, parentView, prevNode, nextNode);\n\t},\n\tunlink: function() {\n\t\treturn $unlink(this);\n\t},\n\tview: function(inner, type) {\n\t\treturn $view(this[0], inner, type);\n\t}\n});\n\n//==============================================================================\n// Override jQuery methods that call our overridden cleanData, for disposal etc.\n//==============================================================================\n\n$.each([HTML, \"replaceWith\", \"empty\", \"remove\"], function(i, name) {\n\tvar oldFn = $.fn[name];\n\t$.fn[name] = function() {\n\t\tvar result;\n\t\tisCleanCall = 1; // Make sure cleanData does disposal only when coming from these calls.\n\t\ttry {\n\t\t\tresult = oldFn.apply(this, arguments);\n\t\t}\n\t\tfinally {\n\t\t\tisCleanCall = 0;\n\t\t}\n\t\treturn result;\n\t};\n});\n\n//===============\n// Extend topView\n//===============\n\n$extend(topView = $sub.topView, {tmpl: {links: {}}});\n\nviewStore = {0: topView}; // Top-level view\n\n//===================\n// Extend $.views.sub\n//===================\n\n$sub._glt = function(elem) { // get linked tags (Used in validate.js)\n\tvar linkCtx,\n\t\tregEx = /#(\\d*)\\^\\/\\1\\^/g,\n\t\tlinkCtxs = [],\n\t\ttokens = markerNodeInfo(elem);\n\n\twhile (linkCtx = regEx.exec(tokens)) {\n\t\tif (linkCtx = bindingStore[linkCtx[1]]) {\n\t\t\tlinkCtxs.push(linkCtx.linkCtx.tag);\n\t\t}\n\t}\n\treturn linkCtxs;\n};\n\n$sub._gccb = function(view) { // Return a callback for accessing the context of a template/data-link expression - and converting ~foo, #foo etc.\n\t// TODO Consider exposing or allowing override, as public API\n\treturn function(path, object, depth) {\n\t\t// TODO consider only calling the contextCb on the initial token in path '~a.b.c' and not calling again on\n\t\t// the individual tokens, 'a', 'b', 'c'... Currently it is called multiple times\n\t\tvar tokens, tag, items, helper, last, nextPath, l, obsCtxPrm, addedTagCpDep, key, bindTo;\n\t\tif (view && path) {\n\t\t\tif (path._cpfn) {\n\t\t\t\treturn path._cpfn.call(view.tmpl, object, view, $sub); // exprOb for computed property\n\t\t\t}\n\t\t\tif (path.charAt(0) === \"~\") {\n\t\t\t\t// We return new items to insert into the sequence, replacing the \"~a.b.c\" string:\n\t\t\t\t// [helperObject 'a', \"a.b.c\" currentDataItem] so currentDataItem becomes the object for subsequent paths.\n\t\t\t\tif (path.slice(0, 4) === \"~tag\") {\n\t\t\t\t\ttag = view.ctx;\n\t\t\t\t\tif (path.charAt(4) === \".\") {\n\t\t\t\t\t\t// \"~tag.xxx\"\n\t\t\t\t\t\ttokens = path.slice(5);\n\t\t\t\t\t\ttag = tag.tag;\n\t\t\t\t\t} else if (path.slice(0, 8) === \"~tagCtx.\") {\n\t\t\t\t\t\t// \"~tagCtx.xxx\"\n\t\t\t\t\t\ttokens = path.slice(8);\n\t\t\t\t\t\ttag = tag.tagCtx;\n\t\t\t\t\t}\n\t\t\t\t\tif (tokens) {\n\t\t\t\t\t\treturn tag ? [tag, tokens] : [];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tpath = path.slice(1).split(\".\");\n\t\t\t\tif (helper = view.ctxPrm(last = path.shift(), undefined, true)) {\n\t\t\t\t\tif (obsCtxPrm = helper._cxp) { // helper for (contextual parameter ~foo=...) is an array - [view, ctxPrmDependencies ...]\n\t\t\t\t\t\tif (path.length) {\n\t\t\t\t\t\t\tnextPath = \".\" + path.join(\".\");\n\t\t\t\t\t\t\tlast = helper[l = helper.length-1];\n\t\t\t\t\t\t\tif (last._cpfn) {\n\t\t\t\t\t\t\t\tlast.sb = nextPath;\n\t\t\t\t\t\t\t\tlast.bnd = !!depth;\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\thelper[l] = (last + nextPath).replace(\"#data.\", \"\");\n\t\t\t\t\t\t\t\tif (last.slice(0, 5) === \"#view\") {\n\t\t\t\t\t\t\t\t\thelper[l] = helper[l].slice(6);\n\t\t\t\t\t\t\t\t\thelper.splice(l, 0, view);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\titems = [helper]; // Contextual parameter\n\t\t\t\t\t\tif ((tag = obsCtxPrm.tag) && tag.convert) {\n\t\t\t\t\t\t\t// If there is a converter, it might mix inputs, so tag contextual param needs to depend on all bound args/props.\n\t\t\t\t\t\t\tbindTo = tag.bindTo || [0];\n\t\t\t\t\t\t\tl = bindTo.length;\n\t\t\t\t\t\t\twhile (l--) {\n\t\t\t\t\t\t\t\tif (depth !== undefined && l !== obsCtxPrm.ind) {\n\t\t\t\t\t\t\t\t\tkey = bindTo[l];\n\t\t\t\t\t\t\t\t\taddedTagCpDep = [helper[0], tag.tagCtx.params[+key === key ? \"args\" : \"props\"]];\n\t\t\t\t\t\t\t\t\taddedTagCpDep._cxp = obsCtxPrm;\n\t\t\t\t\t\t\t\t\titems.push(addedTagCpDep); // Added dependency for tag contextual parameter\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t} else if (path.length || $isFunction(helper)) {\n\t\t\t\t\t\titems = [helper, path.join(\".\")]; // 2way bindng on ~foo.helperLeafProperty or ~computed() or ~contextualParam\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn items || [];\n\t\t\t}\n\t\t\tif (path.charAt(0) === \"#\") {\n\t\t\t\t// We return new items to insert into the sequence, replacing the \"#a.b.c\" string: [view, \"a.b.c\" currentDataItem]\n\t\t\t\t// so currentDataItem becomes the object for subsequent paths. The 'true' flag makes the paths bind only to leaf changes.\n\t\t\t\treturn path === \"#data\" ? [] : [view, path.replace(rViewPath, \"\")];\n\t\t\t}\n\t\t}\n\t};\n};\n\n//===================\n// ctxPrm helpers\n//===================\n// The following helper functions for observable contextual parameters are needed by render.js in data-linking scenarios\n// Implemented here rather than in render.js to keep render.js size down, and exposed via $.sub...\n\n$sub._cp = function(paramVal, paramExpr, view, tagCtxPrm) { // Create tag or inline contextual parameter\n\t// Called for inline contextual parameter ~foo=expression, from compiled function for expression. (tagCtxPrm is undefined)\n\t// Called for tag parameter (two-way binding), from renderTag. (tagCtxPrm is {tag: ..., ind: ...})\n\tif (view.linked) { // In JsViews, returns [view, linkFn] where linkFn is compiled function for expression, or observable contextual parameter object\n\t\tif (tagCtxPrm && (tagCtxPrm.cvt || tagCtxPrm.tag._.toIndex[tagCtxPrm.ind] === undefined)) {\n\t\t\tparamVal = [{_ocp: paramVal}]; // With convert, or with bindTo/bindFrom different, the tag contextual parameter object will be 'local' to the tag.\n\t\t\t\t// It will be updated by bindFrom binding, and by tag.setValue(...), but not by tag.updateValue() (which will update bindTo value externally)\n\t\t\ttagCtxPrm.updateValue = function(val) {\n\t\t\t\t$.observable(paramVal._cxp.data).setProperty(_ocp, val); // Set the value (res[0]._ocp)\n\t\t\t\treturn this;\n\t\t\t};\n\t\t} else if (paramExpr) { // With no convert/convertBack and no bindTo/bindFrom difference, tag contextual parameter 2way binds to bindTo/bindFrom value.\n\t\t\t\t// So tag.updateValue() updates external value, which updates contextual  parameter through 2way binding\n\t\t\tvar params = delimOpenChar1 + \":\" + paramExpr + delimCloseChar0,\n\t\t\t\tlinks = topView.tmpl.links, // Use topView links, as for compiled top-level linking expressions. To do - should this ever get disposed?\n\t\t\t\tlinkFn = links[params];\n\t\t\tif (!linkFn) {\n\t\t\t\tlinks[params] = linkFn = $sub.tmplFn(params, view.tmpl, true);\n\t\t\t}\n\t\t\tparamVal = linkFn.deps[0]\n\t\t\t\t? [view, linkFn] // compiled expression\n\t\t\t\t: [{_ocp: tagCtxPrm ? paramVal : linkFn()}]; // Static value - no deps - returns observable contextual parameter object\n\t\t} else {\n\t\t\tparamVal = [{_ocp: paramVal}]; // Uninitialized observable contextual parameter object\n\t\t}\n\t\tparamVal._cxp = tagCtxPrm || {\n\t\t\tupdateValue: function(val) {\n\t\t\t\t$observable(paramVal._cxp.data).setProperty(paramVal._cxp.path, val);\n\t\t\t\treturn this;\n\t\t\t}\n\t\t};\n\t}\n\treturn paramVal; // In JsRender returns evaluated expression\n};\n\n$sub._ucp = function(key, value, view, obsCtxPrm) {\n\tvar tag = obsCtxPrm.tag,\n\t\tindex = tag ? $inArray(key, tag.linkedCtxParam) : 0;\n\tif (!obsCtxPrm.path) {\n\t\tresolveDataTargetPath(\"~\" + key, view.data, $sub._gccb(view));\n\t}\n\treturn (obsCtxPrm.updateValue || tag.updateValue)(value, index, obsCtxPrm.tagElse, undefined, tag);\n};\n\n$sub._ceo = function cloneExprObjects(obs) { // Clone exprObs so that each referenced contextual parameter ~foo uses its own exprOb instances\n\tvar ob,\n\t\tclones = [],\n\t\tl = obs.length;\n\twhile (l--) {\n\t\tob = obs[l];\n\t\tif (ob._cpfn) {\n\t\t\tob = $extend({}, ob);              // If an exprOb, clone it. If a string, keep as is\n\t\t\tob.prm = cloneExprObjects(ob.prm); // Recursively clone exprObs in parameters, too\n\t\t}\n\t\tclones.unshift(ob);\n\t}\n\treturn clones;\n};\n\n//=========================\n// Extend $.views.settings\n//=========================\n\noldAdvSet = $sub.advSet;\n\n$sub.advSet = function() { // refresh advanced settings\n\toldAdvSet.call($sub);\n\tglobal._jsv = $subSettingsAdvanced._jsv\n\t\t? $extend(global._jsv || {}, { // create global _jsv, for accessing views, etc\n\t\t\t\tviews: viewStore,\n\t\t\t\tbindings: bindingStore\n\t\t\t})\n\t\t: undefined; // In IE8 cannot do delete global._jsv\n\t$viewsLinkAttr = $subSettingsAdvanced.linkAttr;\n\tlinkViewsSel = bindElsSel + \",[\" + $viewsLinkAttr + \"]\";\n\twrapMap = $subSettingsAdvanced._wm;\n\twrapMap.optgroup = wrapMap.option;\n\twrapMap.tbody = wrapMap.tfoot = wrapMap.colgroup = wrapMap.caption = wrapMap.thead;\n\twrapMap.th = wrapMap.td;\n};\n\n$viewsSettings.advanced({\n\tlinkAttr: \"data-link\",\n\tuseViews: false,\n\tnoValidate: false,\n\t// wrapMap provide appropriate wrappers for inserting innerHTML, used in insertBefore\n\t// We have to close these tags to support XHTML (#13200)\n\t// TODO investigate whether more recent jQuery implementation using wrapMap in domManip/$().html() etc. is better optimized now...\n\t_wm: {\n\t\toption: [1, \"<select multiple='multiple'>\", \"</select>\"],\n\t\tlegend: [1, \"<fieldset>\", \"</fieldset>\"],\n\t\tarea: [1, \"<map>\", \"</map>\"],\n\t\tparam: [1, \"<object>\", \"</object>\"],\n\t\tthead: [1, \"<table>\", \"</table>\"],\n\t\ttr: [2, \"<table><tbody>\", \"</tbody></table>\"],\n\t\ttd: [3, \"<table><tbody><tr>\", \"</tr></tbody></table>\"],\n\t\tcol: [2, \"<table><tbody></tbody><colgroup>\", \"</colgroup></table>\"],\n\t\tsvg_ns: [1, \"<svg>\", \"</svg>\"],\n\t\t// IE6-8 can't serialize link, script, style, or any html5 (NoScope) tags,\n\t\t// unless wrapped in a div with non-breaking characters in front of it.\n\t\tdiv: $.support.htmlSerialize ? [0, \"\", \"\"] : [1, \"X<div>\", \"</div>\"]\n\t},\n\t_fe: {\n\t\tinput: {\n\t\t\tfrom: inputAttrib, to: VALUE\n\t\t},\n\t\ttextarea: valueBinding,\n\t\tselect: valueBinding,\n\t\toptgroup: {\n\t\t\tto: \"label\"\n\t\t}\n\t}\n});\n\nreturn $;\n}, window));\n"]}