{"version":3,"sources":["jquery.observable.js"],"names":["factory","global","$","jQuery","exports","module","define","amd","setGlobals","fn","$observe","$observable","versionNumber","_ocp","$views","views","jsrender","jsviews","sub","settings","advanced","value","$subSettingsAdvanced","$subSettings","_jsv","$sub","advSet","$isFunction","isFunction","$expando","expando","$isArray","isArray","OBJECT","observe","$eventSpecial","event","special","slice","splice","concat","PARSEINT","parseInt","rNotWhite","propertyChangeStr","propChng","arrayChangeStr","arrChng","cbBindingsStore","observeStr","observeObjKey","observeCbKey","observeInnerCbKey","$hasData","hasData","$data","data","remove","getCbKey","cb","_cId","ObjectObservable","ns","this","_data","_ns","ArrayObservable","wrapArray","dependsPaths","paths","root","callback","i","path","object","rt","nextObj","l","length","out","view","call","push","unshift","_ar","removeCbBindings","cbBindings","cbBindingsId","onDataChange","ev","eventArgs","isOb","val","allowArray","off","allPath","filter","parentObs","oldValue","ctx","observeAll","arOk","type","array","prop","_path","target","parents","observe_apply","undefined","args","apply","arguments","shift","$observeAll","unobserve","$unobserveAll","namespace","objMap","observeArrayItems","arr","unobs","newAllPath","filterAndObserveAll","obj","nestedArray","newObject","newParentObs","_fltr","nextParentObs","updatedTgt","wrappedCb","change","items","_wrp","isObject","obId","notRemoving","un","shallowFilter","indexOf","$unobserve","innerObserve","observeOnOff","pathStr","isArrayBinding","j","evData","obIdExpando","boundObOrArr","prntObs","allPth","initialNs","events","el","fullPath","replace","all","inArray","on","getInnerCb","exprOb","origRt","ob","contextCb","sb","newObj","bindArray","unbind","relPath","prevObj","prevAllPath","p","skip","parts","dep","cbId","inId","innerContextCb","depth","innerCb","initNsArr","initNsArrLen","cbItemCount","lastArg","pop","origRoots","_inId","match","split","join","_cxp","_gccb","origRoot","_cpfn","bnd","prm","nodeType","observable","depends","s","set","Object","Array","_apply","prototype","unobserveAll","setProperty","nonStrict","key","pair","multi","_is","self","name","_setProperty","removeProperty","leaf","setter","getter","removeProp","property","_vw","Date","_trigger","triggerHandler","exec","insert","index","_insert","oldLength","numToRemove","_remove","move","oldIndex","newIndex","numToMove","_move","excess","refresh","newItems","insertAdded","k","addedItems","dataLength","newItem","num","oldItems","newLength","_srt","$_data","handleObj","found","map","mapDef","Map","source","options","unbound","changing","src","unmap","tgt","update","obsSrc","obs","srcFlt","obsTgt","obt","tgtFlt","getTgt","baseMap","extend","_def","constructor","_dp","window"],"mappings":"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","file":"jquery.observable.min.js","sourcesContent":["/*! JsObservable v0.9.89 (Beta): http://jsviews.com/#jsobservable */\n/*\n * Subcomponent of JsViews\n * Data change events for data-linking\n *\n * Copyright 2017, Boris Moore\n * Released under the MIT License.\n */\n\n//jshint -W018, -W041, -W120\n\n(function(factory, global) {\n\t// global var is the this object, which is window when running in the usual browser environment\n\tvar $ = global.jQuery;\n\n\tif (typeof exports === \"object\") { // CommonJS e.g. Browserify\n\t\tmodule.exports = $\n\t\t\t? factory(global, $)\n\t\t\t: function($) { // If no global jQuery, take jQuery passed as parameter: require(\"jsobservable\")(jQuery)\n\t\t\t\treturn factory(global, $);\n\t\t\t};\n\t} else if (typeof define === \"function\" && define.amd) { // AMD script loader, e.g. RequireJS\n\t\tdefine([\"jquery\"], function($) {\n\t\t\treturn factory(global, $); // Require jQuery\n\t\t});\n\t} else { // Browser using plain <script> tag\n\t\tfactory(global, false);\n\t}\n} (\n\n// factory (for jsviews.js)\nfunction(global, $) {\n\"use strict\";\n\n//========================== Top-level vars ==========================\n\n// global var is the this object, which is window when running in the usual browser environment\nvar setGlobals = $ === false; // Only set globals if script block in browser (not AMD and not CommonJS)\n\n$ = $ || global.jQuery;\n\nif (!$ || !$.fn) {\n\t// jQuery is not loaded.\n\tthrow \"JsObservable requires jQuery\"; // We require jQuery\n}\n\nvar versionNumber = \"v0.9.89\",\n\t_ocp = \"_ocp\", // Observable contextual parameter\n\t$observe, $observable,\n\n\t$views = $.views =\n\t\t$.views ||\n\t\tsetGlobals && global.jsrender && jsrender.views || //jsrender was loaded before jquery.observable\n\t\t{ // jsrender not loaded so set up $.views and $.views.sub here, and merge back in jsrender if loaded afterwards\n\t\t\tjsviews: versionNumber,\n\t\t\tsub: {\n\t\t\t\t// subscription, e.g. JsViews integration\n\t\t\t\tsettings: {}\n\t\t\t},\n\t\t\tsettings: {\n\t\t\t\tadvanced: function(value) {\n\t\t\t\t\t$subSettingsAdvanced = $subSettings.advanced = $subSettings.advanced || {_jsv: true};\n\t\t\t\t\treturn value\n\t\t\t\t\t\t? (\n\t\t\t\t\t\t\t\"_jsv\" in value && ($subSettingsAdvanced._jsv = value._jsv),\n\t\t\t\t\t\t\t$sub.advSet(),\n\t\t\t\t\t\t\t$views.settings\n\t\t\t\t\t\t)\n\t\t\t\t\t\t: $subSettingsAdvanced;\n\t\t\t\t\t}\n\t\t\t}\n\t\t},\n\t$sub = $views.sub,\n\t$subSettings = $sub.settings,\n\t$subSettingsAdvanced = $subSettings.advanced,\n\t$isFunction = $.isFunction,\n\t$expando = $.expando,\n\t$isArray = $.isArray,\n\tOBJECT = \"object\";\n\nif (!$.observe) {\n\n\tvar $eventSpecial = $.event.special,\n\t\tslice = [].slice,\n\t\tsplice = [].splice,\n\t\tconcat = [].concat,\n\t\tPARSEINT = parseInt,\n\t\trNotWhite = /\\S+/g,\n\t\tpropertyChangeStr = $sub.propChng = $sub.propChng || \"propertyChange\",// These two settings can be overridden on settings after loading\n\t\tarrayChangeStr = $sub.arrChng = $sub.arrChng || \"arrayChange\",        // jsRender, and prior to loading jquery.observable.js and/or JsViews\n\t\tcbBindingsStore = {},\n\t\tobserveStr = propertyChangeStr + \".observe\",\n\t\tobserveObjKey = 1,\n\t\tobserveCbKey = 1,\n\t\tobserveInnerCbKey = 1,\n\t\t$hasData = $.hasData,\n\t\t$data = $.data,\n\t\tremove = {}, // flag for removeProperty\n\n\t//========================== Top-level functions ==========================\n\n\tgetCbKey = function(cb) {\n\t\treturn cb._cId = cb._cId || (\".obs\" + observeCbKey++);\n\t},\n\n\tObjectObservable = function(ns, data) {\n\t\tthis._data = data;\n\t\tthis._ns = ns;\n\t\treturn this;\n\t},\n\n\tArrayObservable = function(ns, data) {\n\t\tthis._data = data;\n\t\tthis._ns = ns;\n\t\treturn this;\n\t},\n\n\twrapArray = function(data) {\n\t\treturn $isArray(data)\n\t\t\t? [data]\n\t\t\t: data;\n\t},\n\n\tdependsPaths = function(paths, root, callback) {\n\t\t// Process depends = ... paths to resolve objects, and recursively process functions.\n\t\tpaths = paths\n\t\t\t? $isArray(paths)\n\t\t\t\t? paths\n\t\t\t\t: [paths]\n\t\t\t: [];\n\n\t\tvar i, path, object, rt,\n\t\t\tnextObj = object = root,\n\t\t\tl = paths && paths.length,\n\t\t\tout = [];\n\n\t\tfor (i = 0; i < l; i++) {\n\t\t\tpath = paths[i];\n\t\t\tif ($isFunction(path)) {\n\t\t\t\trt = root._ocp\n\t\t\t\t\t? root.view.data // observable contextual parameter\n\t\t\t\t\t: root;\n\t\t\t\tout = out.concat(dependsPaths(path.call(rt, rt, callback), root, callback));\n\t\t\t\tcontinue;\n\t\t\t} else if (\"\" + path !== path) {\n\t\t\t\troot = nextObj = path;\n\t\t\t\tif (nextObj !== object) {\n\t\t\t\t\tout.push(object = nextObj);\n\t\t\t\t}\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (nextObj !== object) {\n\t\t\t\tout.push(object = nextObj);\n\t\t\t}\n\t\t\tout.push(path);\n\t\t}\n\t\tif (out.length) {\n\t\t\tout.unshift({_ar: 1}); // Switch on allowArray, for depends paths.\n\t\t\tout.push({_ar: -1});\n\t\t}\n\t\treturn out;\n\t},\n\n\tremoveCbBindings = function(cbBindings, cbBindingsId) {\n\t\t// If the cbBindings collection is empty we will remove it from the cbBindingsStore\n\t\tfor (var cb in cbBindings) {\n\t\t\treturn;\n\t\t}\n\t\tdelete cbBindingsStore[cbBindingsId]; // This binding collection is empty, so remove from store\n\t},\n\n\tonDataChange = function(ev, eventArgs) {\n\t\tfunction isOb(val) {\n\t\t\treturn typeof val === OBJECT && (paths[0] || allowArray && $isArray(val));\n\t\t}\n\n\t\tif (!(ev.data && ev.data.off)) {\n\t\t\t// Skip if !!ev.data.off: - a handler that has already been removed (maybe was on handler collection at call time - then removed by another handler)\n\t\t\tvar allPath, filter, parentObs,\n\t\t\t\toldValue = eventArgs.oldValue,\n\t\t\t\tvalue = eventArgs.value,\n\t\t\t\tctx = ev.data,\n\t\t\t\tobserveAll = ctx.observeAll,\n\t\t\t\tcb = ctx.cb,\n\t\t\t\tallowArray = ctx.arOk,\n\t\t\t\tpaths = ctx.paths,\n\t\t\t\tns = ctx.ns;\n\n\t\t\tif (ev.type === arrayChangeStr) {\n\t\t\t\t(cb.array || cb).call(ctx, ev, eventArgs); // If there is an arrayHandler expando on the regular handler, use it, otherwise use the regular handler for arrayChange events also - for example: $.observe(array, handler)\n\t\t\t\t// or observeAll() with an array in the graph. Note that on data-link bindings we ensure always to have an array handler - $.noop if none is specified e.g. on the data-linked tag.\n\t\t\t} else if (ctx.prop === eventArgs.path || ctx.prop === \"*\") {\n\t\t\t\tif (observeAll) {\n\t\t\t\t\tallPath = observeAll._path + \".\" + eventArgs.path;\n\t\t\t\t\tfilter = observeAll.filter;\n\t\t\t\t\tparentObs = [ev.target].concat(observeAll.parents());\n\n\t\t\t\t\tif (isOb(oldValue)) {\n\t\t\t\t\t\tobserve_apply(undefined, ns, [oldValue], paths, cb, true, filter, [parentObs], allPath); // unobserve\n\t\t\t\t\t}\n\t\t\t\t\tif (isOb(value)) {\n\t\t\t\t\t\tobserve_apply(undefined, ns, [value], paths, cb, undefined, filter, [parentObs], allPath);\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tif (isOb(oldValue)) { // oldValue is an object, so unobserve\n\t\t\t\t\t\tobserve_apply(undefined, ns, [oldValue], paths, cb, true); // unobserve\n\t\t\t\t\t}\n\t\t\t\t\tif (isOb(value)) { // value is an object, so observe\n\t\t\t\t\t\tobserve_apply(undefined, ns, [value], paths, cb);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tctx.cb(ev, eventArgs);\n\t\t\t}\n\t\t}\n\t},\n\n\tobserve_apply = function() {\n\t\t// $.observe(), but allowing you to include arrays within the arguments - which you want flattened.\n\t\tvar args = concat.apply([], arguments); // Flatten the arguments\n\t\treturn $observe.apply(args.shift(), args);\n\t},\n\n\t$observeAll = function(cb, filter, unobserve) {\n\t\tobserveAll(this._ns, this._data, cb, filter, [], \"root\", unobserve);\n\t},\n\n\t$unobserveAll = function(cb, filter) {\n\t\t$observeAll.call(this, cb, filter, true);\n\t},\n\n\tobserveAll = function(namespace, object, cb, filter, parentObs, allPath, unobserve, objMap) {\n\t\tfunction observeArrayItems(arr, unobs) {\n\t\t\tl = arr.length;\n\t\t\tnewAllPath = allPath + \"[]\";\n\t\t\twhile (l--) {\n\t\t\t\tfilterAndObserveAll(arr, l, unobs, 1);\n\t\t\t}\n\t\t}\n\n\t\tfunction filterAndObserveAll(obj, prop, unobs, nestedArray) {\n\t\t\tvar newObject, newParentObs;\n\t\t\tif (prop !== $expando) {\n\t\t\t\tif (newObject = $observable._fltr(newAllPath, obj[prop], nextParentObs, filter)) {\n\t\t\t\t\tnewParentObs = nextParentObs.slice();\n\t\t\t\t\tif (nestedArray && updatedTgt && newParentObs[0] !== updatedTgt) {\n\t\t\t\t\t\tnewParentObs.unshift(updatedTgt); // For array change events when observing an array which is not the root, need to add updated array to parentObs\n\t\t\t\t\t}\n\t\t\t\t\tobserveAll(namespace, newObject, cb, filter || (nestedArray ? undefined : 0), newParentObs, newAllPath, unobs, objMap);\n\t\t\t\t\t// If nested array, need to observe the array too - so set filter to undefined\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tfunction wrappedCb(ev, eventArgs) {\n\t\t\t// This object is changing.\n\t\t\tallPath = ev.data.observeAll._path;\n\t\t\tupdatedTgt = ev.target;\n\t\t\tswitch (eventArgs.change) { // observeAll/unobserveAll on added or removed objects\n\t\t\t\tcase \"insert\":\n\t\t\t\t\tobserveArrayItems(eventArgs.items);\n\t\t\t\t\tbreak;\n\t\t\t\tcase \"remove\":\n\t\t\t\t\tobserveArrayItems(eventArgs.items, true); // unobserveAll on removed items\n\t\t\t\t\tbreak;\n\t\t\t\tcase \"set\":\n\t\t\t\t\tnewAllPath = allPath + \".\" + eventArgs.path;\n\t\t\t\t\tfilterAndObserveAll(eventArgs, \"oldValue\", true); // unobserve old value\n\t\t\t\t\tfilterAndObserveAll(eventArgs, \"value\"); // observe new value\n\t\t\t}\n\t\t\tupdatedTgt = undefined;\n\t\t\tcb.apply(this, arguments); // Observe this object (invoke the callback)\n\t\t}\n\t\twrappedCb._wrp = 1;\n\n\t\tvar l, isObject, newAllPath, nextParentObs, updatedTgt, obId,\n\t\t\tnotRemoving = !objMap || objMap.un || !unobserve; // true unless it is an observeAll call (not unobserveAll) and we are removing a listener (not adding one)\n\n\t\tif (object && typeof object === OBJECT) {\n\t\t\tnextParentObs = [object].concat(parentObs); // The parentObs chain for the next depth of observeAll\n\t\t\tisObject = $isArray(object) ? \"\" : \"*\";\n\t\t\tif (objMap && notRemoving && $hasData(object) && objMap[obId = $data(object).obId]) {\n\t\t\t\tobjMap[obId]++;\n\t\t\t\treturn; // This object has already being observed/unobserved by this observeAll/unobserveAll call (must be a cyclic object graph) so skip, to avoid\n\t\t\t\t// stack overflow/multiple instances of listener. See jsviews/pull/305\n\t\t\t\t// NOTE - WE DO NOT support ObserveAll on data with cyclic graphs which include DUPLICATE REFERENCES TO ARRAY PROPERTIES - such as data.children = data.descendants = []\n\t\t\t}\n\t\t\tif (!objMap) {\n\t\t\t\tobjMap = {un: unobserve}; // Map object to register observed objects for this observeAll\n\t\t\t}\n\n\t\t\tif (cb) {\n\t\t\t\t// Observe this object or array - and also listen for changes to object graph, to add or remove observers from the modified object graph\n\t\t\t\tif (isObject || filter !== 0) {\n\t\t\t\t\t// If an object, observe the object. If an array, only add arrayChange binding if has filter or if filter is undefined (!== 0) - which\n\t\t\t\t\t// is the case for top-level calls or for nested array (array item of an array - e.g. member of 2-dimensional array).\n\t\t\t\t\t// For array properties lower in the tree, with no filter, filter is set to 0 in filterAndObserveAll, so no arrayChange binding here,\n\t\t\t\t\t// since they get arrayChange binding added during regular $.observe(array ...) binding.\n\t\t\t\t\twrappedCb._cId = getCbKey(cb); // Identify wrapped callback with unwrapped callback, so unobserveAll will\n\t\t\t\t\t\t\t\t\t\t\t\t\t// remove previous observeAll wrapped callback, if inner callback was the same;\n\t\t\t\t\tif (notRemoving) {\n\t\t\t\t\t\t$observe(namespace, object, isObject, wrappedCb, unobserve, filter, nextParentObs, allPath);\n\t\t\t\t\t\tobId = $data(object).obId;\n\t\t\t\t\t\tobjMap[obId] = (objMap[obId] || 0) + 1; // Register on map of objects observed/unobserved by this observeAll/unobserveAll call\n\t\t\t\t\t\t\t//- or remove from map if we are removing this object from observeAll call. (Avoid dups, for cyclic graphs)\n\t\t\t\t\t} else {\n\t\t\t\t\t\tif (--objMap[$data(object).obId]) {\n\t\t\t\t\t\t\t// Register on map of objects observed/unobserved by this observeAll/unobserveAll call\n\t\t\t\t\t\t\t//- or remove from map if we are removing this object from observeAll call. (Avoid dups, for cyclic graphs)\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t}\n\t\t\t\t\t\t$observe(namespace, object, isObject, wrappedCb, unobserve, filter, nextParentObs, allPath);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t// No callback. Just unobserve if unobserve === true.\n\t\t\t\tif (objMap) {\n\t\t\t\t\tobjMap[$data(object).obId] = 1; // Register on map of objects unobserved by this unobserveAll call. (Avoid dups, for cyclic graphs)\n\t\t\t\t}\n\t\t\t\t$observe(namespace, object, isObject, undefined, unobserve, filter, nextParentObs, allPath);\n\t\t\t}\n\n\t\t\tif (isObject) {\n\t\t\t\t// Continue stepping through object graph, observing object and arrays\n\t\t\t\t// To override filtering, pass in filter function, or replace $.observable._fltr\n\t\t\t\tfor (l in object) {\n\t\t\t\t\tnewAllPath = allPath + \".\" + l;\n\t\t\t\t\tfilterAndObserveAll(object, l, unobserve);\n\t\t\t\t}\n\t\t\t} else { // Observe items in Array\n\t\t\t\tobserveArrayItems(object, unobserve);\n\t\t\t}\n\t\t}\n\t},\n\n\tshallowFilter = function(allPath /*, object, parentObs*/) {\n\t\treturn allPath.indexOf(\".\") < 0 && allPath.indexOf(\"[\") < 0;\n\t},\n\n\t$unobserve = function() {\n\t\t[].push.call(arguments, true); // Add true as additional final argument\n\t\treturn $observe.apply(undefined, arguments);\n\t};\n\n\t$observe = function() {\n\t\t// $.observe([namespace, ]root, [1 or more objects, path or path Array params...], callback[, contextCallback][, unobserve])\n\n\t\tfunction innerObserve() {\n\n\t\t\tfunction observeOnOff(namespace, pathStr, isArrayBinding, off) {\n\t\t\t\tvar j, evData,\n\t\t\t\t\tobIdExpando = $hasData(object),\n\t\t\t\t\tboundObOrArr = wrapArray(object),\n\t\t\t\t\tprntObs = parentObs,\n\t\t\t\t\tallPth = allPath;\n\n\t\t\t\tnamespace = initialNs ? namespace + \".\" + initialNs : namespace;\n\n\t\t\t\tif (!unobserve && (off || isArrayBinding)) {\n\t\t\t\t\tevents = obIdExpando && $._data(object);\n\t\t\t\t\tevents = events && events.events;\n\t\t\t\t\tevents = events && events[isArrayBinding ? arrayChangeStr : propertyChangeStr];\n\t\t\t\t\tel = events && events.length;\n\t\t\t\t\twhile (el--) { // Skip duplicates\n\t\t\t\t\t\tdata = events[el] && events[el].data;\n\t\t\t\t\t\tif (data && (off && data.ns !== initialNs\n\t\t\t\t\t\t\t// When observing, don't unbind dups unless they have the same namespace\n\t\t\t\t\t\t\t|| !off && data.ns === initialNs && data.cb && data.cb._cId === callback._cId && (!callback._wrp || data.cb._wrp)))\n\t\t\t\t\t\t\t// When observing and doing array binding, don't bind dups if they have the same namespace (Dups can happen e.g. with {^{for people ^~foo=people}})\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (unobserve || off) {\n\t\t\t\t\t$(boundObOrArr).off(namespace, onDataChange);\n\t\t\t\t} else {\n\t\t\t\t\tevData = isArrayBinding ? {}\n\t\t\t\t\t\t: {\n\t\t\t\t\t\t\tfullPath: path,\n\t\t\t\t\t\t\tpaths: pathStr ? [pathStr] : [],\n\t\t\t\t\t\t\tprop: prop,\n\t\t\t\t\t\t\tarOk: allowArray\n\t\t\t\t\t\t};\n\t\t\t\t\tevData.ns = initialNs;\n\t\t\t\t\tevData.cb = callback;\n\n\t\t\t\t\tif (allPath) {\n\t\t\t\t\t\t// This is an observeAll call\n\t\t\t\t\t\tevData.observeAll = {\n\t\t\t\t\t\t\t_path: allPth,\n\t\t\t\t\t\t\tpath: function() { // Step through path and parentObs parent chain, replacing '[]' by '[n]' based on current index of objects in parent arrays.\n\t\t\t\t\t\t\t\tj = prntObs.length;\n\t\t\t\t\t\t\t\treturn allPth.replace(/[[.]/g, function(all) {\n\t\t\t\t\t\t\t\t\tj--;\n\t\t\t\t\t\t\t\t\treturn all === \"[\"\n\t\t\t\t\t\t\t\t\t\t? \"[\" + $.inArray(prntObs[j - 1], prntObs[j])\n\t\t\t\t\t\t\t\t\t\t: \".\";\n\t\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tparents: function() {\n\t\t\t\t\t\t\t\treturn prntObs; // The chain of parents between the modified object and the root object used in the observeAll() call\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tfilter: filter\n\t\t\t\t\t\t};\n\t\t\t\t\t}\n\t\t\t\t\t$(boundObOrArr).on(namespace, null, evData, onDataChange);\n\n\t\t\t\t\tif (cbBindings) {\n\t\t\t\t\t\t// Add object to cbBindings\n\t\t\t\t\t\tcbBindings[$data(object).obId || $data(object, \"obId\", observeObjKey++)] = object;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tfunction getInnerCb(exprOb) {\n\t\t\t\t// Returns the innerCb used for updating a computed in a compiled expression (setting the new instance as exprOb.ob, unobserving the previous object,\n\t\t\t\t// and observing the new one), then calling the outerCB - i.e. the handler for the whole compiled expression.\n\t\t\t\t// Initialized exprOb.ob to the current object.\n\t\t\t\t// Uses the contextCb callback to execute the compiled exprOb template in the context of the view/data etc. to get the returned value, typically an object or array.\n\t\t\t\t// If it is an array, registers array binding\n\t\t\t\tvar origRt = root;\n\t\t\t\t// Note: For jsviews/issues/292 ctxCb will need var ctxCb = contextCb || function(exprOb, origRt) {return exprOb._cpfn(origRt);};\n\n\t\t\t\texprOb.ob = contextCb(exprOb, origRt); // Initialize object\n\n\t\t\t\treturn exprOb.cb = function(ev, eventArgs) {\n\t\t\t\t\tvar obj = exprOb.ob, // The old object\n\t\t\t\t\t\tsub = exprOb.sb,\n\t\t\t\t\t\tnewObj = contextCb(exprOb, origRt);\n\n\t\t\t\t\tif (newObj !== obj) {\n\t\t\t\t\t\tif (typeof obj === OBJECT) {\n\t\t\t\t\t\t\tbindArray(obj, true);\n\t\t\t\t\t\t\tif (sub || allowArray && $isArray(obj)) {\n\t\t\t\t\t\t\t\tinnerObserve([obj], sub, callback, contextCb, true); // unobserve on the old object\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\texprOb.ob = newObj;\n\t\t\t\t\t\t// Put the updated object instance onto the exprOb in the paths array, so subsequent string paths are relative to this object\n\t\t\t\t\t\tif (typeof newObj === OBJECT) {\n\t\t\t\t\t\t\tbindArray(newObj);\n\t\t\t\t\t\t\tif (sub || allowArray && $isArray(newObj)) { // observe on new object\n\t\t\t\t\t\t\t\tinnerObserve([newObj], sub, callback, contextCb);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t// Call the outerCb - to execute the compiled expression that this computed is part of\n\t\t\t\t\tcallback(ev, eventArgs);\n\t\t\t\t};\n\t\t\t}\n\n\t\t\tfunction bindArray(arr, unbind, isArray, relPath) {\n\t\t\t\tif (allowArray) {\n\t\t\t\t\t// allowArray is 1 if this is a call to observe that does not come from observeAndBind (tag binding), or is from a `depends` path,\n\t\t\t\t\t// so we allow arrayChange binding. Otherwise allowArray is zero.\n\t\t\t\t\tvar prevObj = object,\n\t\t\t\t\t\tprevAllPath = allPath;\n\n\t\t\t\t\tobject = arr;\n\t\t\t\t\tif (relPath) {\n\t\t\t\t\t\tobject = arr[relPath];\n\t\t\t\t\t\tallPath += \".\" + relPath;\n\t\t\t\t\t}\n\t\t\t\t\tif (filter && object) {\n\t\t\t\t\t\tobject = $observable._fltr(allPath, object, relPath ? [arr].concat(parentObs) : parentObs, filter);\n\t\t\t\t\t}\n\t\t\t\t\tif (object && (isArray || $isArray(object))) {\n\t\t\t\t\t\tobserveOnOff(arrayChangeStr + \".observe\" + (callback ? getCbKey(callback) : \"\"), undefined, true, unbind);\n\t\t\t\t\t}\n\t\t\t\t\tobject = prevObj;\n\t\t\t\t\tallPath = prevAllPath;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tvar i, p, skip, parts, prop, path, dep, unobserve, callback, cbId, inId, el, data, events, contextCb, innerContextCb,\n\t\t\t\titems, cbBindings, depth, innerCb, parentObs, allPath, filter, initNsArr, initNsArrLen, view, cbItemCount,\n\t\t\t\tns = observeStr,\n\t\t\t\tpaths = this != 1 // Using != for IE<10 bug- see jsviews/issues/237\n\t\t\t\t\t? concat.apply([], arguments) // Flatten the arguments - this is a 'recursive call' with params using the 'wrapped array'\n\t\t\t\t\t\t\t\t\t\t\t\t\t// style - such as innerObserve([object], path.path, [origRoot], path.prm, innerCb, ...);\n\t\t\t\t\t: slice.call(arguments), // Don't flatten - this is the first 'top-level call, to innerObserve.apply(1, paths)\n\t\t\t\tlastArg = paths.pop() || false,\n\t\t\t\troot = paths.shift(),\n\t\t\t\tobject = root,\n\t\t\t\tl = paths.length;\n\n\t\t\torigRoots.unshift(root);\n\t\t\tif (lastArg + \"\" === lastArg) { // If last arg is a string then this observe call is part of an observeAll call,\n\t\t\t\tallPath = lastArg;          // and the last three args are the parentObs array, the filter, and the allPath string.\n\t\t\t\tparentObs = paths.pop();\n\t\t\t\tfilter = paths.pop();\n\t\t\t\tlastArg = !!paths.pop(); // unobserve\n\t\t\t\tl -= 3;\n\t\t\t}\n\t\t\tif (lastArg === !!lastArg) {\n\t\t\t\tunobserve = lastArg;\n\t\t\t\tlastArg = paths[l-1];\n\t\t\t\tlastArg = l && lastArg + \"\" !== lastArg && (!lastArg || $isFunction(lastArg)) ? (l--, paths.pop()) : undefined;\n\t\t\t\tif (unobserve && !l && $isFunction(root)) {\n\t\t\t\t\tlastArg = root;\n\t\t\t\t\troot = undefined;\n\t\t\t\t}\n\t\t\t}\n\t\t\tcallback = lastArg;\n\t\t\tif (l && $isFunction(paths[l - 1])) {\n\t\t\t\tinnerContextCb = contextCb = callback;\n\t\t\t\tcallback = paths.pop();\n\t\t\t\tl--;\n\t\t\t}\n\n\t\t\tif (unobserve && callback && !callback._cId) {\n\t\t\t\torigRoots.shift();\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// Use a unique namespace (e.g. obs7) associated with each observe() callback to allow unobserve to remove handlers\n\t\t\tns += callback\n\t\t\t\t? ((inId = callback._inId || \"\"), unobserve)\n\t\t\t\t\t? callback._cId + inId\n\t\t\t\t\t: (cbId = getCbKey(callback)) + inId\n\t\t\t\t: \"\";\n\n\t\t\tif (cbId && !unobserve) {\n\t\t\t\tcbBindings = cbBindingsStore[cbId] = cbBindingsStore[cbId] || {};\n\t\t\t}\n\n\t\t\tinitNsArr = initialNs && initialNs.match(rNotWhite) || [\"\"];\n\t\t\tinitNsArrLen = initNsArr.length;\n\n\t\t\twhile (initNsArrLen--) {\n\t\t\t\tinitialNs = initNsArr[initNsArrLen];\n\t\t\t\tif (root && !paths[0]) {\n\t\t\t\t\tif ($isArray(root)) {\n\t\t\t\t\t\tbindArray(root, unobserve, true); // observe(array, handler)\n\t\t\t\t\t}\n\t\t\t\t\tif (unobserve) {\n\t\t\t\t\t\tobserveOnOff(ns, \"\"); // unobserve(objectOrArray[, handler])\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (unobserve && !l && !root) { // unobserve() - unobserves all\n\t\t\t\t\tfor (p in cbBindingsStore) {\n\t\t\t\t\t\tp = cbBindingsStore[p];\n\t\t\t\t\t\tfor (data in p) {\n\t\t\t\t\t\t\tobject = p[data];\n\t\t\t\t\t\t\tif ($isArray(object)) {\n\t\t\t\t\t\t\t\tbindArray(object, unobserve, unobserve);\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tobserveOnOff(ns, \"\");\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tdepth = 0;\n\t\t\t\tcbItemCount = 0;\n\t\t\t\tfor (i = 0; i < l; i++) {\n\t\t\t\t\tif (cbItemCount) {\n\t\t\t\t\t\tcbItemCount--; // contextCb was moved to a contextual parameter outer context. Needs to revert after cbItemCount\n\t\t\t\t\t} else {\n\t\t\t\t\t\tcontextCb = innerContextCb;\n\t\t\t\t\t}\n\n\t\t\t\t\tpath = paths[i];\n\t\t\t\t\tif (path === \"\" || path === root) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tif (path && path._ar) {\n\t\t\t\t\t\tallowArray += path._ar; // Switch on allowArray for depends paths, and off, afterwards.\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tobject = root;\n\t\t\t\t\tif (\"\" + path === path) {\n\t\t\t\t\t\t// Consider support for computed paths: jsviews/issues/292\n\t\t\t\t\t\t//if (/[\\(\\[\\+]/.test(path)) {\n\t\t\t\t\t\t//\tvar b={links:{}}, t = $sub.tmplFn(\"{:\"+path+\"}\", b, true), items = t.paths[0];\n\t\t\t\t\t\t//\tl += items.length - 1;\n\t\t\t\t\t\t//\tsplice.apply(paths, [i--, 1].concat(items));\n\t\t\t\t\t\t//\tcontinue;\n\t\t\t\t\t\t//}\n\t\t\t\t\t\tparts = path.split(\"^\");\n\t\t\t\t\t\tif (parts[1]) {\n\t\t\t\t\t\t\t// We bind the leaf, plus additional nodes based on depth.\n\t\t\t\t\t\t\t// \"a.b.c^d.e\" is depth 2, so listens to changes of e, plus changes of d and of c\n\t\t\t\t\t\t\tdepth = parts[0].split(\".\").length;\n\t\t\t\t\t\t\tpath = parts.join(\".\");\n\t\t\t\t\t\t\tdepth = path.split(\".\").length - depth;\n\t\t\t\t\t\t\t// if more than one ^ in the path, the first one determines depth\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (contextCb) {\n\t\t\t\t\t\t\titems = contextCb(path, root, depth);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcontextCb = innerContextCb;\n\t\t\t\t\t\tparts = path.split(\".\");\n\t\t\t\t\t} else if (path && path._cxp) { // contextual parameter\n\t\t\t\t\t\tview = path.shift();  // Contextual data\n\t\t\t\t\t\tif (_ocp in view) {\n\t\t\t\t\t\t\troot = view; // observable contextual parameter\n\t\t\t\t\t\t\tcontextCb = 0;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tcontextCb = $sub._gccb(view); // getContextCb: Get context callback for the contextual view (where contextual param evaluated/assigned)\n\t\t\t\t\t\t\troot = view.data;\n\t\t\t\t\t\t}\n\t\t\t\t\t\titems = path;\n\t\t\t\t\t\titems.push(origRoot);\n\t\t\t\t\t\tcbItemCount = items.length;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tif (!$isFunction(path)) {\n\t\t\t\t\t\t\tif (path && path._cpfn) {\n\t\t\t\t\t\t\t\t// Path is an exprOb returned by a computed property - helper/data function (compiled expr function).\n\t\t\t\t\t\t\t\t// Set current object on exprOb.ob, and get innerCb for updating the object\n\t\t\t\t\t\t\t\tinnerCb = unobserve ? path.cb : getInnerCb(path);\n\t\t\t\t\t\t\t\t// innerCb._ctx = callback._ctx; Could pass context (e.g. linkCtx) for use in a depends = function() {} call, so depends is different for different linkCtx's\n\t\t\t\t\t\t\t\tinnerCb._cId = callback._cId;\n\t\t\t\t\t\t\t\t// Set the same cbBindingsStore key as for callback, so when callback is disposed, disposal of innerCb happens too.\n\t\t\t\t\t\t\t\tinnerCb._inId = innerCb._inId || \".obIn\" + observeInnerCbKey++;\n\t\t\t\t\t\t\t\tif (path.bnd || path.prm && path.prm.length || !path.sb) {\n\t\t\t\t\t\t\t\t\t// If the exprOb is bound e.g. foo()^sub.path, or has parameters e.g. foo(bar) or is a leaf object (so no sub path) e.g. foo()\n\t\t\t\t\t\t\t\t\t// then observe changes on the object, or its parameters and sub-path\n\t\t\t\t\t\t\t\t\tinnerObserve([object], path.path, [path.root||root], path.prm, innerCb, contextCb, unobserve);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tif (path.sb) { // subPath\n\t\t\t\t\t\t\t\t\tif (path.sb.prm) {\n\t\t\t\t\t\t\t\t\t\tpath.sb.root = root;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\tinnerObserve([path.ob], path.sb, callback, contextCb, unobserve);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tpath = origRoot;\n\t\t\t\t\t\t\t\tobject = undefined;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tparts = [root = path];\n\t\t\t\t\t}\n\t\t\t\t\tif (items) {\n\t\t\t\t\t\t// If the array of objects and paths returned by contextCb is non empty, insert them\n\t\t\t\t\t\t// into the sequence, replacing the current item (path). Otherwise simply remove current item (path)\n\t\t\t\t\t\tl += items.length - 1;\n\t\t\t\t\t\tsplice.apply(paths, [i--, 1].concat(items));\n\t\t\t\t\t\titems = undefined;\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\twhile (object && (prop = parts.shift()) !== undefined) {\n\t\t\t\t\t\tif (typeof object === OBJECT) {\n\t\t\t\t\t\t\tif (\"\" + prop === prop) {\n\t\t\t\t\t\t\t\tif (prop === \"\") {\n\t\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tif ((parts.length < depth + 1) && !object.nodeType) {\n\t\t\t\t\t\t\t\t\t// Add observer for each token in path starting at depth, and on to the leaf\n\t\t\t\t\t\t\t\t\tif (!unobserve && (events = $hasData(object) && $._data(object))) {\n\t\t\t\t\t\t\t\t\t\tevents = events.events;\n\t\t\t\t\t\t\t\t\t\tevents = events && events[propertyChangeStr];\n\t\t\t\t\t\t\t\t\t\tel = events && events.length;\n\t\t\t\t\t\t\t\t\t\tskip = 0;\n\t\t\t\t\t\t\t\t\t\twhile (el--) { // Skip duplicates\n\t\t\t\t\t\t\t\t\t\t\tdata = events[el].data;\n\t\t\t\t\t\t\t\t\t\t\tif (data\n\t\t\t\t\t\t\t\t\t\t\t\t&& data.ns === initialNs\n\t\t\t\t\t\t\t\t\t\t\t\t&& data.cb._cId === callback._cId\n\t\t\t\t\t\t\t\t\t\t\t\t&& data.cb._inId === callback._inId\n\t\t\t\t\t\t\t\t\t\t\t\t&& (data.prop === prop || data.prop === \"*\" || data.prop === \"**\")) {\n\t\t\t\t\t\t\t\t\t\t\t\tif (p = parts.join(\".\")) {\n\t\t\t\t\t\t\t\t\t\t\t\t\tdata.paths.push(p); // We will skip this binding, but if it is not a leaf binding,\n\t\t\t\t\t\t\t\t\t\t\t\t\t// need to keep bindings for rest of path, ready for if the object gets swapped.\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\tskip++;\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\tif (skip) {\n\t\t\t\t\t\t\t\t\t\t\t// Duplicate binding(s) found, so move on\n\t\t\t\t\t\t\t\t\t\t\tobject = object[prop];\n\t\t\t\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\tif (prop === \"*\" || prop === \"**\") { // \"*\" => all properties. \"**\" => all properties and sub-properties (i.e. deep observeAll behavior)\n\t\t\t\t\t\t\t\t\t\tif (!unobserve && events && events.length) {\n\t\t\t\t\t\t\t\t\t\t\t// Remove existing bindings, since they will be duplicates with \"*\" or \"**\"\n\t\t\t\t\t\t\t\t\t\t\tobserveOnOff(ns, \"\", false, true);\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\tif (prop === \"*\") {\n\t\t\t\t\t\t\t\t\t\t\tobserveOnOff(ns, \"\"); // observe the object for any property change\n\t\t\t\t\t\t\t\t\t\t\tfor (p in object) {\n\t\t\t\t\t\t\t\t\t\t\t\t// observing \"*\": So (in addition to listening to prop change, above) listen to arraychange on props of type array\n\t\t\t\t\t\t\t\t\t\t\t\tif (p !== $expando) {\n\t\t\t\t\t\t\t\t\t\t\t\t\tbindArray(object, unobserve, undefined, p);\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\t\t\t$.observable(initialNs, object)[(unobserve ? \"un\" : \"\") + \"observeAll\"](callback); // observe or unobserve the object for any property change\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t} else if (prop) {\n\t\t\t\t\t\t\t\t\t\tobserveOnOff(ns + \".p_\" + prop, parts.join(\"^\")); // By using \"^\" rather than \".\" we ensure that deep binding will be used on newly inserted object graphs\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tif (allPath) {\n\t\t\t\t\t\t\t\t\tallPath += \".\" + prop;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tprop = object[prop];\n\t\t\t\t\t\t\t\tif (!parts[0]) {\n\t\t\t\t\t\t\t\t\tbindArray(prop, unobserve); // [un]observe(object, \"arrayProperty\") observes array changes on property of type array\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif ($isFunction(prop)) {\n\t\t\t\t\t\t\t\tif (dep = prop.depends) {\n\t\t\t\t\t\t\t\t\t// This is a computed observable. We will observe any declared dependencies.\n\t\t\t\t\t\t\t\t\t// Pass {_ar: ...} objects to switch on allowArray, for depends paths, then return to contextual allowArray value\n\t\t\t\t\t\t\t\t\tinnerObserve([object._ocp ? object.view.data : object], dependsPaths(dep, object, callback), callback, contextCb, unobserve);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tobject = prop;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (cbId) {\n\t\t\t\tremoveCbBindings(cbBindings, cbId);\n\t\t\t}\n\n\t\t\t// Return the cbBindings to the top-level caller, along with the cbId\n\t\t\torigRoots.shift();\n\t\t\treturn {cbId: cbId, bnd: cbBindings, s: cbBindingsStore};\n\t\t}\n\n\t\tvar initialNs,\n\t\t\tallowArray = this == 1 ? 0 : 1, // If this == 1, this is a call from observeAndBind - doing binding of datalink expressions. We don't bind\n\t\t\t// arrayChange events in this scenario. Instead, {^{for}} and similar do specific arrayChange binding to the tagCtx.args[0] value, in onAfterLink.\n\t\t\t// Note deliberately using this == 1, rather than this === 1 because of IE<10 bug- see jsviews/issues/237\n\t\t\tpaths = slice.call(arguments),\n\t\t\torigRoot = paths[0],\n\t\t\torigRoots = [origRoot];\n\n\t\tif (origRoot + \"\" === origRoot && allowArray) {\n\t\t\tinitialNs = origRoot; // The first arg is a namespace, since it is a string, and this call is not from observeAndBind\n\t\t\tpaths.shift();\n\t\t\torigRoot = paths[0];\n\t\t}\n\t\treturn innerObserve.apply(1, paths);\n\t};\n\n\t$observable = function(ns, data) {\n\t\tif (arguments.length === 1) {\n\t\t\tdata = ns;\n\t\t\tns = \"\";\n\t\t}\n\t\treturn $isArray(data)\n\t\t\t? new ArrayObservable(ns, data)\n\t\t\t: new ObjectObservable(ns, data);\n\t};\n\n\t//========================== Initialize ==========================\n\n\t$.observable = $observable;\n\t$observable._fltr = function(allPath, object, parentObs, filter) {\n\t\tif (filter && $isFunction(filter)\n\t\t\t? filter(allPath, object, parentObs)\n\t\t\t: true // TODO Consider supporting filter being a string or strings to do RegEx filtering based on key and/or allPath\n\t\t) {\n\t\t\tobject = $isFunction(object)\n\t\t\t\t? object.set && object.call(parentObs[0]) // It is a getter/setter\n\t\t\t\t: object;\n\t\t\treturn typeof object === OBJECT && object;\n\t\t}\n\t};\n\n\t$observable.Object = ObjectObservable;\n\t$observable.Array = ArrayObservable;\n\t$.observe = $observable.observe = $observe;\n\t$.unobserve = $observable.unobserve = $unobserve;\n\t$observable._apply = observe_apply;\n\n\tObjectObservable.prototype = {\n\t\t_data: null,\n\n\t\tobserveAll: $observeAll,\n\t\tunobserveAll: $unobserveAll,\n\n\t\tdata: function() {\n\t\t\treturn this._data;\n\t\t},\n\n\t\tsetProperty: function(path, value, nonStrict) {\n\t\t\tpath = path || \"\";\n\t\t\tvar key, pair, parts,\n\t\t\t\tmulti = path + \"\" !== path && !path._is, // Hash of paths, not view object\n\t\t\t\tself = this,\n\t\t\t\tobject = self._data;\n\n\t\t\tif (object) {\n\t\t\t\tif (multi) {\n\t\t\t\t\tnonStrict = value;\n\t\t\t\t\tif ($isArray(path)) {\n\t\t\t\t\t\t// This is the array format generated by serializeArray. However, this has the problem that it coerces types to string,\n\t\t\t\t\t\t// and does not provide simple support of convertTo and convertFrom functions.\n\t\t\t\t\t\tkey = path.length;\n\t\t\t\t\t\twhile (key--) {\n\t\t\t\t\t\t\tpair = path[key];\n\t\t\t\t\t\t\tself.setProperty(pair.name, pair.value, nonStrict === undefined || nonStrict); //If nonStrict not specified, default to true;\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\t// Object representation where property name is path and property value is value.\n\t\t\t\t\t\tfor (key in path) {\n\t\t\t\t\t\t\tself.setProperty(key, path[key], nonStrict);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} else if (path !== $expando) {\n\t\t\t\t\t// Simple single property case.\n\t\t\t\t\tif (path._is) {\n\t\t\t\t\t\tparts = [path];\n\t\t\t\t\t} else {\n\t\t\t\t\t\tparts = path.split(/[.^]/);\n\t\t\t\t\t\twhile (object && parts.length > 1) {\n\t\t\t\t\t\t\tobject = object[parts.shift()];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (object) {\n\t\t\t\t\t\tself._setProperty(object, parts[0], value, nonStrict);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn self;\n\t\t},\n\n\t\tremoveProperty: function(path) {\n\t\t\tthis.setProperty(path, remove);\n\t\t\treturn this;\n\t\t},\n\n\t\t_setProperty: function(leaf, path, value, nonStrict) {\n\t\t\tvar setter, getter, removeProp,\n\t\t\t\tproperty = path ? leaf[path] : leaf;\n\n\t\t\tif ($isFunction(property)) {\n\t\t\t\tif (property.set) {\n\t\t\t\t\t// Case of property setter/getter - with convention that property is getter and property.set is setter\n\t\t\t\t\tleaf = leaf._vw // Case of JsViews 2-way data-linking to an observable context parameter, with a setter.\n\t\t\t\t\t\t// The view will be the this pointer for getter and setter. Note: this is the one scenario where path is \"\".\n\t\t\t\t\t || leaf;\n\t\t\t\t\tgetter = property;\n\t\t\t\t\tsetter = getter.set === true ? getter : getter.set;\n\t\t\t\t\tproperty = getter.call(leaf); // get - only treated as getter if also a setter. Otherwise it is simply a property of type function.\n\t\t\t\t\t// See unit tests 'Can observe properties of type function'.\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif ((property !== value || nonStrict && property != value)\n\t\t\t\t// Optional non-strict equality, since serializeArray, and form-based editors can map numbers to strings, etc.\n\t\t\t\t// Date objects don't support != comparison. Treat as special case.\n\t\t\t\t&& (!(property instanceof Date && value instanceof Date) || property > value || property < value)) {\n\t\t\t\tif (setter) {\n\t\t\t\t\tsetter.call(leaf, value);   //set\n\t\t\t\t\tvalue = getter.call(leaf);  //get updated value\n\t\t\t\t} else if (removeProp = value === remove) {\n\t\t\t\t\tif (property !== undefined) {\n\t\t\t\t\t\tdelete leaf[path];\n\t\t\t\t\t\tvalue = undefined;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tpath = undefined; // If value was already undefined, don't trigger handler for removeProp\n\t\t\t\t\t}\n\t\t\t\t} else if (path) {\n\t\t\t\t\tleaf[path] = value;\n\t\t\t\t}\n\t\t\t\tif (path) {\n\t\t\t\t\tthis._trigger(leaf, {change: \"set\", path: path, value: value, oldValue: property, remove: removeProp});\n\t\t\t\t}\n\t\t\t}\n\t\t},\n\n\t\t_trigger: function(target, eventArgs) {\n\t\t\t$(target).triggerHandler(propertyChangeStr + (this._ns ? \".\" + /^\\S+/.exec(this._ns)[0] : \"\"), eventArgs); // If white-space separated namespaces, use first one only\n\t\t}\n\t};\n\n\tArrayObservable.prototype = {\n\t\t_data: null,\n\n\t\tobserveAll: $observeAll,\n\t\tunobserveAll: $unobserveAll,\n\n\t\tdata: function() {\n\t\t\treturn this._data;\n\t\t},\n\n\t\tinsert: function(index, data) {\n\t\t\tvar _data = this._data;\n\t\t\tif (arguments.length === 1) {\n\t\t\t\tdata = index;\n\t\t\t\tindex = _data.length;\n\t\t\t}\n\t\t\tindex = PARSEINT(index);\n\t\t\tif (index > -1) {\n\t\t\t\tdata = $isArray(data) ? data : [data];\n\t\t\t\t// data can be a single item (including a null/undefined value) or an array of items.\n\t\t\t\t// Note the provided items are inserted without being cloned, as direct references to the provided objects\n\n\t\t\t\tif (data.length) {\n\t\t\t\t\tthis._insert(index, data);\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn this;\n\t\t},\n\n\t\t_insert: function(index, data) {\n\t\t\tvar _data = this._data,\n\t\t\t\toldLength = _data.length;\n\t\t\tif (index > oldLength) {\n\t\t\t\tindex = oldLength;\n\t\t\t}\n\t\t\tsplice.apply(_data, [index, 0].concat(data));\n\t\t\tthis._trigger({change: \"insert\", index: index, items: data}, oldLength);\n\t\t},\n\n\t\tremove: function(index, numToRemove) {\n\t\t\tvar items,\n\t\t\t\t_data = this._data;\n\n\t\t\tif (index === undefined) {\n\t\t\t\tindex = _data.length - 1;\n\t\t\t}\n\n\t\t\tindex = PARSEINT(index);\n\t\t\tnumToRemove = numToRemove ? PARSEINT(numToRemove) : numToRemove === 0 ? 0 : 1; // if null or undefined: remove 1\n\t\t\tif (numToRemove > 0 && index > -1) {\n\t\t\t\titems = _data.slice(index, index + numToRemove);\n\t\t\t\tif (numToRemove = items.length) {\n\t\t\t\t\tthis._remove(index, numToRemove, items);\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn this;\n\t\t},\n\n\t\t_remove: function(index, numToRemove, items) {\n\t\t\tvar _data = this._data,\n\t\t\t\toldLength = _data.length;\n\n\t\t\t_data.splice(index, numToRemove);\n\t\t\tthis._trigger({change: \"remove\", index: index, items: items}, oldLength);\n\t\t},\n\n\t\tmove: function(oldIndex, newIndex, numToMove) {\n\t\t\tnumToMove = numToMove ? PARSEINT(numToMove) : numToMove === 0 ? 0 : 1; // if null or undefined: move 1\n\t\t\toldIndex = PARSEINT(oldIndex);\n\t\t\tnewIndex = PARSEINT(newIndex);\n\n\t\t\tif (numToMove > 0 && oldIndex > -1 && newIndex > -1 && oldIndex !== newIndex) {\n\t\t\t\tthis._move(oldIndex, newIndex, numToMove);\n\t\t\t}\n\t\t\treturn this;\n\t\t},\n\n\t\t_move: function(oldIndex, newIndex, numToMove) {\n\t\t\tvar items,\n\t\t\t\t_data = this._data,\n\t\t\t\toldLength = _data.length,\n\t\t\t\texcess = oldIndex + numToMove - oldLength;\n\t\t\tif (excess > 0) {\n\t\t\t\tnumToMove -= excess;\n\t\t\t}\n\t\t\tif (numToMove) {\n\t\t\t\titems = _data.splice(oldIndex, numToMove); // remove\n\t\t\t\tif (newIndex > _data.length) {\n\t\t\t\t\tnewIndex = _data.length;\n\t\t\t\t}\n\t\t\t\tsplice.apply(_data, [newIndex, 0].concat(items)); //re-insert\n\t\t\t\tif (newIndex !== oldIndex) {\n\t\t\t\t\tthis._trigger({change: \"move\", oldIndex: oldIndex, index: newIndex, items: items}, oldLength);\n\t\t\t\t}\n\t\t\t}\n\t\t},\n\n\t\trefresh: function(newItems) {\n\t\t\tfunction insertAdded() {\n\t\t\t\tif (k) {\n\t\t\t\t\tself.insert(j-k, addedItems); // Not found in original array - so insert\n\t\t\t\t\tdataLength += k;\n\t\t\t\t\ti += k;\n\t\t\t\t\tk = 0;\n\t\t\t\t\taddedItems = [];\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// For refresh operation we iteratively step through the target array and sort by move/add/remove operations on the source array until they match\n\t\t\tvar i, j, k, newItem, num,\n\t\t\t\tself = this,\n\t\t\t\taddedItems = [],\n\t\t\t\tdata = self._data,\n\t\t\t\toldItems = data.slice(),\n\t\t\t\toldLength = data.length,\n\t\t\t\tdataLength = oldLength,\n\t\t\t\tnewLength = newItems.length;\n\t\t\tself._srt = true; // Flag for sorting during refresh\n\t\t\tfor (j=k=0; j<newLength; j++) {\n\t\t\t\tif ((newItem = newItems[j]) === data[j-k]) {\n\t\t\t\t\t\tinsertAdded();\n\t\t\t\t} else {\n\t\t\t\t\tfor (i=j-k; i<dataLength; i++) {\n\t\t\t\t\t\tif (newItem === data[i]) {\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (i<dataLength) {\n\t\t\t\t\t\tinsertAdded();\n\t\t\t\t\t\tnum = 0;\n\t\t\t\t\t\twhile (num++ < newLength-i && newItems[j+num] === data[i+num]);\n\t\t\t\t\t\tself.move(i, j, num); // Found newItem in original array - so move it to new position\n\t\t\t\t\t\tj += num - 1;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tk++;\n\t\t\t\t\t\taddedItems.push(newItem); // Not found in original array - so insert\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tinsertAdded();\n\t\t\tif (dataLength > j) {\n\t\t\t\tself.remove(j, dataLength - j);\n\t\t\t}\n\t\t\tself._srt = undefined; // We have finished sort operations during refresh\n\t\t\tself._trigger({change: \"refresh\", oldItems: oldItems}, oldLength);\n\t\t\treturn self;\n\t\t},\n\n\t\t_trigger: function(eventArgs, oldLength) {\n\t\t\tvar self = this,\n\t\t\t\t_data = self._data,\n\t\t\t\tlength = _data.length,\n\t\t\t\t$_data = $([_data]);\n\t\t\tif (self._srt) {\n\t\t\t\teventArgs.refresh = true; // We are sorting during refresh\n\t\t\t} else if (length !== oldLength) { // We have finished sort operations during refresh\n\t\t\t\t$_data.triggerHandler(propertyChangeStr, {change: \"set\", path: \"length\", value: length, oldValue: oldLength});\n\t\t\t}\n\t\t\t$_data.triggerHandler(arrayChangeStr + (self._ns ? \".\" + /^\\S+/.exec(self._ns)[0] : \"\"), eventArgs); // If white-space separated namespaces, use first one only\n\t\t}\n\t};\n\n\t$eventSpecial[propertyChangeStr] = $eventSpecial[arrayChangeStr] = {\n\t\t// Register a jQuery special 'remove' event, to access the data associated with handlers being removed by jQuery.off().\n\t\t// We get data.cb._cId from the event handleObj and get the corresponding cbBindings hash from the cbBindingsStore,\n\t\t// then remove this object from that bindings hash - if the object does not have any other handlers associated with the same callback.\n\t\tremove: function (handleObj) {\n\t\t\tvar cbBindings, found, events, l, data,\n\t\t\t\tevData = handleObj.data;\n\t\t\tif ((evData) && (evData.off = true, evData = evData.cb)) { //Set off = true as marker for disposed event\n\t\t\t\t// Get the cb._cId from handleObj.data.cb._cId\n\t\t\t\tif (cbBindings = cbBindingsStore[evData._cId]) {\n\t\t\t\t\t// There were bindings for this callback. If this was the last one, we'll remove it.\n\t\t\t\t\tevents = $._data(this).events[handleObj.type];\n\t\t\t\t\tl = events.length;\n\t\t\t\t\twhile (l-- && !found) {\n\t\t\t\t\t\tfound = (data = events[l].data) && data.cb && data.cb._cId === evData._cId;\n\t\t\t\t\t\t// Found another one with same callback (though may be a different innerCallback)\n\t\t\t\t\t}\n\t\t\t\t\tif (!found) {\n\t\t\t\t\t\t// This was the last handler for this callback and object, so remove the binding entry\n\t\t\t\t\t\tdelete cbBindings[$data(this).obId];\n\t\t\t\t\t\tremoveCbBindings(cbBindings, evData._cId);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t};\n\n\t$views.map = function(mapDef) {\n\t\tfunction Map(source, options, target, unbound) {\n\t\t\tvar changing,\n\t\t\t\tmap = this;\n\t\t\tif (this.src) {\n\t\t\t\tthis.unmap(); // We are re-mapping a new source\n\t\t\t}\n\t\t\tif (typeof source === OBJECT) {\n\t\t\t\tmap.src = source;\n\t\t\t\tmap.tgt = target || map.tgt || [];\n\t\t\t\tmap.options = options || map.options;\n\t\t\t\tmap.update();\n\t\t\t\tif (!unbound) {\n\t\t\t\t\tif (mapDef.obsSrc) {\n\t\t\t\t\t\t$observable(map.src).observeAll(map.obs = function(ev, eventArgs) {\n\t\t\t\t\t\t\tif (!changing) {\n\t\t\t\t\t\t\t\tchanging = true;\n\t\t\t\t\t\t\t\tmapDef.obsSrc(map, ev, eventArgs);\n\t\t\t\t\t\t\t\tchanging = undefined;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}, map.srcFlt);\n\t\t\t\t\t}\n\t\t\t\t\tif (mapDef.obsTgt) {\n\t\t\t\t\t\t$observable(map.tgt).observeAll(map.obt = function(ev, eventArgs) {\n\t\t\t\t\t\tif (!changing) {\n\t\t\t\t\t\t\tchanging = true;\n\t\t\t\t\t\t\tmapDef.obsTgt(map, ev, eventArgs);\n\t\t\t\t\t\t\tchanging = undefined;\n\t\t\t\t\t\t}\n\t\t\t\t\t\t}, map.tgtFlt);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif ($isFunction(mapDef)) {\n\t\t\t// Simple map declared as function\n\t\t\tmapDef = {\n\t\t\t\tgetTgt: mapDef\n\t\t\t};\n\t\t}\n\n\t\tif (mapDef.baseMap) {\n\t\t\tmapDef = $.extend({}, mapDef.baseMap, mapDef);\n\t\t}\n\n\t\tmapDef.map = function(source, options, target, unbound) {\n\t\t\treturn new Map(source, options, target, unbound);\n\t\t};\n\n\t\t(Map.prototype = {\n\t\t\tsrcFlt: mapDef.srcFlt || shallowFilter, // default to shallowFilter\n\t\t\ttgtFlt: mapDef.tgtFlt || shallowFilter,\n\t\t\tupdate: function(options) {\n\t\t\t\tvar map = this;\n\t\t\t\t$observable(map.tgt).refresh(mapDef.getTgt(map.src, map.options = options || map.options));\n\t\t\t},\n\t\t\tunmap: function() {\n\t\t\t\tvar map = this;\n\t\t\t\tif (map.src) {\n\t\t\t\t\tif (map.obs) {\n\t\t\t\t\t\t$observable(map.src).unobserveAll(map.obs, map.srcFlt);\n\t\t\t\t\t}\n\t\t\t\t\tif (map.obt) {\n\t\t\t\t\t\t$observable(map.tgt).unobserveAll(map.obt, map.tgtFlt);\n\t\t\t\t\t}\n\t\t\t\t\tmap.src = undefined;\n\t\t\t\t}\n\t\t\t},\n\t\t\tmap: Map,\n\t\t\t_def: mapDef\n\t\t}).constructor = Map;\n\n\t\treturn mapDef;\n\t};\n\n\t$sub.advSet = function() { // refresh advanced settings\n\t\t$sub._gccb = this._gccb; // getContextCallback method\n\t\tglobal._jsv = $subSettings.advanced._jsv\n\t\t\t? { // create global _jsv, for accessing views, etc\n\t\t\t\t\tcbBindings: cbBindingsStore\n\t\t\t\t}\n\t\t\t: undefined; // In IE8 cannot do delete global._jsv\n\t};\n\t$sub._dp = dependsPaths;\n}\n\nreturn $;\n}, window));\n"]}