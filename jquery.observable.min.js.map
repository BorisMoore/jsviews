{"version":3,"sources":["jquery.observable.js"],"names":["factory","global","$","jQuery","exports","module","define","amd","setGlobals","fn","$observe","$observable","versionNumber","$views","views","jsrender","jsviews","sub","settings","advanced","value","$subSettingsAdvanced","$subSettings","_jsv","$sub","advSet","$isFunction","ob","$isArray","Array","isArray","$expando","expando","STRING","OBJECT","observe","$eventSpecial","event","special","slice","splice","concat","PARSEINT","parseInt","rNotWhite","rShallowPath","propertyChangeStr","propChng","arrayChangeStr","arrChng","cbBindingsStore","observeStr","observeObjKey","observeCbKey","observeInnerCbKey","$data","data","remove","asyncBatch","getCbKey","cb","_cId","ObjectObservable","ns","this","_data","_ns","ArrayObservable","wrapArray","dependsPaths","paths","root","callback","i","path","object","rt","nextObj","l","length","out","tagName","linkCtx","call","push","undefined","unshift","_ar","onDataChange","ev","eventArgs","isOb","val","noArray","off","allPath","filter","parentObs","oldValue","ctx","observeAll","_arOk","type","array","prop","_path","target","parents","observe_apply","args","apply","arguments","shift","$observeAll","unobserve","$unobserveAll","namespace","objMap","observeArrayItems","arr","unobs","newAllPath","filterAndObserveAll","obj","nestedArray","newObject","newParentObs","_fltr","nextParentObs","updatedTgt","wrappedCb","change","items","_wrp","isObject","obId","notRemoving","un","hasData","shallowFilter","test","$unobserve","batchTrigger","async","batch","_go","skip","_trigger","innerObserve","unobserveBinding","binding","bindArray","observeOnOff","fullPath","pathStr","isArrayBinding","j","evData","dataOb","boundObOrArr","prntObs","allPth","initialNs","events","el","_inId","allowArray","replace","all","inArray","on","cbBindings","len","unbind","relPath","prevAllPath","observeObjects","observeObjectPaths","pths","contextCb","getInnerCb","exprOb","sb","newObj","observePath","prts","obArrAddRemove","arrIndex","dep","obArr","prt","fnProp","isGet","_cxp","depth","nodeType","join","observable","depends","_vw","_ocp","_tgId","tagCtx","view","_is","_gccb","contentView","parts","split","pth","_cpfn","innerCb","bnd","prm","p","cbId","inId","initNsArr","initNsArrLen","lastArg","pop","m","match","s","wait","setTimeout","trigger","delay","asyncObserve","_batch","set","Object","_apply","prototype","unobserveAll","setProperty","nonStrict","isCpfn","key","pair","tempBatch","multi","self","name","_setProperty","removeProperty","leaf","setter","getter","removeProp","property","Date","ctxPrm","_key","force","_cchCt","previous","triggerHandler","exec","insert","index","_insert","oldLength","numToRemove","_remove","move","oldIndex","newIndex","numToMove","_move","excess","refresh","newItems","insertAdded","k","addedItems","dataLength","newItem","num","oldItems","newLength","_srt","_dly","handleObj","found","map","mapDef","Map","source","options","oldMapOrTarget","unbound","changing","updatedMap","src","unmap","tgt","getTgt","update","obsSrc","obs","srcFlt","obsTgt","obt","_updt","tgtFlt","baseMap","extend","oldMap","newMap","deps","obmp","newTagCtx","props","tag","_ctxCb","_def","constructor","_dp","_gck","_obs","useViews","window"],"mappings":"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","file":"jquery.observable.min.js","sourcesContent":["/*! JsObservable v1.0.16: http://jsviews.com/#jsobservable */\n/*\n * Subcomponent of JsViews\n * Data change events for data-linking\n *\n * Copyright 2025, Boris Moore\n * Released under the MIT License.\n */\n\n//jshint -W018, -W041, -W120\n\n(function(factory, global) {\n\t// global var is the this object, which is window when running in the usual browser environment\n\tvar $ = global.jQuery;\n\n\tif (typeof exports === \"object\") { // CommonJS e.g. Browserify\n\t\tmodule.exports = $\n\t\t\t? factory(global, $)\n\t\t\t: function($) { // If no global jQuery, take jQuery passed as parameter: require(\"jsobservable\")(jQuery)\n\t\t\t\treturn factory(global, $);\n\t\t\t};\n\t} else if (typeof define === \"function\" && define.amd) { // AMD script loader, e.g. RequireJS\n\t\tdefine([\"jquery\"], function($) {\n\t\t\treturn factory(global, $); // Require jQuery\n\t\t});\n\t} else { // Browser using plain <script> tag\n\t\tfactory(global, false);\n\t}\n} (\n\n// factory (for jsviews.js)\nfunction(global, $) {\n\"use strict\";\n\n//========================== Top-level vars ==========================\n\n// global var is the this object, which is window when running in the usual browser environment\nvar setGlobals = $ === false; // Only set globals if script block in browser (not AMD and not CommonJS)\n\n$ = $ || global.jQuery;\n\nif (!$ || !$.fn) {\n\t// jQuery is not loaded.\n\tthrow \"jquery.observable.js requires jQuery\"; // We require jQuery\n}\n\nvar versionNumber = \"v1.0.16\",\n\t_ocp = \"_ocp\", // Observable contextual parameter\n\t$observe, $observable,\n\n\t$views = $.views =\n\t\t$.views ||\n\t\tsetGlobals && global.jsrender && jsrender.views || //jsrender was loaded before jquery.observable\n\t\t{ // jsrender not loaded so set up $.views and $.views.sub here, and merge back in jsrender if loaded afterwards\n\t\t\tjsviews: versionNumber,\n\t\t\tsub: { // subscription, e.g. JsViews integration\n\t\t\t\tsettings: {}\n\t\t\t},\n\t\t\tsettings: {\n\t\t\t\tadvanced: function(value) {\n\t\t\t\t\t$subSettingsAdvanced = $subSettings.advanced = $subSettings.advanced || {_jsv: true};\n\t\t\t\t\treturn value\n\t\t\t\t\t\t? (\n\t\t\t\t\t\t\t\"_jsv\" in value && ($subSettingsAdvanced._jsv = value._jsv),\n\t\t\t\t\t\t\t$sub.advSet(),\n\t\t\t\t\t\t\t$views.settings\n\t\t\t\t\t\t)\n\t\t\t\t\t\t: $subSettingsAdvanced;\n\t\t\t\t\t}\n\t\t\t}\n\t\t},\n\t$sub = $views.sub,\n\t$subSettings = $sub.settings,\n\t$subSettingsAdvanced = $subSettings.advanced,\n\t$isFunction = function(ob) { return typeof ob === \"function\"; },\n\t$isArray = Array.isArray,\n\t$expando = $.expando,\n\tSTRING = \"string\",\n\tOBJECT = \"object\";\n\nif ($views.jsviews !== versionNumber) {\n\t// Different version of jsRender was loaded\n\tthrow \"jquery.observable.js requires jsrender.js \" + versionNumber;\n}\n\nif (!$.observe) {\n\n\tvar $eventSpecial = $.event.special,\n\t\tslice = [].slice,\n\t\tsplice = [].splice,\n\t\tconcat = [].concat,\n\t\tPARSEINT = parseInt,\n\t\trNotWhite = /\\S+/g,\n\t\trShallowPath = /^[^.[]*$/, // No '.' or '[' in path\n\t\tpropertyChangeStr = $sub.propChng = $sub.propChng || \"propertyChange\",// These two settings can be overridden on settings after loading\n\t\tarrayChangeStr = $sub.arrChng = $sub.arrChng || \"arrayChange\",        // jsRender, and prior to loading jquery.observable.js and/or JsViews\n\t\tcbBindingsStore = {},\n\t\tobserveStr = propertyChangeStr + \".observe\",\n\t\tobserveObjKey = 1,\n\t\tobserveCbKey = 1,\n\t\tobserveInnerCbKey = 1,\n\t\t$data = $.data,\n\t\tremove = {}, // flag for removeProperty\n\t\tasyncBatch = [],\n\n\t//========================== Top-level functions ==========================\n\n\tgetCbKey = function(cb) {\n\t\treturn cb\n\t\t? (cb._cId = cb._cId || (\".obs\" + observeCbKey++))\n\t\t: \"\";\n\t},\n\n\tObjectObservable = function(ns, data) {\n\t\tthis._data = data;\n\t\tthis._ns = ns;\n\t\treturn this;\n\t},\n\n\tArrayObservable = function(ns, data) {\n\t\tthis._data = data;\n\t\tthis._ns = ns;\n\t\treturn this;\n\t},\n\n\twrapArray = function(data) {\n\t\treturn $isArray(data)\n\t\t\t? [data]\n\t\t\t: data;\n\t},\n\n\tdependsPaths = function(paths, root, callback) {\n\t\t// Process depends = ... paths to resolve objects, and recursively process functions.\n\t\tpaths = paths\n\t\t\t? $isArray(paths)\n\t\t\t\t? paths\n\t\t\t\t: [paths]\n\t\t\t: [];\n\n\t\tvar i, path, object, rt,\n\t\t\tnextObj = object = root,\n\t\t\tl = paths && paths.length,\n\t\t\tout = [];\n\n\t\tfor (i = 0; i < l; i++) {\n\t\t\tpath = paths[i];\n\t\t\tif ($isFunction(path)) { // path is a depends function, returning [path1, ...]\n\t\t\t\trt = root.tagName\n\t\t\t\t\t\t? root.linkCtx.data // root is tag instance. rt is current data context of tag\n\t\t\t\t\t\t: root; // rt = root = current data context of computed prop\n\t\t\t\tout = out.concat(dependsPaths(path.call(root, rt, callback), rt, callback));\n\t\t\t\tcontinue;\n\t\t\t} else if (typeof path !== STRING) {\n\t\t\t\troot = nextObj = path = (path === undefined ? null : path);\n\t\t\t\tif (nextObj !== object) {\n\t\t\t\t\tout.push(object = nextObj);\n\t\t\t\t}\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (nextObj !== object) {\n\t\t\t\tout.push(object = nextObj);\n\t\t\t}\n\t\t\tout.push(path);\n\t\t}\n\t\tif (out.length) {\n\t\t\t// Switch on allowArray, for depends paths, by passing {_ar: ...} objects to switch on allowArray then return to contextual allowArray value\n\t\t\tout.unshift({_ar: 1});\n\t\t\tout.push({_ar: -1});\n\t\t}\n\t\treturn out;\n\t},\n\n\tonDataChange = function(ev, eventArgs) {\n\t\tfunction isOb(val) {\n\t\t\treturn typeof val === OBJECT && (paths[0] || !noArray && $isArray(val));\n\t\t}\n\n\t\tif (!(ev.data && ev.data.off)) {\n\t\t\t// Skip if !!ev.data.off: - a handler that has already been removed (maybe was on handler collection at call time - then removed by another handler)\n\t\t\tvar allPath, filter, parentObs,\n\t\t\t\toldValue = eventArgs.oldValue,\n\t\t\t\tvalue = eventArgs.value,\n\t\t\t\tctx = ev.data,\n\t\t\t\tobserveAll = ctx.observeAll,\n\t\t\t\tcb = ctx.cb,\n\t\t\t\tnoArray = ctx._arOk ? 0 : 1,\n\t\t\t\tpaths = ctx.paths,\n\t\t\t\tns = ctx.ns;\n\n\t\t\tif (ev.type === arrayChangeStr) {\n\t\t\t\t(cb.array || cb).call(ctx, ev, eventArgs); // If there is an arrayHandler expando on the regular handler, use it, otherwise use the regular handler for arrayChange events also - for example: $.observe(array, handler)\n\t\t\t\t// or observeAll() with an array in the graph. Note that on data-link bindings we ensure always to have an array handler - $.noop if none is specified e.g. on the data-linked tag.\n\t\t\t} else if (ctx.prop === eventArgs.path || ctx.prop === \"*\") {\n\t\t\t\tif (observeAll) {\n\t\t\t\t\tallPath = observeAll._path + \".\" + eventArgs.path;\n\t\t\t\t\tfilter = observeAll.filter;\n\t\t\t\t\tparentObs = [ev.target].concat(observeAll.parents());\n\n\t\t\t\t\tif (isOb(oldValue)) {\n\t\t\t\t\t\tobserve_apply(undefined, ns, [oldValue], paths, cb, true, filter, [parentObs], allPath); // unobserve\n\t\t\t\t\t}\n\t\t\t\t\tif (isOb(value)) {\n\t\t\t\t\t\tobserve_apply(undefined, ns, [value], paths, cb, undefined, filter, [parentObs], allPath);\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tif (isOb(oldValue)) { // oldValue is an object, so unobserve\n\t\t\t\t\t\tobserve_apply(noArray, ns, [oldValue], paths, cb, true); // unobserve. Observe array change events too if this change is not from an 'observeAndBind' tag binding, or is from a 'depends' path\n\t\t\t\t\t}\n\t\t\t\t\tif (isOb(value)) { // value is an object, so observe\n\t\t\t\t\t\tobserve_apply(noArray, ns, [value], paths, cb); // observe. Observe array change events too if this change is not from an 'observeAndBind' tag binding, or is from a 'depends' path\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tctx.cb(ev, eventArgs);\n\t\t\t}\n\t\t}\n\t},\n\n\tobserve_apply = function() {\n\t\t// $.observe(), but allowing you to include arrays within the arguments - which you want flattened.\n\t\tvar args = concat.apply([], arguments); // Flatten the arguments\n\t\treturn $observe.apply(args.shift(), args);\n\t},\n\n\t$observeAll = function(cb, filter, unobserve) {\n\t\tobserveAll(this._ns, this._data, cb, filter, [], \"root\", unobserve);\n\t},\n\n\t$unobserveAll = function(cb, filter) {\n\t\t$observeAll.call(this, cb, filter, true);\n\t},\n\n\tobserveAll = function(namespace, object, cb, filter, parentObs, allPath, unobserve, objMap) {\n\t\tfunction observeArrayItems(arr, unobs) {\n\t\t\tl = arr.length;\n\t\t\tnewAllPath = allPath + \"[]\";\n\t\t\twhile (l--) {\n\t\t\t\tfilterAndObserveAll(arr, l, unobs, 1);\n\t\t\t}\n\t\t}\n\n\t\tfunction filterAndObserveAll(obj, prop, unobs, nestedArray) {\n\t\t\tvar newObject, newParentObs;\n\t\t\tif (prop !== $expando && (newObject = $observable._fltr(newAllPath, obj[prop], nextParentObs, filter))) {\n\t\t\t\tnewParentObs = nextParentObs.slice();\n\t\t\t\tif (nestedArray && updatedTgt && newParentObs[0] !== updatedTgt) {\n\t\t\t\t\tnewParentObs.unshift(updatedTgt); // For array change events when observing an array which is not the root, need to add updated array to parentObs\n\t\t\t\t}\n\t\t\t\tobserveAll(namespace, newObject, cb, filter || (nestedArray ? undefined : 0), newParentObs, newAllPath, unobs, objMap);\n\t\t\t}\n\t\t}\n\n\t\tfunction wrappedCb(ev, eventArgs) {\n\t\t\t// This object is changing.\n\t\t\tallPath = ev.data.observeAll._path;\n\t\t\tupdatedTgt = ev.target;\n\t\t\tswitch (eventArgs.change) { // observeAll/unobserveAll on added or removed objects\n\t\t\t\tcase \"insert\":\n\t\t\t\t\tobserveArrayItems(eventArgs.items);\n\t\t\t\t\tbreak;\n\t\t\t\tcase \"remove\":\n\t\t\t\t\tobserveArrayItems(eventArgs.items, true); // unobserveAll on removed items\n\t\t\t\t\tbreak;\n\t\t\t\tcase \"set\":\n\t\t\t\t\tnewAllPath = allPath + \".\" + eventArgs.path;\n\t\t\t\t\tfilterAndObserveAll(eventArgs, \"oldValue\", true); // unobserve old value\n\t\t\t\t\tfilterAndObserveAll(eventArgs, \"value\"); // observe new value\n\t\t\t}\n\t\t\tupdatedTgt = undefined;\n\t\t\tcb.apply(this, arguments); // Observe this object (invoke the callback)\n\t\t}\n\t\twrappedCb._wrp = 1;\n\n\t\tvar l, isObject, newAllPath, nextParentObs, updatedTgt, obId,\n\t\t\tnotRemoving = !objMap || objMap.un || !unobserve; // true unless it is an observeAll call (not unobserveAll) and we are removing a listener (not adding one)\n\n\t\tif (object && typeof object === OBJECT) {\n\t\t\tnextParentObs = [object].concat(parentObs); // The parentObs chain for the next depth of observeAll\n\t\t\tisObject = $isArray(object) ? \"\" : \"*\";\n\t\t\tif (objMap && notRemoving && $.hasData(object) && objMap[obId = $data(object).obId]) {\n\t\t\t\tobjMap[obId]++;\n\t\t\t\treturn; // This object has already being observed/unobserved by this observeAll/unobserveAll call (must be a cyclic object graph) so skip, to avoid\n\t\t\t\t// stack overflow/multiple instances of listener. See jsviews/pull/305\n\t\t\t\t// NOTE - WE DO NOT support ObserveAll on data with cyclic graphs which include DUPLICATE REFERENCES TO ARRAY PROPERTIES - such as data.children = data.descendants = []\n\t\t\t}\n\t\t\tif (!objMap) {\n\t\t\t\tobjMap = {un: unobserve}; // Map object to register observed objects for this observeAll\n\t\t\t}\n\n\t\t\tif (cb) {\n\t\t\t\t// Observe this object or array - and also listen for changes to object graph, to add or remove observers from the modified object graph\n\t\t\t\tif (isObject || filter !== 0) {\n\t\t\t\t\t// If an object, observe the object. If an array, only add arrayChange binding if has filter or if filter is undefined (!== 0) - which\n\t\t\t\t\t// is the case for top-level calls or for nested array (array item of an array - e.g. member of 2-dimensional array).\n\t\t\t\t\t// For array properties lower in the tree, with no filter, filter is set to 0 in filterAndObserveAll, so no arrayChange binding here,\n\t\t\t\t\t// since they get arrayChange binding added during regular $.observe(array ...) binding.\n\t\t\t\t\twrappedCb._cId = getCbKey(cb); // Identify wrapped callback with unwrapped callback, so unobserveAll will\n\t\t\t\t\t\t\t\t\t\t\t\t\t// remove previous observeAll wrapped callback, if inner callback was the same;\n\t\t\t\t\tif (notRemoving) {\n\t\t\t\t\t\t$observe(namespace, object, isObject, wrappedCb, unobserve, filter, nextParentObs, allPath);\n\t\t\t\t\t\tobId = $data(object).obId;\n\t\t\t\t\t\tobjMap[obId] = (objMap[obId] || 0) + 1; // Register on map of objects observed/unobserved by this observeAll/unobserveAll call\n\t\t\t\t\t\t\t//- or remove from map if we are removing this object from observeAll call. (Avoid dups, for cyclic graphs)\n\t\t\t\t\t} else {\n\t\t\t\t\t\tif (--objMap[$data(object).obId]) {\n\t\t\t\t\t\t\t// Register on map of objects observed/unobserved by this observeAll/unobserveAll call\n\t\t\t\t\t\t\t//- or remove from map if we are removing this object from observeAll call. (Avoid dups, for cyclic graphs)\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t}\n\t\t\t\t\t\t$observe(namespace, object, isObject, wrappedCb, unobserve, filter, nextParentObs, allPath);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t// No callback. Just unobserve if unobserve === true.\n\t\t\t\tif (objMap) {\n\t\t\t\t\tobjMap[$data(object).obId] = 1; // Register on map of objects unobserved by this unobserveAll call. (Avoid dups, for cyclic graphs)\n\t\t\t\t}\n\t\t\t\t$observe(namespace, object, isObject, undefined, unobserve, filter, nextParentObs, allPath);\n\t\t\t}\n\n\t\t\tif (isObject) {\n\t\t\t\t// Continue stepping through object graph, observing object and arrays\n\t\t\t\t// To override filtering, pass in filter function, or replace $.observable._fltr\n\t\t\t\tfor (l in object) {\n\t\t\t\t\tnewAllPath = allPath + \".\" + l;\n\t\t\t\t\tfilterAndObserveAll(object, l, unobserve);\n\t\t\t\t}\n\t\t\t} else { // Observe items in Array\n\t\t\t\tobserveArrayItems(object, unobserve);\n\t\t\t}\n\t\t}\n\t},\n\n\tshallowFilter = function(path /*, object, parentObs*/) {\n\t\treturn rShallowPath.test(path); // No '.' and no '[' in path\n\t},\n\n\t$unobserve = function() {\n\t\t[].push.call(arguments, true); // Add true as additional final argument\n\t\treturn $observe.apply(undefined, arguments);\n\t},\n\n\tbatchTrigger = function(async) {\n\t\tvar event,\n\t\tbatch = this.slice();\n\t\tthis.length = 0;\n\t\tthis._go = 0;\n\t\twhile (event = batch.shift()) {\n\t\t\tif (!event.skip) {\n\t\t\t\tevent[0]._trigger(event[1], event[2], true);\n\t\t\t}\n\t\t}\n\t\tthis.paths = {};\n\t};\n\n\t$observe = function() {\n\t\t// $.observe([namespace, ]root, [1 or more objects, path or path Array params...], callback[, contextCallback][, unobserve])\n\n\t\tfunction innerObserve() {\n\t\t\tvar p, parts, unobserve, callback, cbId, inId, data, contextCb, items, cbBindings,\n\t\t\t\tinnerCb, parentObs, allPath, filter, initNsArr, initNsArrLen, view, prop, events, el;\n\n\t\t\tfunction unobserveBinding(cb, binding) {\n\t\t\t\tvar object;\n\t\t\t\tfor (data in binding) {\n\t\t\t\t\tobject = binding[data];\n\t\t\t\t\tif ($isArray(object)) {\n\t\t\t\t\t\tbindArray(cb, object, unobserve, unobserve);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tobserveOnOff(cb, object, undefined, ns, \"\");\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tfunction observeOnOff(cb, object, fullPath, namespace, pathStr, isArrayBinding, off) {\n\t\t\t\tvar j, evData, dataOb,\n\t\t\t\t\tboundObOrArr = wrapArray(object),\n\t\t\t\t\tprntObs = parentObs,\n\t\t\t\t\tallPth = allPath;\n\n\t\t\t\tnamespace = initialNs ? namespace + \".\" + initialNs : namespace;\n\n\t\t\t\tif (!unobserve && (off || isArrayBinding)) {\n\t\t\t\t\tevents = $._data(object).events;\n\t\t\t\t\tevents = events && events[isArrayBinding ? arrayChangeStr : propertyChangeStr];\n\t\t\t\t\tel = events && events.length;\n\t\t\t\t\twhile (el--) { // Skip duplicates\n\t\t\t\t\t\tdata = events[el] && events[el].data;\n\t\t\t\t\t\tif (data && (off && data.ns !== initialNs\n\t\t\t\t\t\t\t// When observing, don't unbind dups unless they have the same namespace\n\t\t\t\t\t\t\t|| !off && data.ns === initialNs && data.cb && data.cb._cId === cb._cId && data.cb._inId === cb._inId && (!cb._wrp || data.cb._wrp)))\n\t\t\t\t\t\t\t// When observing and doing array binding, don't bind dups if they have the same namespace (Dups can happen e.g. with {^{for people ^~foo=people}})\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (unobserve || off) {\n\t\t\t\t\t$(boundObOrArr).off(namespace, onDataChange);\n\t\t\t\t} else {\n\t\t\t\t\tevData = isArrayBinding ? {}\n\t\t\t\t\t\t: {\n\t\t\t\t\t\t\tfullPath: fullPath,\n\t\t\t\t\t\t\tpaths: pathStr ? [pathStr] : [],\n\t\t\t\t\t\t\tprop: prop,\n\t\t\t\t\t\t\t_arOk: allowArray\n\t\t\t\t\t\t};\n\t\t\t\t\tevData.ns = initialNs;\n\t\t\t\t\tevData.cb = cb;\n\n\t\t\t\t\tif (allPath) {\n\t\t\t\t\t\t// This is an observeAll call\n\t\t\t\t\t\tevData.observeAll = {\n\t\t\t\t\t\t\t_path: allPth,\n\t\t\t\t\t\t\tpath: function() { // Step through path and parentObs parent chain, replacing '[]' by '[n]' based on current index of objects in parent arrays.\n\t\t\t\t\t\t\t\tj = prntObs.length;\n\t\t\t\t\t\t\t\treturn allPth.replace(/[[.]/g, function(all) {\n\t\t\t\t\t\t\t\t\tj--;\n\t\t\t\t\t\t\t\t\treturn all === \"[\"\n\t\t\t\t\t\t\t\t\t\t? \"[\" + $.inArray(prntObs[j - 1], prntObs[j])\n\t\t\t\t\t\t\t\t\t\t: \".\";\n\t\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tparents: function() {\n\t\t\t\t\t\t\t\treturn prntObs; // The chain of parents between the modified object and the root object used in the observeAll() call\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tfilter: filter\n\t\t\t\t\t\t};\n\t\t\t\t\t}\n\t\t\t\t\t$(boundObOrArr).on(namespace, null, evData, onDataChange);\n\t\t\t\t\tif (cbBindings) {\n\t\t\t\t\t\t// Add object to cbBindings\n\t\t\t\t\t\tdataOb = $data(object);\n\t\t\t\t\t\tdataOb = dataOb.obId || (dataOb.obId = observeObjKey++);\n\t\t\t\t\t\tcbBindings[dataOb] = cbBindings[dataOb] || (cbBindings.len++, object);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tfunction bindArray(cb, arr, unbind, isArray, relPath) {\n\t\t\t\tif (allowArray) {\n\t\t\t\t\t// allowArray is 1 if this is a call to observe that does not come from observeAndBind (tag binding), or is from a 'depends' path,\n\t\t\t\t\t// or for a tag with tag.onArrayChange = true - so we allow arrayChange binding. Otherwise allowArray is zero.\n\t\t\t\t\tvar object,\n\t\t\t\t\t\tprevAllPath = allPath;\n\n\t\t\t\t\tobject = arr;\n\t\t\t\t\tif (relPath) {\n\t\t\t\t\t\tobject = arr[relPath];\n\t\t\t\t\t\tallPath = allPath ? allPath + \".\" + relPath : allPath;\n\t\t\t\t\t}\n\n\t\t\t\t\tif (isArray || $isArray(object)) {\n\t\t\t\t\t\tif (filter && object) {\n\t\t\t\t\t\t\tobject = $observable._fltr(allPath, object, parentObs, filter);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (object) {\n\t\t\t\t\t\t\tobserveOnOff(cb, object, undefined, arrayChangeStr + \".observe\" + getCbKey(cb), undefined, true, unbind);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tallPath = prevAllPath;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tfunction observeObjects(paths) {\n\n\t\t\t\tfunction observeObjectPaths(object, pths, callback, contextCb) {\n\n\t\t\t\t\tfunction getInnerCb(exprOb) {\n\t\t\t\t\t\texprOb.ob = contextCb(exprOb); // Initialize object\n\t\t\t\t\t\treturn exprOb.cb = function(ev, eventArgs) {\n\t\t\t\t\t\t\t// The innerCb used for updating a computed in a compiled expression (setting the new instance as exprOb.ob, unobserving the previous object,\n\t\t\t\t\t\t\t// and observing the new one), then calling the outerCB - i.e. the handler for the whole compiled expression.\n\t\t\t\t\t\t\t// Initialized exprOb.ob to the current object.\n\t\t\t\t\t\t\t// Uses the contextCb callback to execute the compiled exprOb template in the context of the view/data etc. to get the returned value, typically an object or array.\n\t\t\t\t\t\t\t// If it is an array, registers array binding\n\t\t\t\t\t\t\t// Note: For jsviews/issues/292 ctxCb will need var ctxCb = contextCb || function(exprOb, origRt) {return exprOb._cpfn(origRt);};\n\t\t\t\t\t\t\tvar obj = exprOb.ob, // The old object\n\t\t\t\t\t\t\t\tsub = exprOb.sb,\n\t\t\t\t\t\t\t\tnewObj = contextCb(exprOb);\n\n\t\t\t\t\t\t\tif (newObj !== obj) {\n\t\t\t\t\t\t\t\tif (typeof obj === OBJECT) {\n\t\t\t\t\t\t\t\t\tbindArray(callback, obj, true);\n\t\t\t\t\t\t\t\t\tif (sub || allowArray && $isArray(obj)) {\n\t\t\t\t\t\t\t\t\t\tinnerObserve([obj], sub, callback, contextCb, true); // unobserve on the old object\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\texprOb.ob = newObj;\n\t\t\t\t\t\t\t\t// Put the updated object instance onto the exprOb in the paths array, so subsequent string paths are relative to this object\n\t\t\t\t\t\t\t\tif (typeof newObj === OBJECT) {\n\t\t\t\t\t\t\t\t\tbindArray(callback, newObj);\n\t\t\t\t\t\t\t\t\tif (sub || allowArray && $isArray(newObj)) { // observe on new object\n\t\t\t\t\t\t\t\t\t\tinnerObserve([newObj], sub, callback, contextCb);\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t// Call the outerCb - to execute the compiled expression that this computed is part of\n\t\t\t\t\t\t\tcallback(ev, eventArgs);\n\t\t\t\t\t\t};\n\t\t\t\t\t}\n\n\t\t\t\t\tfunction observePath(object, prts) { // Step through the path parts \"this.is^some.path\" and observe changes (on the leaf, or down to the bound depth)\n\n\t\t\t\t\t\tfunction obArrAddRemove(ev, eventArgs) {\n\t\t\t\t\t\t\t// If a \"[].*\" or \"[].prop\" wild card path (for observing properties of array items) we need to observe or unobserve added or removed items\n\t\t\t\t\t\t\tvar l;\n\t\t\t\t\t\t\tif (eventArgs.change === \"insert\" || (unobserve = eventArgs.change === \"remove\")) {\n\t\t\t\t\t\t\t\tl = eventArgs.items.length;\n\t\t\t\t\t\t\t\twhile (l--) {\n\t\t\t\t\t\t\t\t\tobservePath(eventArgs.items[l], prts.slice());\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tunobserve = false;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif (callback) {\n\t\t\t\t\t\t\tobArrAddRemove._cId = getCbKey(callback); // Identify wrapped callback with unwrapped callback, so unobserveAll will\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// remove previous observeAll wrapped callback, if inner callback was the same;\n\t\t\t\t\t\t\tobArrAddRemove._inId = \".arIn\" + observeInnerCbKey++; // Specific _inId for each distinct obArrAddRemove, so not skipped as dups\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tvar arrIndex, skip, dep, obArr, prt, fnProp, isGet,\n\t\t\t\t\t\t\tobj = object;\n\t\t\t\t\t\tif (object && object._cxp) {\n\t\t\t\t\t\t\treturn observeObjectPaths(object[0], [object[1]], callback, contextCb);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\twhile ((prop = prts.shift()) !== undefined && prop !== \"__proto__\") { // Prevent prototype pollution attacks\n\t\t\t\t\t\t\tif (obj && typeof obj === OBJECT && typeof prop === STRING) {\n\t\t\t\t\t\t\t\tif (prop === \"\") {\n\t\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tif (prop.slice(-2) === \"()\") {\n\t\t\t\t\t\t\t\t\tprop = prop.slice(0, -2);\n\t\t\t\t\t\t\t\t\tisGet = true;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tif ((prts.length < depth + 1) && !obj.nodeType) {\n\t\t\t\t\t\t\t\t\t// Add observer for each token in path starting at depth, and on to the leaf\n\t\t\t\t\t\t\t\t\tif (!unobserve && (events = $._data(obj).events)) {\n\t\t\t\t\t\t\t\t\t\tevents = events && events[propertyChangeStr];\n\t\t\t\t\t\t\t\t\t\tel = events && events.length;\n\t\t\t\t\t\t\t\t\t\tskip = 0;\n\t\t\t\t\t\t\t\t\t\twhile (el--) { // Skip duplicates\n\t\t\t\t\t\t\t\t\t\t\tdata = events[el].data;\n\t\t\t\t\t\t\t\t\t\t\tif (data\n\t\t\t\t\t\t\t\t\t\t\t\t&& data.ns === initialNs\n\t\t\t\t\t\t\t\t\t\t\t\t&& data.cb._cId === callback._cId\n\t\t\t\t\t\t\t\t\t\t\t\t&& data.cb._inId === callback._inId\n\t\t\t\t\t\t\t\t\t\t\t\t&& !data._arOk === !allowArray\n\t\t\t\t\t\t\t\t\t\t\t\t&& (data.prop === prop || data.prop === \"*\" || data.prop === \"**\")) {\n\t\t\t\t\t\t\t\t\t\t\t\tif (prt = prts.join(\".\")) {\n\t\t\t\t\t\t\t\t\t\t\t\t\tdata.paths.push(prt); // We will skip this binding, but if it is not a leaf binding,\n\t\t\t\t\t\t\t\t\t\t\t\t\t// need to keep bindings for rest of path, ready for if the obj gets swapped.\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\tskip++;\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\tif (skip) {\n\t\t\t\t\t\t\t\t\t\t\t// Duplicate binding(s) found, so move on\n\t\t\t\t\t\t\t\t\t\t\tfnProp = obj[prop];\n\t\t\t\t\t\t\t\t\t\t\tobj = $isFunction(fnProp) ? fnProp.call(obj) : obj[prop];\n\t\t\t\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\tif (prop === \"*\" || prop === \"**\") { // \"*\" => all properties. \"**\" => all properties and sub-properties (i.e. deep observeAll behavior)\n\t\t\t\t\t\t\t\t\t\tif (!unobserve && events && events.length) {\n\t\t\t\t\t\t\t\t\t\t\t// Remove existing bindings, since they will be duplicates with \"*\" or \"**\"\n\t\t\t\t\t\t\t\t\t\t\tobserveOnOff(callback, obj, path, ns, \"\", false, true);\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\tif (prop === \"*\") {\n\t\t\t\t\t\t\t\t\t\t\tobserveOnOff(callback, obj, path, ns, \"\"); // observe the object for any property change\n\t\t\t\t\t\t\t\t\t\t\tfor (prt in obj) {\n\t\t\t\t\t\t\t\t\t\t\t\t// observing \"*\": So (in addition to listening to prop change, above) listen to arraychange on props of type array\n\t\t\t\t\t\t\t\t\t\t\t\tif (prt !== $expando) {\n\t\t\t\t\t\t\t\t\t\t\t\t\tbindArray(callback, obj, unobserve, undefined, prt);\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\t\t\t$.observable(initialNs, obj)[(unobserve ? \"un\" : \"\") + \"observeAll\"](callback); // observe or unobserve the object for any property change\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t} else if (prop == \"[]\") { // \"[].*\" or \"[].prop\" wild card path, for observing properties of array items\n\t\t\t\t\t\t\t\t\t\tif ($isArray(obj)) {\n\t\t\t\t\t\t\t\t\t\t\tif (unobserve) {\n\t\t\t\t\t\t\t\t\t\t\t\tobserveOnOff(callback, obj, path, arrayChangeStr + getCbKey(callback), undefined, unobserve, unobserve);\n\t\t\t\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\t\t\t\t$observe(initialNs, obj, obArrAddRemove, unobserve); // observe or unobserve added or removed items\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t} else if (prop) {\n\t\t\t\t\t\t\t\t\t\tobserveOnOff(callback, obj, path, ns + \".p_\" + prop, prts.join(\"^\")); // By using \"^\" rather than \".\" we ensure that deep binding will be used on newly inserted object graphs\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tif (allPath) {\n\t\t\t\t\t\t\t\t\tallPath += \".\" + prop;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tif (prop === \"[]\") {\n\t\t\t\t\t\t\t\t\tif ($isArray(obj)) {\n\t\t\t\t\t\t\t\t\t\tobArr = obj;\n\t\t\t\t\t\t\t\t\t\tarrIndex = obj.length;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\twhile (arrIndex--) {\n\t\t\t\t\t\t\t\t\t\tobj = obArr[arrIndex];\n\t\t\t\t\t\t\t\t\t\tobservePath(obj, prts.slice());\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tprop = obj[prop];\n\t\t\t\t\t\t\t\tif (!prts[0]) {\n\t\t\t\t\t\t\t\t\tbindArray(callback, prop, unobserve); // [un]observe(object, \"arrayProperty\") observes array changes on property of type array\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif ($isFunction(prop)) {\n\t\t\t\t\t\t\t\tfnProp = prop;\n\t\t\t\t\t\t\t\tif (dep = fnProp.depends) {\n\t\t\t\t\t\t\t\t\t// This is a computed observable. We will observe any declared dependencies.\n\t\t\t\t\t\t\t\t\tif (obj._vw && obj._ocp) {\n\t\t\t\t\t\t\t\t\t\t// Observable contextual parameter, so context was ocp object. Now move context to view.data for dependencies\n\t\t\t\t\t\t\t\t\t\tobj = obj._vw; // storeView or tag (scope of contextual parameter)\n\t\t\t\t\t\t\t\t\t\tif (obj._tgId) {\n\t\t\t\t\t\t\t\t\t\t\t// Is a tag, so get view\n\t\t\t\t\t\t\t\t\t\t\tobj = obj.tagCtx.view;\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\tobj = obj.data; // view.data\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\tobserveObjects(concat.apply([], [[obj], dependsPaths(dep, obj, callback)]));\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\tif (isGet) {\n\t\t\t\t\t\t\t\t\tif (!prts[0]) {\n\t\t\t\t\t\t\t\t\t\tbindArray(callback, fnProp.call(obj), unobserve);\n\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\tprop = fnProp.call(obj);\n\t\t\t\t\t\t\t\t\tif (!prop) {\n\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tobj = prop;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tvar i, path,\n\t\t\t\t\t\tdepth = 0,\n\t\t\t\t\t\tl = pths.length;\n\t\t\t\t\tif (object && !contextCb && ((view = object._is === \"view\") || object._is === \"tag\")) {\n\t\t\t\t\t\tcontextCb = $sub._gccb(view ? object : object.tagCtx.contentView);\n\t\t\t\t\t\tif (callback && !unobserve) {\n\t\t\t\t\t\t\t(function() {\n\t\t\t\t\t\t\t\tvar ob = object,\n\t\t\t\t\t\t\t\t\tcb = callback;\n\t\t\t\t\t\t\t\tcallback = function(ev, eventArgs) {\n\t\t\t\t\t\t\t\t\t// Wrapped callback so this pointer is tag or view\n\t\t\t\t\t\t\t\t\tcb.call(ob, ev, eventArgs);\n\t\t\t\t\t\t\t\t};\n\t\t\t\t\t\t\t\tcallback._cId = cb._cId;\n\t\t\t\t\t\t\t\tcallback._inId = cb._inId;\n\t\t\t\t\t\t\t})();\n\t\t\t\t\t\t}\n\t\t\t\t\t\tobject = view ? object.data : object;\n\t\t\t\t\t}\n\t\t\t\t\tif (!pths[0]) {\n\t\t\t\t\t\tif ($isArray(object)) {\n\t\t\t\t\t\t\tbindArray(callback, object, unobserve, true); // observe(array, handler)\n\t\t\t\t\t\t} else if (unobserve) {\n\t\t\t\t\t\t\tobserveOnOff(callback, object, undefined, ns, \"\"); // unobserve(objectOrArray[, handler])\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tfor (i = 0; i < l; i++) { // Step through objects and paths\n\t\t\t\t\t\tpath = pths[i];\n\t\t\t\t\t\tif (path === \"\") {\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (path && path._ar) {\n\t\t\t\t\t\t\tallowArray += path._ar; // Switch on allowArray for depends paths, and off, afterwards.\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (typeof path === STRING) {\n\t\t\t\t\t\t\tparts = path.split(\"^\");\n\t\t\t\t\t\t\tif (parts[1]) {\n\t\t\t\t\t\t\t\t// We bind the leaf, plus additional nodes based on depth.\n\t\t\t\t\t\t\t\t// \"a.b.c^d.e\" is depth 2, so listens to changes of e, plus changes of d and of c\n\t\t\t\t\t\t\t\tdepth = parts[0].split(\".\").length;\n\t\t\t\t\t\t\t\tpath = parts.join(\".\");\n\t\t\t\t\t\t\t\tdepth = path.split(\".\").length - depth;\n\t\t\t\t\t\t\t\t// if more than one ^ in the path, the first one determines depth\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif (contextCb && (items = contextCb(path, depth))) {\n\t\t\t\t\t\t\t\t//object, paths\n\t\t\t\t\t\t\t\tif (items.length) {\n\t\t\t\t\t\t\t\t\tvar ob = items[0],\n\t\t\t\t\t\t\t\t\t\tpth = items[1];\n\t\t\t\t\t\t\t\t\tif (ob && ob._cxp) { // contextual parameter\n\t\t\t\t\t\t\t\t\t\tpth = ob[1];\n\t\t\t\t\t\t\t\t\t\tob = ob[0];\n\t\t\t\t\t\t\t\t\t\tif (ob._is === \"view\") {\n\t\t\t\t\t\t\t\t\t\t\tobserveObjectPaths(ob, [pth], callback); // Setting contextCb to undefined, to use passed in view for new contextCb\n\t\t\t\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\tif (typeof pth === STRING) {\n\t\t\t\t\t\t\t\t\t\tobservePath(ob, pth.split(\".\"));\n\t\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\t\tobserveObjectPaths(items.shift(), items, callback, contextCb);\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tobservePath(object, path.split(\".\"));\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else if (!$isFunction(path) && path && path._cpfn) {\n\t\t\t\t\t\t\t// Path is an exprOb returned by a computed property - helper/data function (compiled expr function).\n\t\t\t\t\t\t\t// Get innerCb for updating the object\n\t\t\t\t\t\t\tinnerCb = unobserve ? path.cb || (path.cb = callback) : getInnerCb(path); // https://github.com/BorisMoore/jsviews/issues/463#issuecomment-2651496030\n\t\t\t\t\t\t\t// innerCb._ctx = callback._ctx; Could pass context (e.g. linkCtx) for use in a depends = function() {} call, so depends is different for different linkCtx's\n\t\t\t\t\t\t\tinnerCb._cId = callback._cId;\n\t\t\t\t\t\t\t// Set the same cbBindingsStore key as for callback, so when callback is disposed, disposal of innerCb happens too.\n\t\t\t\t\t\t\tinnerCb._inId = innerCb._inId || \".obIn\" + observeInnerCbKey++;\n\t\t\t\t\t\t\tif (path.bnd || path.prm && path.prm.length || !path.sb) {\n\t\t\t\t\t\t\t\t// If the exprOb is bound e.g. foo()^sub.path, or has parameters e.g. foo(bar) or is a leaf object (so no sub path) e.g. foo()\n\t\t\t\t\t\t\t\t// then observe changes on the object, or its parameters and sub-path\n\t\t\t\t\t\t\t\tinnerObserve([object], path.path, (path.prm.length ? [path.root||object] : []), path.prm, innerCb, contextCb, unobserve);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif (path.sb) { // Has a subPath\n\t\t\t\t\t\t\t\t// Observe changes on the sub-path\n\t\t\t\t\t\t\t\tif (path.sb.prm) {\n\t\t\t\t\t\t\t\t\tpath.sb.root = object;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t// Set current object on exprOb.ob\n\t\t\t\t\t\t\t\tobserveObjectPaths(path.ob, [path.sb], callback, contextCb);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tvar pth,\n\t\t\t\t\tpths = [], // Array of paths for current object\n\t\t\t\t\tl = paths.length;\n\t\t\t\twhile (l--) { // Step backwards through paths and objects\n\t\t\t\t\tpth = paths[l];\n\t\t\t\t\tif (typeof pth === STRING || pth && (pth._ar || pth._cpfn)) {\n\t\t\t\t\t\tpths.unshift(pth); // This is a path so add to arr\n\t\t\t\t\t} else { // This is an object\n\t\t\t\t\t\tobserveObjectPaths(pth, pths, callback, contextCb);\n\t\t\t\t\t\tpths = []; // New array for next object\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n//END OF FUNCTIONS\n\n\t\t\tvar ns = observeStr,\n\t\t\t\tpaths = this != 1 // Using != for IE<10 bug- see jsviews/issues/237\n\t\t\t\t\t? concat.apply([], arguments) // Flatten the arguments - this is a 'recursive call' with params using the 'wrapped array'\n\t\t\t\t\t\t\t\t\t\t\t\t\t// style - such as innerObserve([object], path.path, [origRoot], path.prm, innerCb, ...);\n\t\t\t\t\t: slice.call(arguments), // Don't flatten - this is the first 'top-level call, to innerObserve.apply(1, paths)\n\t\t\t\tlastArg = paths.pop() || false,\n\t\t\t\tm = paths.length;\n\n\t\t\tif (typeof lastArg === STRING) { // If last arg is a string then this observe call is part of an observeAll call,\n\t\t\t\tallPath = lastArg;           // and the last three args are the filter, the parentObs array, and the allPath string.\n\t\t\t\tparentObs = paths.pop();\n\t\t\t\tfilter = paths.pop();\n\t\t\t\tlastArg = !!paths.pop(); // unobserve\n\t\t\t\tm -= 3;\n\t\t\t}\n\t\t\tif (lastArg === !!lastArg) {\n\t\t\t\tunobserve = lastArg;\n\t\t\t\tlastArg = paths[m-1];\n\t\t\t\tlastArg = m && typeof lastArg !== STRING && (!lastArg || $isFunction(lastArg)) ? (m--, paths.pop()) : undefined;\n\t\t\t\tif (unobserve && !m && $isFunction(paths[0])) {\n\t\t\t\t\tlastArg = paths.shift();\n\t\t\t\t}\n\t\t\t}\n\t\t\tcallback = lastArg;\n\t\t\tif (m && $isFunction(paths[m - 1])) {\n\t\t\t\tcontextCb = callback;\n\t\t\t\tlastArg = callback = paths.pop();\n\t\t\t\tm--;\n\t\t\t}\n\n\t\t\tif (unobserve && callback && !callback._cId) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// Use a unique namespace (e.g. obs7) associated with each observe() callback to allow unobserve to remove handlers\n\t\t\tns += callback\n\t\t\t\t? ((inId = callback._inId || \"\"), unobserve)\n\t\t\t\t\t? callback._cId + inId\n\t\t\t\t\t: (cbId = getCbKey(callback)) + inId\n\t\t\t\t: \"\";\n\n\t\t\tif (cbId && !unobserve) {\n\t\t\t\tcbBindings = cbBindingsStore[cbId] = cbBindingsStore[cbId] || {len: 0};\n\t\t\t}\n\n\t\t\tinitNsArr = initialNs && initialNs.match(rNotWhite) || [\"\"];\n\t\t\tinitNsArrLen = initNsArr.length;\n\n\t\t\twhile (initNsArrLen--) { // Step through multiple white-space separated namespaces if there are any\n\t\t\t\tinitialNs = initNsArr[initNsArrLen];\n\t\t\t\tif (unobserve && arguments.length < 3) {\n\t\t\t\t\tif (callback) {\n\t\t\t\t\t\tunobserveBinding(callback, cbBindingsStore[callback._cId]); // unobserve(handler) - unobserves this handler, all objects\n\t\t\t\t\t} else if (!paths[0]) {\n\t\t\t\t\t\tfor (p in cbBindingsStore) {\n\t\t\t\t\t\t\tunobserveBinding(callback, cbBindingsStore[p]); // unobserve() - unobserves all\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tobserveObjects(paths);\n\t\t\t}\n\t\t\tif (cbId && !cbBindings.len) {\n\t\t\t\t// If the cbBindings collection is empty we will remove it from the cbBindingsStore\n\t\t\t\tdelete cbBindingsStore[cbId];\n\t\t\t}\n\n\t\t\t// Return the cbBindings to the top-level caller, along with the cbId\n\t\t\treturn {cbId: cbId, bnd: cbBindings, s: cbBindingsStore};\n\t\t}\n\n\t\tvar initialNs,\n\t\t\tallowArray = this == 1 ? 0 : 1, // If this == 1, this is a call from observeAndBind (doing binding of datalink expressions),\n\t\t\t// and tag.onArrayChange is not set to true. We don't bind arrayChange events in this scenario. Instead, {^{for}} and similar\n\t\t\t// do specific arrayChange binding to the tagCtx.args[0] value, in onAfterLink.\n\t\t\t// Note deliberately using this == 1, rather than this === 1 because of IE<10 bug - see jsviews/issues/237\n\t\t\tpaths = slice.call(arguments),\n\t\t\tpth = paths[0];\n\n\t\tif (typeof pth === STRING) {\n\t\t\tinitialNs = pth; // The first arg is a namespace, since it is a string\n\t\t\tpaths.shift();\n\t\t}\n\t\treturn innerObserve.apply(1, paths);\n\t};\n\n\tasyncBatch.wait = function() {\n\t\tvar batch = this;\n\t\tbatch._go = 1;\n\t\tsetTimeout(function() {\n\t\t\tbatch.trigger(true);\n\t\t\tbatch._go = 0;\n\t\t\tbatch.paths = {};\n\t\t});\n\t};\n\n\t$observable = function(ns, data, delay) {\n\t\tif (typeof ns !== STRING) {\n\t\t\tdelay = data;\n\t\t\tdata = ns;\n\t\t\tns = \"\";\n\t\t}\n\t\tdelay = delay === undefined ? $subSettingsAdvanced.asyncObserve : delay;\n\t\tvar observable = $isArray(data)\n\t\t\t? new ArrayObservable(ns, data)\n\t\t\t: new ObjectObservable(ns, data);\n\t\tif (delay) {\n\t\t\tif (delay === true) {\n\t\t\t\tobservable.async = true;\n\t\t\t\tdelay = asyncBatch;\n\t\t\t}\n\t\t\tif (!delay.trigger) {\n\t\t\t\tif ($isArray(delay)) {\n\t\t\t\t\tdelay.trigger = batchTrigger;\n\t\t\t\t\tdelay.paths = {};\n\t\t\t\t} else {\n\t\t\t\t\tdelay = undefined;\n\t\t\t\t}\n\t\t\t}\n\t\t\tobservable._batch = delay;\n\t\t}\n\t\treturn observable;\n\t};\n\n\t//========================== Initialize ==========================\n\n\t$.observable = $observable;\n\t$observable._fltr = function(path, object, parentObs, filter) {\n\t\tif (filter && $isFunction(filter) && (typeof object === OBJECT || $isFunction(object))\n\t\t\t? filter(path, object, parentObs)\n\t\t\t: true // TODO Consider supporting filter being a string or strings to do RegEx filtering based on key and/or path\n\t\t) {\n\t\t\tobject = $isFunction(object)\n\t\t\t\t? object.set && object.call(parentObs[0]) // It is a getter/setter\n\t\t\t\t: object;\n\t\t\treturn typeof object === OBJECT && object;\n\t\t}\n\t};\n\n\t$observable.Object = ObjectObservable;\n\t$observable.Array = ArrayObservable;\n\t$.observe = $observable.observe = $observe;\n\t$.unobserve = $observable.unobserve = $unobserve;\n\t$observable._apply = observe_apply;\n\n\tObjectObservable.prototype = {\n\t\t_data: null,\n\n\t\tobserveAll: $observeAll,\n\t\tunobserveAll: $unobserveAll,\n\n\t\tdata: function() {\n\t\t\treturn this._data;\n\t\t},\n\n\t\tsetProperty: function(path, value, nonStrict, isCpfn) {\n\t\t\tpath = path || \"\";\n\t\t\tvar key, pair, parts, tempBatch,\n\t\t\t\tmulti = typeof path !== STRING, // Hash of paths\n\t\t\t\tself = this,\n\t\t\t\tobject = self._data,\n\t\t\t\tbatch = self._batch;\n\n\t\t\tif (object) {\n\t\t\t\tif (multi) {\n\t\t\t\t\tnonStrict = value;\n\t\t\t\t\tif ($isArray(path)) {\n\t\t\t\t\t\t// This is the array format generated by serializeArray. However, this has the problem that it coerces types to string,\n\t\t\t\t\t\t// and does not provide simple support of convertTo and convertFrom functions.\n\t\t\t\t\t\tkey = path.length;\n\t\t\t\t\t\twhile (key--) {\n\t\t\t\t\t\t\tpair = path[key];\n\t\t\t\t\t\t\tself.setProperty(pair.name, pair.value, nonStrict === undefined || nonStrict); //If nonStrict not specified, default to true;\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tif (!batch) {\n\t\t\t\t\t\t\tself._batch = tempBatch = [];\n\t\t\t\t\t\t\ttempBatch.trigger = batchTrigger;\n\t\t\t\t\t\t\ttempBatch.paths = {};\n\t\t\t\t\t\t}\n\t\t\t\t\t\tfor (key in path) { // Object representation where property name is path and property value is value.\n\t\t\t\t\t\t\tself.setProperty(key, path[key], nonStrict);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (tempBatch) {\n\t\t\t\t\t\t\tself._batch.trigger();\n\t\t\t\t\t\t\tself._batch = undefined;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} else if (path !== $expando) {\n\t\t\t\t\t// Simple single property case.\n\t\t\t\t\tparts = path.split(/[.^]/);\n\t\t\t\t\twhile (object && parts.length > 1) {\n\t\t\t\t\t\tkey = parts.shift();\n\t\t\t\t\t\tobject = key !== \"__proto__\" ? object[key] : undefined; // Avoid prototype pollution\n\t\t\t\t\t}\n\t\t\t\t\tif (object) {\n\t\t\t\t\t\tself._setProperty(object, parts[0], value, nonStrict, isCpfn);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn self;\n\t\t},\n\n\t\tremoveProperty: function(path) {\n\t\t\tthis.setProperty(path, remove);\n\t\t\treturn this;\n\t\t},\n\n\t\t_setProperty: function(leaf, path, value, nonStrict, isCpfn) {\n\t\t\tvar setter, getter, removeProp, eventArgs, view,\n\t\t\t\tproperty = path ? leaf[path] : leaf;\n\t\t\tif ($isFunction(property) && !$isFunction(value)) {\n\t\t\t\tif (isCpfn && !property.set) {\n\t\t\t\t\treturn; // getter function with no setter defined. So will not trigger update\n\t\t\t\t}\telse if (property.set) {\n\t\t\t\t\t// Case of property setter/getter - with convention that property is getter and property.set is setter\n\t\t\t\t\tview = leaf._vw // Case of JsViews 2-way data-linking to an observable context parameter, with a setter.\n\t\t\t\t\t\t// The view will be the this pointer for getter and setter. Note: this is the one scenario where path is \"\".\n\t\t\t\t\t\t|| leaf;\n\t\t\t\t\tgetter = property;\n\t\t\t\t\tsetter = getter.set === true ? getter : getter.set;\n\t\t\t\t\tproperty = getter.call(view); // get - only treated as getter if also a setter. Otherwise it is simply a property of type function.\n\t\t\t\t\t// See unit tests 'Can observe properties of type function'.\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (property !== value || nonStrict && property != value) {\n\t\t\t\t// Optional non-strict equality, since serializeArray, and form-based editors can map numbers to strings, etc.\n\t\t\t\t// Date objects don't support != comparison. Treat as special case.\n\t\t\t\tif (!(property instanceof Date && value instanceof Date) || property > value || property < value) {\n\t\t\t\t\tif (setter) {\n\t\t\t\t\t\tsetter.call(view, value);   // set\n\t\t\t\t\t\tvalue = getter.call(view);  // get updated value\n\t\t\t\t\t} else if (removeProp = value === remove) {\n\t\t\t\t\t\tif (property !== undefined) {\n\t\t\t\t\t\t\tdelete leaf[path];\n\t\t\t\t\t\t\tvalue = undefined;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tpath = undefined; // If value was already undefined, don't trigger handler for removeProp\n\t\t\t\t\t\t}\n\t\t\t\t\t} else if (path) {\n\t\t\t\t\t\tleaf[path] = value;\n\t\t\t\t\t}\n\t\t\t\t\tif (path) {\n\t\t\t\t\t\teventArgs = {change: \"set\", path: path, value: value, oldValue: property, remove: removeProp};\n\t\t\t\t\t\tif (leaf._ocp) {\n\t\t\t\t\t\t\teventArgs.ctxPrm = leaf._key;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tthis._trigger(leaf, eventArgs);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t},\n\n\t\t_trigger: function(target, eventArgs, force) {\n\t\t\t$subSettings._cchCt++; // Since we are making observable data change, increment cacheCounter to clear cached values and recompute\n\t\t\tvar key, batch, previous,\n\t\t\t\tself = this;\n\t\t\tif ($.hasData(target)) {\n\t\t\t\tif (!force && (batch = self._batch)) {\n\t\t\t\t\tif (self.async && !batch._go) {\n\t\t\t\t\t\tbatch.wait();\n\t\t\t\t\t}\n\t\t\t\t\tbatch.push([self, target, eventArgs]);\n\t\t\t\t\tkey = $data(target).obId + eventArgs.path;\n\t\t\t\t\tif (previous = batch.paths[key]) {\n\t\t\t\t\t\tbatch[previous-1].skip = 1;\n\t\t\t\t\t}\n\t\t\t\t\tbatch.paths[key] = batch.length;\n\t\t\t\t} else {\n\t\t\t\t\t$(target).triggerHandler(propertyChangeStr + (this._ns ? \".\" + /^\\S+/.exec(this._ns)[0] : \"\"), eventArgs); // If white-space separated namespaces, use first one only\n\t\t\t\t\teventArgs.oldValue = null; // Avoid holding on to stale objects\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t};\n\n\tArrayObservable.prototype = {\n\t\t_data: null,\n\n\t\tobserveAll: $observeAll,\n\t\tunobserveAll: $unobserveAll,\n\n\t\tdata: function() {\n\t\t\treturn this._data;\n\t\t},\n\n\t\tinsert: function(index, data) {\n\t\t\tvar _data = this._data;\n\t\t\tif (arguments.length === 1) {\n\t\t\t\tdata = index;\n\t\t\t\tindex = _data.length;\n\t\t\t}\n\t\t\tindex = PARSEINT(index);\n\t\t\tif (index > -1) {\n\t\t\t\tdata = $isArray(data) ? data : [data];\n\t\t\t\t// data can be a single item (including a null/undefined value) or an array of items.\n\t\t\t\t// Note the provided items are inserted without being cloned, as direct references to the provided objects\n\n\t\t\t\tif (data.length) {\n\t\t\t\t\tthis._insert(index, data);\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn this;\n\t\t},\n\n\t\t_insert: function(index, data) {\n\t\t\tvar _data = this._data,\n\t\t\t\toldLength = _data.length;\n\t\t\tif (index > oldLength) {\n\t\t\t\tindex = oldLength;\n\t\t\t}\n\t\t\tsplice.apply(_data, [index, 0].concat(data));\n\t\t\tthis._trigger({change: \"insert\", index: index, items: data}, oldLength);\n\t\t},\n\n\t\tremove: function(index, numToRemove) {\n\t\t\tvar items,\n\t\t\t\t_data = this._data;\n\n\t\t\tif (index === undefined) {\n\t\t\t\tindex = _data.length - 1;\n\t\t\t}\n\n\t\t\tindex = PARSEINT(index);\n\t\t\tnumToRemove = numToRemove ? PARSEINT(numToRemove) : numToRemove === 0 ? 0 : 1; // if null or undefined: remove 1\n\t\t\tif (numToRemove > 0 && index > -1) {\n\t\t\t\titems = _data.slice(index, index + numToRemove);\n\t\t\t\tif (numToRemove = items.length) {\n\t\t\t\t\tthis._remove(index, numToRemove, items);\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn this;\n\t\t},\n\n\t\t_remove: function(index, numToRemove, items) {\n\t\t\tvar _data = this._data,\n\t\t\t\toldLength = _data.length;\n\n\t\t\t_data.splice(index, numToRemove);\n\t\t\tthis._trigger({change: \"remove\", index: index, items: items}, oldLength);\n\t\t},\n\n\t\tmove: function(oldIndex, newIndex, numToMove) {\n\t\t\tnumToMove = numToMove ? PARSEINT(numToMove) : numToMove === 0 ? 0 : 1; // if null or undefined: move 1\n\t\t\toldIndex = PARSEINT(oldIndex);\n\t\t\tnewIndex = PARSEINT(newIndex);\n\n\t\t\tif (numToMove > 0 && oldIndex > -1 && newIndex > -1 && oldIndex !== newIndex) {\n\t\t\t\tthis._move(oldIndex, newIndex, numToMove);\n\t\t\t}\n\t\t\treturn this;\n\t\t},\n\n\t\t_move: function(oldIndex, newIndex, numToMove) {\n\t\t\tvar items,\n\t\t\t\t_data = this._data,\n\t\t\t\toldLength = _data.length,\n\t\t\t\texcess = oldIndex + numToMove - oldLength;\n\t\t\tif (excess > 0) {\n\t\t\t\tnumToMove -= excess;\n\t\t\t}\n\t\t\tif (numToMove) {\n\t\t\t\titems = _data.splice(oldIndex, numToMove); // remove\n\t\t\t\tif (newIndex > _data.length) {\n\t\t\t\t\tnewIndex = _data.length;\n\t\t\t\t}\n\t\t\t\tsplice.apply(_data, [newIndex, 0].concat(items)); //re-insert\n\t\t\t\tif (newIndex !== oldIndex) {\n\t\t\t\t\tthis._trigger({change: \"move\", oldIndex: oldIndex, index: newIndex, items: items}, oldLength);\n\t\t\t\t}\n\t\t\t}\n\t\t},\n\n\t\trefresh: function(newItems) {\n\t\t\tfunction insertAdded() {\n\t\t\t\tif (k) {\n\t\t\t\t\tself.insert(j-k, addedItems); // Not found in original array - so insert\n\t\t\t\t\tdataLength += k;\n\t\t\t\t\ti += k;\n\t\t\t\t\tk = 0;\n\t\t\t\t\taddedItems = [];\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// For refresh operation we iteratively step through the target array and sort by move/add/remove operations on the source array until they match\n\t\t\tvar i, j, k, newItem, num,\n\t\t\t\tself = this,\n\t\t\t\taddedItems = [],\n\t\t\t\tdata = self._data,\n\t\t\t\toldItems = data.slice(),\n\t\t\t\toldLength = data.length,\n\t\t\t\tdataLength = oldLength,\n\t\t\t\tnewLength = newItems.length;\n\t\t\tself._srt = true; // Flag for sorting during refresh\n\t\t\tfor (j=k=0; j<newLength; j++) {\n\t\t\t\tif ((newItem = newItems[j]) === data[j-k]) {\n\t\t\t\t\tinsertAdded();\n\t\t\t\t} else {\n\t\t\t\t\tfor (i=j-k; i<dataLength && newItem !== data[i]; i++) {}\n\t\t\t\t\tif (i<dataLength) {\n\t\t\t\t\t\tinsertAdded();\n\t\t\t\t\t\tnum = 0;\n\t\t\t\t\t\twhile (num++ < newLength-i && newItems[j+num] === data[i+num]);\n\t\t\t\t\t\tself.move(i, j, num); // Found newItem in original array - so move it to new position\n\t\t\t\t\t\tj += num - 1;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tk++;\n\t\t\t\t\t\taddedItems.push(newItem); // Not found in original array - so insert\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tinsertAdded();\n\t\t\tif (dataLength > j) {\n\t\t\t\tself.remove(j, dataLength - j);\n\t\t\t}\n\t\t\tself._srt = undefined; // We have finished sort operations during refresh\n\t\t\tif (oldLength || newLength) {\n\t\t\t\tself._trigger({change: \"refresh\", oldItems: oldItems}, oldLength);\n\t\t\t}\n\t\t\treturn self;\n\t\t},\n\n\t\t_trigger: function(eventArgs, oldLength, force) {\n\t\t\t$subSettings._cchCt++; // Since we are making observable data change, increment cacheCounter to clear cached values and recompute\n\t\t\tvar length, _data, batch,\n\t\t\t\tself = this;\n\t\t\tif ($.hasData(_data = self._data)) {\n\t\t\t\tif (!force && (batch = self._batch)) {\n\t\t\t\t\teventArgs._dly = true; // Delayed event (async or batch change)\n\t\t\t\t\tbatch.push([self, eventArgs, oldLength]);\n\t\t\t\t\tif (self.async && !batch._go) {\n\t\t\t\t\t\tbatch.wait();\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tlength = _data.length;\n\t\t\t\t\t_data = $([_data]);\n\n\t\t\t\t\tif (self._srt) {\n\t\t\t\t\t\teventArgs.refresh = true; // We are sorting during refresh\n\t\t\t\t\t} else if (length !== oldLength) { // We have finished sort operations during refresh\n\t\t\t\t\t\t_data.triggerHandler(propertyChangeStr, {change: \"set\", path: \"length\", value: length, oldValue: oldLength});\n\t\t\t\t\t}\n\t\t\t\t\t_data.triggerHandler(arrayChangeStr + (self._ns ? \".\" + /^\\S+/.exec(self._ns)[0] : \"\"), eventArgs); // If white-space separated namespaces, use first one only\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t};\n\n\t$eventSpecial[propertyChangeStr] = $eventSpecial[arrayChangeStr] = {\n\t\t// Register a jQuery special 'remove' event, to access the data associated with handlers being removed by jQuery.off().\n\t\t// We get data.cb._cId from the event handleObj and get the corresponding cbBindings hash from the cbBindingsStore,\n\t\t// then remove this object from that bindings hash - if the object does not have any other handlers associated with the same callback.\n\t\tremove: function (handleObj) {\n\t\t\tvar cbBindings, found, events, l, data,\n\t\t\t\tevData = handleObj.data;\n\t\t\tif ((evData) && (evData.off = true, evData = evData.cb)) { //Set off = true as marker for disposed event\n\t\t\t\t// Get the cb._cId from handleObj.data.cb._cId\n\t\t\t\tif (cbBindings = cbBindingsStore[evData._cId]) {\n\t\t\t\t\t// There were bindings for this callback. If this was the last one, we'll remove it.\n\t\t\t\t\tevents = $._data(this).events[handleObj.type];\n\t\t\t\t\tl = events.length;\n\t\t\t\t\twhile (l-- && !found) {\n\t\t\t\t\t\tfound = (data = events[l].data) && data.cb && data.cb._cId === evData._cId;\n\t\t\t\t\t\t// Found another one with same callback (though may be a different innerCallback)\n\t\t\t\t\t}\n\t\t\t\t\tif (!found) {\n\t\t\t\t\t\tif (--cbBindings.len) {\n\t\t\t\t\t\t\tdelete cbBindings[$data(this).obId];\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tdelete cbBindingsStore[evData._cId]; // If the cbBindings collection is empty we will remove it from the cbBindingsStore\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t};\n\n//==========================\n// dataMap with data-linking\n//==========================\n\n\t$views.map = function(mapDef) {\n\t\tfunction Map(source, options, oldMapOrTarget, unbound) {\n\t\t\tvar changing, updatedMap,\n\t\t\t\tmap = this;\n\t\t\tif (map.src) {\n\t\t\t\tmap.unmap(); // We are re-mapping a new source\n\t\t\t}\n\t\t\tif (options) {\n\t\t\t\toptions.map = map;\n\t\t\t}\n\t\t\tif (typeof source === OBJECT || $isFunction(source)) {\n\t\t\t\tmap.src = source;\n\t\t\t\tif (unbound) {\n\t\t\t\t\tmap.tgt = mapDef.getTgt(source, options);\n\t\t\t\t} else {\n\t\t\t\t\tif (oldMapOrTarget) {\n\t\t\t\t\t\tmap.tgt = oldMapOrTarget.tgt || $isArray(oldMapOrTarget) && oldMapOrTarget; // Can provide an existing map, or a target array to be used on new map\n\t\t\t\t\t}\n\t\t\t\t\tmap.tgt = map.tgt || [];\n\t\t\t\t\tmap.options = options || map.options;\n\t\t\t\t\tif (updatedMap = map.update()) {\n\t\t\t\t\t\tmap = updatedMap; // If updating returns another map, then we can replace this one (so no need to bind it)\n\t\t\t\t\t} else {\n\t\t\t\t\t\tif (mapDef.obsSrc) {\n\t\t\t\t\t\t\t$observable(map.src).observeAll(map.obs = function(ev, eventArgs) {\n\t\t\t\t\t\t\t\tif (!changing && !eventArgs.refresh) {\n\t\t\t\t\t\t\t\t\tchanging = true;\n\t\t\t\t\t\t\t\t\tmapDef.obsSrc(map, ev, eventArgs);\n\t\t\t\t\t\t\t\t\tchanging = undefined;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}, map.srcFlt);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (mapDef.obsTgt) {\n\t\t\t\t\t\t\t$observable(map.tgt).observeAll(map.obt = function(ev, eventArgs) {\n\t\t\t\t\t\t\t\tif (!changing && !map.tgt._updt) {\n\t\t\t\t\t\t\t\t\tchanging = true;\n\t\t\t\t\t\t\t\t\tmapDef.obsTgt(map, ev, eventArgs);\n\t\t\t\t\t\t\t\t\tchanging = undefined;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}, map.tgtFlt);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif ($isFunction(mapDef)) {\n\t\t\t// Simple map declared as function\n\t\t\tmapDef = {\n\t\t\t\tgetTgt: mapDef\n\t\t\t};\n\t\t}\n\n\t\tif (mapDef.baseMap) {\n\t\t\tmapDef = $.extend({}, mapDef.baseMap, mapDef);\n\t\t}\n\n\t\tmapDef.map = function(source, options, oldMap, unbound) {\n\t\t\treturn new Map(source, options, oldMap, unbound);\n\t\t};\n\n\t\t(Map.prototype = {\n\t\t\tsrcFlt: mapDef.srcFlt || shallowFilter, // default to shallowFilter\n\t\t\ttgtFlt: mapDef.tgtFlt || shallowFilter,\n\t\t\tupdate: function(options) {\n\t\t\t\tvar oldMap, newMap,\n\t\t\t\t\tmap = this,\n\t\t\t\t\ttgt = map.tgt;\n\t\t\t\tif (!tgt._updt) {\n\t\t\t\t\ttgt._updt = true;\n\t\t\t\t\toldMap = map.options && map.options.map;\n\t\t\t\t\t$observable(tgt).refresh(mapDef.getTgt(map.src, map.options = options || map.options));\n\t\t\t\t\ttgt._updt = false;\n\t\t\t\t\tnewMap = map.options && map.options.map;\n\t\t\t\t\tif (newMap && oldMap !== newMap) {\n\t\t\t\t\t\treturn newMap;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t},\n\t\t\tobserve: function(deps, linkCtx) { // Listen to observable changes of mapProps, and call map.update when change happens\n\t\t\t\tvar map = this,\n\t\t\t\t\toptions = map.options;\n\t\t\t\tif (map.obmp) {\n\t\t\t\t\t// There is a previous handler observing the mapProps\n\t\t\t\t\t$unobserve(map.obmp);\n\t\t\t\t}\n\t\t\t\tmap.obmp = function() {\n\t\t\t\t\t// Observe changes in the mapProps (\"filter\", \"sort\", \"reverse\", \"start\", \"end\")\n\t\t\t\t\tvar newTagCtx = linkCtx.fn(linkCtx.data, linkCtx.view, $sub)[options.index]; // Updated tagCtx props and args\n\t\t\t\t\t$.extend(options.props, newTagCtx.props); // Update props to new values\n\t\t\t\t\toptions.args = newTagCtx.args; // Update args to new values\n\t\t\t\t\tmap.update(); // Update the map target array, based on new mapProp values\n\t\t\t\t};\n\t\t\t\t$observable._apply(1, linkCtx.data, dependsPaths(deps, linkCtx.tag, map.obmp), map.obmp, linkCtx._ctxCb);\n\t\t\t},\n\t\t\tunmap: function() {\n\t\t\t\tvar map = this;\n\t\t\t\tif (map.src && map.obs) {\n\t\t\t\t\t$observable(map.src).unobserveAll(map.obs, map.srcFlt);\n\t\t\t\t}\n\t\t\t\tif (map.tgt && map.obt) {\n\t\t\t\t\t$observable(map.tgt).unobserveAll(map.obt, map.tgtFlt);\n\t\t\t\t}\n\t\t\t\tif (map.obmp) {\n\t\t\t\t\t$unobserve(map.obmp);\n\t\t\t\t}\n\t\t\t\tmap.src = undefined;\n\t\t\t},\n\t\t\tmap: Map,\n\t\t\t_def: mapDef\n\t\t}).constructor = Map;\n\n\t\treturn mapDef;\n\t};\n\n\t$sub.advSet = function() { // refresh advanced settings\n\t\t$sub = this; // If JsRender is loaded after jquery.observable, then this sets $sub to $.views.sub\n\t\t$subSettingsAdvanced = $subSettings.advanced;\n\t\tglobal._jsv = $subSettingsAdvanced._jsv\n\t\t\t? { // create global _jsv, for accessing views, etc\n\t\t\t\t\tcbBindings: cbBindingsStore\n\t\t\t\t}\n\t\t\t: undefined; // In IE8 cannot do delete global._jsv\n\t};\n\t$sub._dp = dependsPaths;\n\t$sub._gck = getCbKey;\n\t$sub._obs = $observe;\n\t$subSettings._cchCt = 0; // Counter for clearing cached values for getCache() call\n\t$subSettingsAdvanced = $subSettings.advanced = $subSettingsAdvanced || {\n\t\tuseViews: false,\n\t\t_jsv: false // For global access to JsViews store\n\t};\n}\n\nreturn $;\n}, window));\n"]}